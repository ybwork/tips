Ограничения

    Если нужно чтобы значение столбца не встречалось в других записях, используем constraints

Основы архитектуры.

	PostgreSQL реализован в архитектуре клиент-сервер.

	Главный серверный процесс, управляющий файлами баз данных, принимающий подключения клиентских приложений и выполняющий различные запросы клиентов к базам данных. Эта программа сервера БД называется postgres.

	Клиентские приложения могут быть очень разнообразными: это может быть текстовая утилита, графическое приложение, веб-сервер, использующий базу данных для отображения веб-страниц.

	Сервер PostgreSQL может обслуживать одновременно несколько подключений клиентов. Для этого он запускает («порождает») отдельный процесс для каждого подключения. Можно сказать, что клиент и серверный процесс общаются, не затрагивая главный процесс postgres. 

Создание базы данных.

	createdb mydb

	Имена баз данных должны начинаться с буквы и быть не длиннее 63 символов.

	dropdb mydb

Подключение к базе данных.

	Создав базу данных, вы можете обратиться к ней запустив терминальную программу PostgreSQL под названием psql, в которой можно интерактивно вводить, редактировать и выполнять команды SQL.

	psql mydb

	Чтобы выйти из psql, введите: \q или просто q

Основные понятия.

	PostgreSQL — это реляционная система управления базами данных. 

	Это означает, что это система управления данными, представленными в виде отношений (relation). Отношение — это математически точное обозначение таблицы. То есть данные хранятся в таблицах.

	Любая таблица представляет собой именованный набор строк. Все строки таблицы имеют одинаковый набор именованных столбцов, при этом каждому столбцу назначается определённый тип данных.

	Таблицы объединяются в базы данных, а набор баз данных, управляемый одним экземпляром сервера PostgreSQL, образует кластер баз данных.

Основные команды.

	CREATE TABLE users (
		name varchar(80)
	);

	DROP TABLE table_name;

Создание.

	INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');

    COPY weather FROM '/home/user/weather.txt'; - загрузка большого объёма данных из обычных текстовых файлов

Простая выборка.

    SELECT DISTINCT name, surname, phone FROM users WHERE surnamr = 'Kaduk' AND phone = 89081996450 ORDER BY name;

Соединения таблиц.

	Хорошим стилем считается указывать полные имена столбцов в запросе соединения, чтобы запрос не поломался, если позже в таблицы будут добавлены столбцы с повторяющимися именами.

    	SELECT name, city, date, location FROM weather, cities WHERE cities.name = weather.city;

    	SELECT name, city, date, location FROM weather INNER JOIN cities ON (weather.city = cities.name) - внутренее соединение, при нём не будут выведены пустые значения

    	SELECT name, city, date, location FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name); - левое внешнее соединение при котором если строка не будет найдена, подставится пустая

    	SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high, W2.city, W2.temp_lo AS low, W2.temp_hi AS high FROM weather W1, weather W2 WHERE W1.temp_lo < W2.temp_lo AND W1.temp_hi > W2.temp_hi; - замкнутое соединение. Например, представьте, что мы хотим найти все записи погоды, в которых температура лежит в диапазоне температур других записей. Для этого мы должны сравнить столбцы temp_lo и temp_hi каждой строки таблицы weather со столбцами temp_lo и temp_hi другого набора строк weather.

Агрегатные функции.

	Агрегатная функция вычисляет единственное значение, обрабатывая множество строк. 

	Например, есть агрегатные функции, вычисляющие: count (количество), sum (сумму), avg (среднее), max (максимум) и min (минимум) для набора строк.

	SELECT max(temp_lo) FROM weather;

	max не работает с where, но это можно сделать с помощью подзапроса - SELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather);

	Агрегатные функции также очень полезны в сочетании с предложением GROUP BY. - SELECT city, max(temp_lo) FROM weather GROUP BY city;

		Hayward | 37
		New York | 48

	Мы можем отфильтровать сгруппированные строки с помощью предложения HAVING - ...HAVING max(temp_lo) < 40;

	Предложение HAVING отлично подходит для совместного использования с агрегатные функциями.

Изменение данных.

	UPDATE users SET name = 'Nastya';

Удаление данных.

	DELETE FROM users WHERE name = 'test';

	Без указания условия DELETE удалит все строки данной таблицы, полностью очистит её. При этом система не попросит вас подтвердить операцию!

Представления.

	Предположим, что нужно выбрать данные из двух таблиц, но не нужно каждый раз вводить весь этот запрос. В этом помогают представления.

	Активное использование представлений — это ключевой аспект хорошего проектирования баз данных SQL. Представления позволяют вам скрыть внутреннее устройство ваших таблиц, которые могут меняться по мере развития приложения, за надёжными интерфейсами.

	CREATE VIEW viewname AS SELECT city, temp_lo, temp_hi, prcp, date, location FROM weather, cities WHERE city = name;

	SELECT * FROM myview;

Внешние ключи.

	Нужно добиться, чтобы никто не мог вставить в таблицу weather строки, для которых не находится соответствующая строка в таблице cities. Это называется обеспечением ссылочной целостности данных.

	CREATE TABLE cities (
        city varchar(80) primary key,
        location point
	);

	CREATE TABLE weather (
        city varchar(80) references cities(city),
        date date
	);

	INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28'); - если Berkeley отсутствует в таблице cities, то произойдёт ошибка.

Транзакции.

	Суть транзакции в том, что она объединяет последовательность действий в одну операцию "всё или ничего". Если  что-то помешает успешно завершить транзакцию, ни один из результатов этих действий не сохранится в базе данных.

	Изменения, производимые открытой транзакцией, невидимы для других транзакций, пока она не будет завершена, а затем они становятся видны все сразу.

	BEGIN;
	UPDATE accounts SET cash = 1000 WHERE name = 'Alice';
	UPDATE accounts SET cash = 200 WHERE name = 'Mark';
	COMMIT;

	Если в процессе выполнения транзакции мы решим, что не хотим фиксировать её изменения мы можем выполнить команду ROLLBACK вместо COMMIT, и все наши изменения будут отменены.

	PostgreSQL на самом деле отрабатывает каждый SQL-оператор как транзакцию. Если вы не вставите команду BEGIN, то каждый отдельный оператор будет неявно окружён командами BEGIN и COMMIT (в случае успешного завершения).

	Операторами в транзакции можно также управлять на более детальном уровне, используя точки сохранения. Точки сохранения позволяют выборочно отменять некоторые части транзакции и фиксировать все остальные. Определив точку сохранения с помощью SAVEPOINT, при необходимости вы можете вернуться к ней с помощью команды ROLLBACK TO. Все изменения в базе данных, произошедшие после точки сохранения и до момента отката, отменяются, но изменения, произведённые ранее, сохраняются.

	...
	SAVEPOINT my_savepoint;
	...
	ROLLBACK TO my_savepoint;

Оконные функции.

	С оконными функциями строки не группируются в одну выходную строку, что имеет место с агрегатными функциями. Вместо этого, эти строки остаются отдельными сущностями.

	Вызов оконной функции всегда содержит предложение OVER. Предложение PARTITION BY, дополняющее OVER, разделяет строки по группам, или разделам. Вы можете также определять порядок, в котором строки будут обрабатываться оконными функциями, используя ORDER BY.

	Вот пример, показывающий, как сравнить зарплату каждого сотрудника со средней зарплатой его отдела:

	SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;

	  depname  | empno | salary |          avg          
	-----------+-------+--------+-----------------------
	 develop   |    11 |   5200 | 5020.0000000000000000
	 develop   |     7 |   4200 | 5020.0000000000000000
	 develop   |     9 |   4500 | 5020.0000000000000000
	 develop   |     8 |   6000 | 5020.0000000000000000
	 develop   |    10 |   5200 | 5020.0000000000000000
	 personnel |     5 |   3500 | 3700.0000000000000000
	 personnel |     2 |   3900 | 3700.0000000000000000
	 sales     |     3 |   4800 | 4866.6666666666666667
	 sales     |     1 |   5000 | 4866.6666666666666667
	 sales     |     4 |   4800 | 4866.6666666666666667

	Первые три столбца извлекаются непосредственно из таблицы empsalary, при этом для каждой строки таблицы есть строка результата. В четвёртом столбце оказалось среднее значение, вычисленное по всем строкам, имеющим то же значение depname, что и текущая строка.

	Оконные функции разрешается использовать в запросе только в списке SELECT и предложении ORDER BY. Во всех остальных предложениях, включая GROUP BY, HAVING и WHERE, они запрещены.

Наследование.

	Давайте создадим две таблицы: cities (города) и capitals (столицы штатов). Естественно, столицы штатов также являются городами, поэтому нам нужно явным образом добавлять их в результат, когда мы хотим просмотреть все города. Для этого воспользуемся наследованием.

	CREATE TABLE cities (
		name text,
		population real,
		altitude int
	);

	CREATE TABLE capitals (
		state char(2)
	) INHERITS (cities);

	В данном случае строка таблицы capitals наследует все столбцы (name, population и altitude) от родительской таблицы cities и все запросы будут включать значения из двух таблиц.

	Если нужны значения только из одной таблицы, то можно воспользоваться атрибутом ONLY - SELECT name, altitude FROM ONLY cities WHERE altitude > 500;

	Хотя наследование часто бывает полезно, оно не интегрировано с ограничениями уникальности и внешними ключами, что ограничивает его применимость.

Ключевые слова.

	SELECT, UPDATE, DELETE...

Идентификаторы.

	table_name, field_name...

Идентификаторы и ключевые слова.

	Часто используется неформальное соглашение записывать ключевые слова заглавными буквами, а имена строчными, например

Константы.

	Две строковые константы, разделённые пробельными символами и минимум одним переводом строки, объединяются в одну и обрабатываются, как если бы строка была записана в одной константе.

	SELECT 'foo'
	'bar';

	эквивалентно: SELECT 'foobar';

	но эта запись: SELECT 'foo'      'bar'; считается синтаксической ошибкой.

	Любой другой символ, идущий после обратной косой черты, воспринимается буквально. Таким образом, чтобы включить в строку обратную косую черту, нужно написать две косых черты (\\). Так же можно включить в строку апостроф, написав \', в дополнение к обычному способу ''

	PostgreSQL предлагает ещё один способ записи строковых констант — «заключение строк в доллары». Строковая константа, заключённая в доллары, начинается со знака доллара ($) и заканчивается им.

	$Жанна д'Арк$SomeTag$

	В строке, заключённой в доллары, все символы можно записывать в чистом виде: содержимое строки всегда записывается буквально. Ни обратная косая черта, ни даже знак доллара не являются спецсимволами.

Операторы.

	+ - * / < > = ~ ! @ # % ^ & | ` ?

	Сочетания символов -- и /* не могут присутствовать в имени оператора, так как они будут обозначать начало комментария.

	Многосимвольное имя оператора не может заканчиваться знаком + или -, если только оно не содержит также один из этих символов. Например, @- — допустимое имя оператора, а *- — нет.

	:: - приведение типов

Комментарии.

	Комментарий — это последовательность символов, которая начинается с двух минусов и продолжается до конца строки.

	-- Это стандартный комментарий SQL

	Кроме этого, блочные комментарии можно записывать в стиле C:

		/* многострочный комментарий
		 * с вложенностью: /* вложенный блок комментария */
		 */

Ссылки на столбцы.

	отношение.имя_столбца (u.name)

	Здесь отношение — имя таблицы.

Индексы элементов.

	Если в выражении вы имеете дело с массивом, то можно извлечь определённый его элемент, написав: столбец_массив[4]

Основы таблиц.

	При чтении таблицы строки выводятся в произвольном порядке.

	Столбцу можно назначить значение по умолчанию. Если значение по умолчанию не объявлено явно, им считается значение NULL.

	В определении таблицы значения по умолчанию указываются после типа данных столбца - price numeric DEFAULT 9.99

	Значение по умолчанию вычисляется в момент присваивания значения по умолчанию (а не когда создаётся таблица).

Ограничения.

	В определении столбца можно указать, что значение данного столбца должно удовлетворять логическому выражению (проверке истинности).

	price numeric CHECK (price > 0)

	Ограничению можно присвоить отдельное имя. Это улучшит сообщения об ошибках и позволит вам ссылаться на это ограничение, когда вам понадобится изменить его.

	price numeric CONSTRAINT positive_price CHECK (price > 0)

	Можно задать ограничение для таблицы:

	CREATE TABLE products (
	    name text,
	    price numeric CHECK (price > 0),
	    discounted_price numeric CHECK (discounted_price > 0),
	    CHECK (price > discounted_price) - ограничение для таблицы
	);

	Естественно, для столбца можно определить больше одного ограничения. Для этого их нужно просто указать одно за другим.

	price numeric NOT NULL CHECK (price > 0)

	При проектировании баз данных чаще всего большинство столбцов должны быть помечены как NOT NULL.

Ограничение уникальности.

	Ограничения уникальности гарантируют, что данные в определённом столбце или группе столбцов уникальны среди всех строк таблицы.

	product_no integer UNIQUE

	Можно определить ограничение уникальности для группы столбцов:

	UNIQUE (a, c) - должно быть написано после описания последнего столбца таблицы (считается ограничением таблицы)

Первичные ключи.

	Ограничение первичного ключа означает, что образующий его столбец или группа столбцов может быть уникальным идентификатором строк в таблице.

	Таблица может иметь максимум один первичный ключ.

	id integer PRIMARY KEY,

	PRIMARY KEY (a, c) - создаёт первичный ключ из нескольких столбцов, должен писаться после описания последнего столбца в таблице.

	При добавлении первичного ключа автоматически создаётся уникальный индекс и данные столбец/столбцы помечаются как NOT NULL.

	Теория реляционных баз данных говорит, что первичный ключ должен быть в каждой таблице. В PostgreSQL такого жёсткого требования нет, но обычно лучше ему следовать.

Внешние ключи.

	Значения столбца (или группы столбцов) должны соответствовать значениям в некоторой строке другой таблицы. 

	Ещё это называется ссылочной целостностью двух связанных таблиц.

	Мы знаем, что внешние ключи запрещают создание заказов, не относящихся ни к одному продукту. Но что делать, если после создания заказов с определённым продуктом мы захотим удалить его?

	product_id integer REFERENCES products ON DELETE RESTRICT, - предотвращает удаление связанной строки

	order_id integer REFERENCES orders ON DELETE CASCADE, - указывает, что при удалении связанных строк зависимые от них будут так же автоматически удалены

	Ограничивающие и каскадные удаления — два наиболее распространённых варианта.

	Есть ещё два варианта: SET NULL и SET DEFAULT. При удалении связанных строк они назначают зависимым столбцам в подчинённой таблице значения NULL или значения по умолчанию, соответственно. Заметьте, что это не будет основанием для нарушения ограничений. Например, если в качестве действия задано SET DEFAULT, но значение по умолчанию не удовлетворяет ограничению внешнего ключа, операция закончится ошибкой.

Системные столбцы.

	В каждой таблице есть несколько системных столбцов, неявно определённых системой. Как следствие, их имена нельзя использовать в качестве имён пользовательских столбцов.

	Список: oid, tableoid, xmin, cmin, xmax, cmax, ctid.

Изменение таблиц.

	ALTER TABLE products ADD COLUMN description text; - добавление новой колонки

	Новый столбец заполняется заданным для него значением по умолчанию (или значением NULL, если вы не добавите указание DEFAULT).

	ALTER TABLE products DROP COLUMN description; - удаление столбца

	ALTER TABLE products DROP COLUMN description CASCADE; - удаление столбца и все зависящие от этого столбца объекты

	ALTER TABLE products ALTER COLUMN product_no SET NOT NULL; - добавление ограничения для столбца

	Для удаления ограничения вы должны знать его имя. Если вы не присваивали ему имя, это неявно сделала система, и вы должны выяснить его. Здесь может быть полезна команда psql \d имя_таблицы. Если вы имеете дело с именем ограничения вида $2, не забудьте заключить его в кавычки, чтобы это был допустимый идентификатор.

	ALTER TABLE products DROP CONSTRAINT some_name; - удаление ограничения для столбца

	ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77; - назначает новое значение по умолчанию

	ALTER TABLE products ALTER COLUMN price DROP DEFAULT; - удаляет значение по умолчанию

	ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2); - изменяет тип данных столбца

	ALTER TABLE products RENAME COLUMN product_no TO product_number; - переименование столбца

	ALTER TABLE products RENAME TO items; - переименование таблицы

Права.

	Когда в базе данных создаётся объект, ему назначается владелец. Владельцем обычно становится роль, с которой был выполнен оператор создания. 

	Только владелец может делать с объектом всё, что угодно. Чтобы разрешить использовать его другим ролям, нужно дать им права.

	Существует несколько типов прав: SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER, CREATE, CONNECT, TEMPORARY, EXECUTE и USAGE.

	Неотъемлемое право изменять или удалять объект имеет только владелец объекта.

	Объекту можно назначить нового владельца с помощью команды ALTER для соответствующего типа объекта.

	Для назначения прав применяется команда GRANT.

	GRANT UPDATE ON accounts TO joe; - если в базе данных есть роль joe и таблица accounts, то эта команда даёт право на изменение таблицы для роли joe

	GRANT ALL ON accounts TO joe; - команда ALL дала все права

	GRANT UPDATE ON accounts TO PUBLIC; - дали всем ролям возможность обновления

	REVOKE ALL ON accounts FROM PUBLIC; - лишили всех пользователей всех прав

	








	





