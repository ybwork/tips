Ограничения

    Если нужно чтобы значение столбца не встречалось в других записях, используем constraints

Основы архитектуры.

	PostgreSQL реализован в архитектуре клиент-сервер.

	Главный серверный процесс, управляющий файлами баз данных, принимающий подключения клиентских приложений и выполняющий различные запросы клиентов к базам данных. Эта программа сервера БД называется postgres.

	Клиентские приложения могут быть очень разнообразными: это может быть текстовая утилита, графическое приложение, веб-сервер, использующий базу данных для отображения веб-страниц.

	Сервер PostgreSQL может обслуживать одновременно несколько подключений клиентов. Для этого он запускает («порождает») отдельный процесс для каждого подключения. Можно сказать, что клиент и серверный процесс общаются, не затрагивая главный процесс postgres. 

Создание базы данных.

	createdb mydb

	Имена баз данных должны начинаться с буквы и быть не длиннее 63 символов.

	dropdb mydb

Подключение к базе данных.

	Создав базу данных, вы можете обратиться к ней запустив терминальную программу PostgreSQL под названием psql, в которой можно интерактивно вводить, редактировать и выполнять команды SQL.

	psql mydb

	Чтобы выйти из psql, введите: \q или просто q

Основные понятия.

	PostgreSQL — это реляционная система управления базами данных. 

	Это означает, что это система управления данными, представленными в виде отношений (relation). Отношение — это математически точное обозначение таблицы. То есть данные хранятся в таблицах.

	Любая таблица представляет собой именованный набор строк. Все строки таблицы имеют одинаковый набор именованных столбцов, при этом каждому столбцу назначается определённый тип данных.

	Таблицы объединяются в базы данных, а набор баз данных, управляемый одним экземпляром сервера PostgreSQL, образует кластер баз данных.

Основные команды.

	CREATE TABLE users (
		name varchar(80)
	);

	DROP TABLE table_name;

Создание.

	INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');

    COPY weather FROM '/home/user/weather.txt'; - загрузка большого объёма данных из обычных текстовых файлов

Простая выборка.

    SELECT DISTINCT name, surname, phone FROM users WHERE surnamr = 'Kaduk' AND phone = 89081996450 ORDER BY name;

    Для предотвращения конфликта с ключевыми словами, которые могут появиться в будущем, рекомендуется всегда писать AS или заключать метки выходных столбцов в кавычки.

Соединения таблиц.

	Хорошим стилем считается указывать полные имена столбцов в запросе соединения, чтобы запрос не поломался, если позже в таблицы будут добавлены столбцы с повторяющимися именами.

    	SELECT name, city, date, location FROM weather, cities WHERE cities.name = weather.city;

    	SELECT name, city, date, location FROM weather INNER JOIN cities ON (weather.city = cities.name) - внутренее соединение, при нём не будут выведены пустые значения

    	SELECT name, city, date, location FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name); - левое внешнее соединение при котором если строка не будет найдена, подставится пустая

    	SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high, W2.city, W2.temp_lo AS low, W2.temp_hi AS high FROM weather W1, weather W2 WHERE W1.temp_lo < W2.temp_lo AND W1.temp_hi > W2.temp_hi; - замкнутое соединение. Например, представьте, что мы хотим найти все записи погоды, в которых температура лежит в диапазоне температур других записей. Для этого мы должны сравнить столбцы temp_lo и temp_hi каждой строки таблицы weather со столбцами temp_lo и temp_hi другого набора строк weather.

	INNER JOIN

		Для каждой строки R1 из T1 в результирующей таблице содержится строка для каждой строки в T2, удовлетворяющей условию соединения с R1.

	LEFT OUTER JOIN

		Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL. Таким образом, в результирующей таблице всегда будет минимум одна строка для каждой строки из T1.

	RIGHT OUTER JOIN

		Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляются все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений столбцов T1 вставляются NULL. Это соединение является обратным к левому (LEFT JOIN): в результирующей таблице всегда будет минимум одна строка для каждой строки из T2.

	FULL OUTER JOIN

		Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL. И наконец, в результат включаются все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений столбцов T1 вставляются NULL.

Агрегатные функции.

	Агрегатная функция вычисляет единственное значение, обрабатывая множество строк. 

	Например, есть агрегатные функции, вычисляющие: count (количество), sum (сумму), avg (среднее), max (максимум) и min (минимум) для набора строк.

	SELECT max(temp_lo) FROM weather;

	max не работает с where, но это можно сделать с помощью подзапроса - SELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather);

	Агрегатные функции также очень полезны в сочетании с предложением GROUP BY. - SELECT city, max(temp_lo) FROM weather GROUP BY city;

		Hayward | 37
		New York | 48

	Мы можем отфильтровать сгруппированные строки с помощью предложения HAVING - ...HAVING max(temp_lo) < 40;

	Предложение HAVING отлично подходит для совместного использования с агрегатные функциями.

Изменение данных.

	UPDATE users SET name = 'Nastya';

Удаление данных.

	DELETE FROM users WHERE name = 'test';

	Без указания условия DELETE удалит все строки данной таблицы, полностью очистит её. При этом система не попросит вас подтвердить операцию!

Представления.

	Предположим, что нужно выбрать данные из двух таблиц, но не нужно каждый раз вводить весь этот запрос. В этом помогают представления.

	Активное использование представлений — это ключевой аспект хорошего проектирования баз данных SQL. Представления позволяют вам скрыть внутреннее устройство ваших таблиц, которые могут меняться по мере развития приложения, за надёжными интерфейсами.

	CREATE VIEW viewname AS SELECT city, temp_lo, temp_hi, prcp, date, location FROM weather, cities WHERE city = name;

	SELECT * FROM myview;

Внешние ключи.

	Нужно добиться, чтобы никто не мог вставить в таблицу weather строки, для которых не находится соответствующая строка в таблице cities. Это называется обеспечением ссылочной целостности данных.

	CREATE TABLE cities (
        city varchar(80) primary key,
        location point
	);

	CREATE TABLE weather (
        city varchar(80) references cities(city),
        date date
	);

	INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28'); - если Berkeley отсутствует в таблице cities, то произойдёт ошибка.

Транзакции.

	Суть транзакции в том, что она объединяет последовательность действий в одну операцию "всё или ничего". Если  что-то помешает успешно завершить транзакцию, ни один из результатов этих действий не сохранится в базе данных.

	Изменения, производимые открытой транзакцией, невидимы для других транзакций, пока она не будет завершена, а затем они становятся видны все сразу.

	BEGIN;
	UPDATE accounts SET cash = 1000 WHERE name = 'Alice';
	UPDATE accounts SET cash = 200 WHERE name = 'Mark';
	COMMIT;

	Если в процессе выполнения транзакции мы решим, что не хотим фиксировать её изменения мы можем выполнить команду ROLLBACK вместо COMMIT, и все наши изменения будут отменены.

	PostgreSQL на самом деле отрабатывает каждый SQL-оператор как транзакцию. Если вы не вставите команду BEGIN, то каждый отдельный оператор будет неявно окружён командами BEGIN и COMMIT (в случае успешного завершения).

	Операторами в транзакции можно также управлять на более детальном уровне, используя точки сохранения. Точки сохранения позволяют выборочно отменять некоторые части транзакции и фиксировать все остальные. Определив точку сохранения с помощью SAVEPOINT, при необходимости вы можете вернуться к ней с помощью команды ROLLBACK TO. Все изменения в базе данных, произошедшие после точки сохранения и до момента отката, отменяются, но изменения, произведённые ранее, сохраняются.

	...
	SAVEPOINT my_savepoint;
	...
	ROLLBACK TO my_savepoint;

Оконные функции.

	С оконными функциями строки не группируются в одну выходную строку, что имеет место с агрегатными функциями. Вместо этого, эти строки остаются отдельными сущностями.

	Вызов оконной функции всегда содержит предложение OVER. Предложение PARTITION BY, дополняющее OVER, разделяет строки по группам, или разделам. Вы можете также определять порядок, в котором строки будут обрабатываться оконными функциями, используя ORDER BY.

	Вот пример, показывающий, как сравнить зарплату каждого сотрудника со средней зарплатой его отдела:

	SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;

	  depname  | empno | salary |          avg          
	-----------+-------+--------+-----------------------
	 develop   |    11 |   5200 | 5020.0000000000000000
	 develop   |     7 |   4200 | 5020.0000000000000000
	 develop   |     9 |   4500 | 5020.0000000000000000
	 develop   |     8 |   6000 | 5020.0000000000000000
	 develop   |    10 |   5200 | 5020.0000000000000000
	 personnel |     5 |   3500 | 3700.0000000000000000
	 personnel |     2 |   3900 | 3700.0000000000000000
	 sales     |     3 |   4800 | 4866.6666666666666667
	 sales     |     1 |   5000 | 4866.6666666666666667
	 sales     |     4 |   4800 | 4866.6666666666666667

	Первые три столбца извлекаются непосредственно из таблицы empsalary, при этом для каждой строки таблицы есть строка результата. В четвёртом столбце оказалось среднее значение, вычисленное по всем строкам, имеющим то же значение depname, что и текущая строка.

	Оконные функции разрешается использовать в запросе только в списке SELECT и предложении ORDER BY. Во всех остальных предложениях, включая GROUP BY, HAVING и WHERE, они запрещены.

Наследование.

	Давайте создадим две таблицы: cities (города) и capitals (столицы штатов). Естественно, столицы штатов также являются городами, поэтому нам нужно явным образом добавлять их в результат, когда мы хотим просмотреть все города. Для этого воспользуемся наследованием.

	CREATE TABLE cities (
		name text,
		population real,
		altitude int
	);

	CREATE TABLE capitals (
		state char(2)
	) INHERITS (cities);

	В данном случае строка таблицы capitals наследует все столбцы (name, population и altitude) от родительской таблицы cities и все запросы будут включать значения из двух таблиц.

	Если нужны значения только из одной таблицы, то можно воспользоваться атрибутом ONLY - SELECT name, altitude FROM ONLY cities WHERE altitude > 500;

	Хотя наследование часто бывает полезно, оно не интегрировано с ограничениями уникальности и внешними ключами, что ограничивает его применимость.

	SELECT name, altitude FROM cities* WHERE altitude > 500; - * позволяет указать, что должны включаться и дочерние таблицы. Указывать * не обязательно, так как теперь это поведение всегда подразумевается по умолчанию. Однако такая запись всё ещё поддерживается для совместимости со старыми версиями

	Родительскую таблицу нельзя удалить, пока существуют унаследованные от неё. При этом в дочерних таблицах нельзя удалять или модифицировать столбцы или ограничения-проверки, унаследованные от родительских таблиц. Если вы хотите удалить таблицу вместе со всеми её потомками, это легко сделать, добавив в команду удаления родительской таблицы параметр CASCADE.

	Возможности наследования серьёзно ограничены тем, что индексы (включая ограничения уникальности) и ограничения внешних ключей относятся только к отдельным таблицам, но не к их потомкам.

Ключевые слова.

	SELECT, UPDATE, DELETE...

Идентификаторы.

	table_name, field_name...

Идентификаторы и ключевые слова.

	Часто используется неформальное соглашение записывать ключевые слова заглавными буквами, а имена строчными, например

Константы.

	Две строковые константы, разделённые пробельными символами и минимум одним переводом строки, объединяются в одну и обрабатываются, как если бы строка была записана в одной константе.

	SELECT 'foo'
	'bar';

	эквивалентно: SELECT 'foobar';

	но эта запись: SELECT 'foo'      'bar'; считается синтаксической ошибкой.

	Любой другой символ, идущий после обратной косой черты, воспринимается буквально. Таким образом, чтобы включить в строку обратную косую черту, нужно написать две косых черты (\\). Так же можно включить в строку апостроф, написав \', в дополнение к обычному способу ''

	PostgreSQL предлагает ещё один способ записи строковых констант — «заключение строк в доллары». Строковая константа, заключённая в доллары, начинается со знака доллара ($) и заканчивается им.

	$Жанна д'Арк$SomeTag$

	В строке, заключённой в доллары, все символы можно записывать в чистом виде: содержимое строки всегда записывается буквально. Ни обратная косая черта, ни даже знак доллара не являются спецсимволами.

Операторы.

	+ - * / < > = ~ ! @ # % ^ & | ` ?

	Сочетания символов -- и /* не могут присутствовать в имени оператора, так как они будут обозначать начало комментария.

	Многосимвольное имя оператора не может заканчиваться знаком + или -, если только оно не содержит также один из этих символов. Например, @- — допустимое имя оператора, а *- — нет.

	:: - приведение типов

Комментарии.

	Комментарий — это последовательность символов, которая начинается с двух минусов и продолжается до конца строки.

	-- Это стандартный комментарий SQL

	Кроме этого, блочные комментарии можно записывать в стиле C:

		/* многострочный комментарий
		 * с вложенностью: /* вложенный блок комментария */
		 */

Ссылки на столбцы.

	отношение.имя_столбца (u.name)

	Здесь отношение — имя таблицы.

Индексы элементов.

	Если в выражении вы имеете дело с массивом, то можно извлечь определённый его элемент, написав: столбец_массив[4]

Основы таблиц.

	При чтении таблицы строки выводятся в произвольном порядке.

	Столбцу можно назначить значение по умолчанию. Если значение по умолчанию не объявлено явно, им считается значение NULL.

	В определении таблицы значения по умолчанию указываются после типа данных столбца - price numeric DEFAULT 9.99

	Значение по умолчанию вычисляется в момент присваивания значения по умолчанию (а не когда создаётся таблица).

Ограничения.

	В определении столбца можно указать, что значение данного столбца должно удовлетворять логическому выражению (проверке истинности).

	price numeric CHECK (price > 0)

	Ограничению можно присвоить отдельное имя. Это улучшит сообщения об ошибках и позволит вам ссылаться на это ограничение, когда вам понадобится изменить его.

	price numeric CONSTRAINT positive_price CHECK (price > 0)

	Можно задать ограничение для таблицы:

	CREATE TABLE products (
	    name text,
	    price numeric CHECK (price > 0),
	    discounted_price numeric CHECK (discounted_price > 0),
	    CHECK (price > discounted_price) - ограничение для таблицы
	);

	Естественно, для столбца можно определить больше одного ограничения. Для этого их нужно просто указать одно за другим.

	price numeric NOT NULL CHECK (price > 0)

	При проектировании баз данных чаще всего большинство столбцов должны быть помечены как NOT NULL.

Ограничение уникальности.

	Ограничения уникальности гарантируют, что данные в определённом столбце или группе столбцов уникальны среди всех строк таблицы.

	product_no integer UNIQUE

	Можно определить ограничение уникальности для группы столбцов:

	UNIQUE (a, c) - должно быть написано после описания последнего столбца таблицы (считается ограничением таблицы)

Первичные ключи.

	Ограничение первичного ключа означает, что образующий его столбец или группа столбцов может быть уникальным идентификатором строк в таблице.

	Таблица может иметь максимум один первичный ключ.

	id integer PRIMARY KEY,

	PRIMARY KEY (a, c) - создаёт первичный ключ из нескольких столбцов, должен писаться после описания последнего столбца в таблице.

	При добавлении первичного ключа автоматически создаётся уникальный индекс и данные столбец/столбцы помечаются как NOT NULL.

	Теория реляционных баз данных говорит, что первичный ключ должен быть в каждой таблице. В PostgreSQL такого жёсткого требования нет, но обычно лучше ему следовать.

Внешние ключи.

	Значения столбца (или группы столбцов) должны соответствовать значениям в некоторой строке другой таблицы. 

	Ещё это называется ссылочной целостностью двух связанных таблиц.

	Мы знаем, что внешние ключи запрещают создание заказов, не относящихся ни к одному продукту. Но что делать, если после создания заказов с определённым продуктом мы захотим удалить его?

	product_id integer REFERENCES products ON DELETE RESTRICT, - предотвращает удаление связанной строки

	order_id integer REFERENCES orders ON DELETE CASCADE, - указывает, что при удалении связанных строк зависимые от них будут так же автоматически удалены

	Ограничивающие и каскадные удаления — два наиболее распространённых варианта.

	Есть ещё два варианта: SET NULL и SET DEFAULT. При удалении связанных строк они назначают зависимым столбцам в подчинённой таблице значения NULL или значения по умолчанию, соответственно. Заметьте, что это не будет основанием для нарушения ограничений. Например, если в качестве действия задано SET DEFAULT, но значение по умолчанию не удовлетворяет ограничению внешнего ключа, операция закончится ошибкой.

Системные столбцы.

	В каждой таблице есть несколько системных столбцов, неявно определённых системой. Как следствие, их имена нельзя использовать в качестве имён пользовательских столбцов.

	Список: oid, tableoid, xmin, cmin, xmax, cmax, ctid.

Изменение таблиц.

	ALTER TABLE products ADD COLUMN description text; - добавление новой колонки

	Новый столбец заполняется заданным для него значением по умолчанию (или значением NULL, если вы не добавите указание DEFAULT).

	ALTER TABLE products DROP COLUMN description; - удаление столбца

	ALTER TABLE products DROP COLUMN description CASCADE; - удаление столбца и все зависящие от этого столбца объекты

	ALTER TABLE products ALTER COLUMN product_no SET NOT NULL; - добавление ограничения для столбца

	Для удаления ограничения вы должны знать его имя. Если вы не присваивали ему имя, это неявно сделала система, и вы должны выяснить его. Здесь может быть полезна команда psql \d имя_таблицы. Если вы имеете дело с именем ограничения вида $2, не забудьте заключить его в кавычки, чтобы это был допустимый идентификатор.

	ALTER TABLE products DROP CONSTRAINT some_name; - удаление ограничения для столбца

	ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77; - назначает новое значение по умолчанию

	ALTER TABLE products ALTER COLUMN price DROP DEFAULT; - удаляет значение по умолчанию

	ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2); - изменяет тип данных столбца

	ALTER TABLE products RENAME COLUMN product_no TO product_number; - переименование столбца

	ALTER TABLE products RENAME TO items; - переименование таблицы

Права.

	Когда в базе данных создаётся объект, ему назначается владелец. Владельцем обычно становится роль, с которой был выполнен оператор создания. 

	Только владелец может делать с объектом всё, что угодно. Чтобы разрешить использовать его другим ролям, нужно дать им права.

	Существует несколько типов прав: SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER, CREATE, CONNECT, TEMPORARY, EXECUTE и USAGE.

	Неотъемлемое право изменять или удалять объект имеет только владелец объекта.

	Объекту можно назначить нового владельца с помощью команды ALTER для соответствующего типа объекта.

	Для назначения прав применяется команда GRANT.

	GRANT UPDATE ON accounts TO joe; - если в базе данных есть роль joe и таблица accounts, то эта команда даёт право на изменение таблицы для роли joe

	GRANT ALL ON accounts TO joe; - команда ALL дала все права

	GRANT UPDATE ON accounts TO PUBLIC; - дали всем ролям возможность обновления

	REVOKE ALL ON accounts FROM PUBLIC; - лишили всех пользователей всех прав

Политики защиты строк.

	На уровне таблиц можно определить политики защиты строк, ограничивающие для пользователей наборы строк, которые могут быть возвращены обычными запросами или добавлены, изменены и удалены командами, изменяющими данные.

	В качестве простого примера, создать политику для отношения account, позволяющую только членам роли managers обращаться к строкам отношения и при этом только к своим, можно так:

		CREATE TABLE accounts (manager text, company text, contact_email text);

		ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

		CREATE POLICY account_managers ON accounts TO managers USING (manager = current_user);

	Чтобы все пользователи могли обратиться к собственной строке в таблице users, можно применить простую политику:

		CREATE POLICY user_policy ON users USING (user_name = current_user);

	Следующая политика позволит всем пользователям видеть все строки в таблице users, но изменять только свою собственную:

		CREATE POLICY user_policy ON users USING (true) WITH CHECK (user_name = current_user);

	Ниже показан развёрнутый пример того, как этот механизм защиты можно применять в производственной среде. Таблица passwd имитирует файл паролей в Unix:

		CREATE TABLE passwd (
		  user_name              text UNIQUE NOT NULL,
		  pwhash                text,
		  uid                   int  PRIMARY KEY,
		  gid                   int  NOT NULL,
		  real_name             text NOT NULL,
		  home_phone            text,
		  extra_info            text,
		  home_dir              text NOT NULL,
		  shell                 text NOT NULL
		);

		CREATE ROLE admin;  -- Администратор
		CREATE ROLE bob;    -- Обычный пользователь
		CREATE ROLE alice;  -- Обычный пользователь

		-- Наполнение таблицы
		INSERT INTO passwd VALUES
		  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
		INSERT INTO passwd VALUES
		  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
		INSERT INTO passwd VALUES
		  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

		-- Необходимо включить для этой таблицы защиту на уровне строк
		ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

		-- Создание политик
		-- Администратор может видеть и добавлять любые строки
		CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
		-- Обычные пользователи могут видеть все строки
		CREATE POLICY all_view ON passwd FOR SELECT USING (true);
		-- Обычные пользователи могут изменять собственные данные, но
		-- не могут задать произвольную оболочку входа
		CREATE POLICY user_mod ON passwd FOR UPDATE
		  USING (current_user = user_name)
		  WITH CHECK (
		    current_user = user_name AND
		    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
		  );

		-- Администраторы получают все обычные права
		GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
		-- Пользователям разрешается чтение только общедоступных столбцов
		GRANT SELECT
		  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
		  ON passwd TO public;
		-- Пользователям разрешается изменение определённых столбцов
		GRANT UPDATE
		  (pwhash, real_name, home_phone, extra_info, shell)
		  ON passwd TO public;

Схемы.

	Кластер баз данных PostgreSQL содержит один или несколько именованных экземпляров баз. При этом в рамках одного подключения к серверу можно обращаться к данным только одной базы данных, указанной при установлении соединения.

	База данных может содержать одну или несколько схем.

	Есть несколько возможных объяснений, для чего стоит применять схемы:

		Чтобы одну базу данных могли использовать несколько пользователей, независимо друг от друга.

		Чтобы объединить объекты базы данных в логические группы для облегчения управления ими.

		Чтобы в одной базе сосуществовали разные приложения, и при этом не возникало конфликтов имён.

	CREATE SCHEMA myschema;

	схема.таблица - обращение к схеме

	база_данных.схема.таблица - более общий синтаксис обращения к схеме

	CREATE TABLE myschema.mytable ();

	DROP SCHEMA myschema;

	DROP SCHEMA myschema CASCADE; - удалить схему со всеми содержащимися в ней объектами

	Если при создании таблицы не указывается схема, то она автоматически помещаются в схему «public».

	Первая схема в пути поиска называется текущей. Эта схема будет использоваться не только при поиске, но и при создании объектов — она будет включать таблицы, созданные командой CREATE TABLE без указания схемы.

	SHOW search_path; - показывает текущий тип поиска

	SET search_path TO myschema,public; - добавляет в путь новую схему

	В дополнение к схеме public и схемам, создаваемым пользователями, любая база данных содержит схему pg_catalog, в которой находятся системные таблицы и все встроенные типы данных, функции и операторы. pg_catalog фактически всегда является частью пути поиска. Так как имена системных таблиц начинаются с pg_, такие имена лучше не использовать во избежание конфликта имён, возможного при появлении в будущем системной таблицы с тем же именем, что и ваша.

Секционирование таблиц.
	
	Секционированием данных называется разбиение одной большой логической таблицы на несколько небольших физических секций.

	В определённых ситуациях оно кардинально увеличивает быстродействие, особенно когда большой процент часто запрашиваемых строк таблицы относится к одному или небольшому числу секций.

	Массовую загрузку и удаление данных можно осуществлять, добавляя и удаляя секции, если это было предусмотрено при проектировании секционированных таблиц.

	Всё это обычно полезно только для очень больших таблиц. Какие именно таблицы выиграют от секционирования, зависит от конкретного приложения, хотя, как правило, это следует применять для таблиц, размер которых превышает объём ОЗУ сервера.

	Преобразовать обычную таблицу в секционированную и наоборот нельзя. Однако в секционированную таблицу можно добавить в качестве секции обычную или секционированную таблицу с данными, а также можно удалить секцию из секционированной таблицы и превратить её в отдельную таблицу.

	В секциях не может быть столбцов, отсутствующих в родительской таблице.

	CREATE TABLE measurement (
	    city_id         int not null,
	    logdate         date not null,
	    peaktemp        int,
	    unitsales       int
	) PARTITION BY RANGE (logdate);

	CREATE TABLE measurement_y2006m02 PARTITION OF measurement FOR VALUES FROM ('2006-02-01') TO ('2006-03-01'); - создание секции

	DROP TABLE measurement_y2006m02; - удаляет секцию

	ALTER TABLE measurement_y2006m02 NO INHERIT measurement; - удаляет секцию из секционированной таблицы

Сторонние данные.

	PostgreSQL частично реализует спецификацию SQL/MED, позволяя вам обращаться к данным, находящимся снаружи, используя обычные SQL-запросы. Такие данные называются сторонними.

	Чтобы обратиться к сторонним данным, вы должны создать объект сторонний сервер, в котором настраивается подключение к внешнему источнику данных, определяются параметры соответствующей обёртки сторонних данных. 

	При каждом запросе PostgreSQL обращается к обёртке сторонних данных, которая, в свою очередь, получает данные из внешнего источника или передаёт их ему (в случае команд INSERT или UPDATE).

Объекты баз данных.

	Таблицы, Представления, Функции и операторы, Типы данных и домены, Триггеры и правила перезаписи.

Отслеживание зависимостей.

	Для сохранения целостности структуры всей базы данных, PostgreSQL не позволяет удалять объекты, от которых зависят другие.

	Если вы не хотите заниматься ликвидацией зависимостей по отдельности, можно выполнить: DROP TABLE products CASCADE;

Возврат данных из изменённых строк.

	Иногда бывает полезно получать данные из модифицируемых строк в процессе их обработки. Это возможно с использованием предложения RETURNING, которое можно задать для команд INSERT, UPDATE и DELETE.

	INSERT INTO users (firstname, lastname) VALUES ('Joe', 'Cool') RETURNING id;

Подзапросы.
	
	Подзапросы, образующие таблицы, должны заключаться в скобки и им обязательно должны назначаться псевдонимы.

	FROM (SELECT * FROM table1) AS псевдоним

	Перед подзапросами в предложении FROM можно добавить ключевое слово LATERAL. Это позволит ссылаться в них на столбцы предшествующих элементов списка FROM.

Предложения GROUP BY и HAVING.

	Строки порождённой входной таблицы, прошедшие фильтр WHERE, можно сгруппировать с помощью предложения GROUP BY, а затем оставить в результате только нужные группы строк, используя предложение HAVING.

	Предложение GROUP BY группирует строки таблицы, объединяя их в одну группу при совпадении значений во всех перечисленных столбцах.

	В результате наборы строк с одинаковыми значениями преобразуются в отдельные строки, представляющие все строки группы. Это может быть полезно для устранения избыточности выходных данных и/или для вычисления агрегатных функций, применённых к этим группам.

	=> SELECT * FROM test1;
	 x | y
	---+---
	 a | 3
	 c | 2
	 b | 5
	 a | 1

	 => SELECT x FROM test1 GROUP BY x;
	 x
	---
	 a
	 b
	 c

	Группировка без агрегатных выражений по сути выдаёт набор различающихся значений столбцов. Этот же результат можно получить с помощью предложения DISTINCT.

	Если в запросе есть вызовы агрегатных функций, но нет предложения GROUP BY, строки всё равно будут группироваться: в результате окажется одна строка группы (или возможно, ни одной строки, если эта строка будет отброшена предложением HAVING). Это справедливо и для запросов, которые содержат только предложение HAVING, но не содержат вызовы агрегатных функций и предложение GROUP BY.

GROUPING SETS, CUBE и ROLLUP (наборы группирования).

	В каждом внутреннем списке GROUPING SETS могут задаваться ноль или более столбцов или выражений, которые воспринимаются так же, как если бы они были непосредственно записаны в предложении GROUP BY.

	Изучить позже!!!!

Сочетание запросов.

	запрос1 UNION запрос2 - добавляет результаты второго запроса к результатам первого (операция убирает дублирующиеся строки из результата если не указано ALL)

	запрос1 INTERSECT запрос2 - возвращает все строки, содержащиеся в результате и первого, и второго запроса. Дублирующиеся строки отфильтровываются, если не указано ALL.

	запрос1 EXCEPT запрос2 - возвращает все строки, которые есть в результате первого запроса, но отсутствуют в результате второго. И здесь дублирующиеся строки отфильтровываются, если не указано ALL.

Сортировка строк.

	Если сортировка не задана, строки возвращаются в неопределённом порядке.

	Порядок сортировки определяет предложение ORDER BY.

	SELECT a, b FROM table1 ORDER BY a + b, c;

	Когда указывается несколько выражений, последующие значения позволяют отсортировать строки, в которых совпали все предыдущие значения.

	ORDER BY можно применить к результату комбинации UNION, INTERSECT и EXCEPT, но в этом случае возможна сортировка только по номерам или именам столбцов, но не по выражениям.

LIMIT и OFFSET.

	Указания LIMIT и OFFSET позволяют получить только часть строк из тех, что выдал остальной запрос.

	SELECT name FROM users LIMIT 5 OFFSET 10

	Если указывается число LIMIT, в результате возвращается не больше заданного числа строк (меньше может быть, если сам запрос выдал меньшее количество строк).

	OFFSET указывает пропустить указанное число строк, прежде чем начать выдавать строки.

	Если указано и OFFSET, и LIMIT, сначала система пропускает OFFSET строк, а затем начинает подсчитывать строки для ограничения LIMIT.

	Применяя LIMIT, важно использовать также предложение ORDER BY, чтобы строки результата выдавались в определённом порядке. Иначе будут возвращаться непредсказуемые подмножества строк.
	
Списки VALUES.

	Предложение VALUES позволяет создать «постоянную таблицу», которую можно использовать в запросе, не создавая и не наполняя таблицу в БД. По умолчанию PostgreSQL назначает столбцам таблицы VALUES имена column1, column2 и т. д. Но их название можно изменить.

	SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num, letter);

	 num | letter
	-----+--------
	   1 | one
	   2 | two
	   3 | three

Запросы WITH (Общие табличные выражения).

	WITH предоставляет способ записывать дополнительные операторы для применения в больших запросах. Дополнительным оператором в предложении WITH может быть SELECT, INSERT, UPDATE или DELETE, а само предложение WITH присоединяется к основному оператору, которым также может быть SELECT, INSERT, UPDATE или DELETE.

	Основное предназначение SELECT в предложении WITH заключается в разбиении сложных запросов на простые части. 

	WITH regional_sales AS (
	    SELECT region, SUM(amount) AS total_sales
	    FROM orders
	    GROUP BY region
   	) SELECT product, SUM(quantity) AS product_units, SUM(amount) AS product_sales FROM orders

   	Необязательное указание RECURSIVE превращает WITH из простого синтаксического удобства в средство реализации того, что невозможно в стандартном SQL. Используя RECURSIVE, запрос WITH может обращаться к собственному результату. Очень простой пример, суммирующий числа от 1 до 100.

   	WITH RECURSIVE t(n) AS (
	    VALUES (1)
	  UNION ALL
	    SELECT n+1 FROM t WHERE n < 100
	)
	SELECT sum(n) FROM t;

	В общем виде рекурсивный запрос WITH всегда записывается как не рекурсивная часть, потом UNION (или UNION ALL), а затем рекурсивная часть, где только в рекурсивной части можно обратиться к результату запроса.

	В предложении WITH можно также использовать операторы, изменяющие данные (INSERT, UPDATE или DELETE). Это позволяет выполнять в одном запросе сразу несколько разных операций.

	WITH moved_rows AS (
	    DELETE FROM products
	    WHERE
	        "date" >= '2010-10-01' AND
	        "date" < '2010-11-01'
	    RETURNING *
	) 
	INSERT INTO products_log
	SELECT * FROM moved_rows;

Типы данных.

	Пользователи могут создавать свои типы в PostgreSQL, используя команду CREATE TYPE.

Логический тип.

	В PostgreSQL есть стандартный SQL-тип boolean. Тип boolean может иметь следующие состояния: «true», «false» и третье состояние, «unknown», которое представляется SQL-значением NULL.

	Предпочтительными (совместимыми с SQL) являются варианты TRUE и FALSE.

Числовые типы.

	smallint, integer, bigint, decimal, numeric, real, double precision, smallserial, serial, bigserial.

	Чаще всего используется тип integer, как наиболее сбалансированный выбор ширины диапазона, размера и быстродействия. Тип smallint обычно применяется, только когда крайне важно уменьшить размер данных на диске. Тип bigint предназначен для тех случаев, когда числа не умещаются в диапазон типа integer.

	Тип numeric позволяет хранить числа с очень большим количеством цифр. Он особенно рекомендуется для хранения денежных сумм и других величин, где важна точность. Вычисления с типом numeric дают точные результаты, где это возможно, например, при сложении, вычитании и умножении. Однако операции со значениями numeric выполняются гораздо медленнее, чем с целыми числами или с типами с плавающей точкой, описанными в следующем разделе.

	Типы decimal и numeric равнозначны.

	Типы данных smallserial, serial и bigserial не являются настоящими типами, а представляют собой просто удобное средство для создания столбцов с уникальными идентификаторами (подобное свойству AUTO_INCREMENT в некоторых СУБД).

	При создании типа numeric нужно всегда указывайте точность и масштаб явно.

	Помимо обычных чисел тип numeric позволяет сохранить специальное значение NaN, что означает «not-a-number» (не число). Любая операция c NaN выдаёт в результате тоже NaN. Записывая это значение в виде константы в команде SQL, его нужно заключать в апострофы, например так: UPDATE table SET x = 'NaN'. Регистр символов в строке NaN не важен.

	В дополнение к обычным числовым значениям типы с плавающей точкой могут содержать следующие специальные значения: Infinity, -Infinity, NaN.

	Если float указывается без точности, подразумевается тип double precision.

Последовательные типы.

	Это специфичный для PostgreSQL способ создания столбца с автоувеличением.

	Типы данных smallserial, serial и bigserial не являются настоящими типами, а представляют собой просто удобное средство для создания столбцов с уникальными идентификаторами (подобное свойству AUTO_INCREMENT в некоторых СУБД).

Денежные типы.

	Тип money хранит денежную сумму с фиксированной дробной частью.

	Значения типов numeric, int и bigint можно привести к типу money.

Символьные типы.

	SQL определяет два основных символьных типа: character varying(n) и character(n), где n — положительное число. Помимо этого, PostgreSQL предлагает тип text, в котором можно хранить строки произвольной длины.

	Если длина сохраняемой строки оказывается меньше объявленной, значения типа character будут дополнятся пробелами; а тип character varying просто сохранит короткую строку.
	
	Хотя в некоторых СУБД тип character(n) работает быстрее других, в PostgreSQL это не так; на деле character(n) обычно оказывается медленнее остальных типов из-за большего размера данных и более медленной сортировки. В большинстве случаев вместо него лучше применять text или character varying.

Двоичные типы данных.

	Для хранения двоичных данных предназначен тип bytea.

Типы даты/времени.

	timestamp without time zone, date, time with time zone, interval.

	Стандарт SQL требует, чтобы тип timestamp подразумевал timestamp without time zone (время без часового пояса), и PostgreSQL следует этому. Для краткости timestamp with time zone можно записать как timestamptz.

	Типы time, timestamp и interval принимают необязательное значение точности p, определяющее, сколько знаков после запятой должно сохраняться в секундах.

	Для хранения времени суток без даты предназначены типы time.

	Допустимые значения типов timestamp состоят из записи даты и времени, после которого может указываться часовой пояс и необязательное уточнение AD или BC, определяющее эпоху до нашей эры и нашу эру соответственно.

	Специальные значения: epoch, infinity, -infinity, now, today, tomorrow, yesterday, allballs

Типы перечислений.

	В качестве перечисления можно привести дни недели или набор состояний.

	Тип перечислений создаются с помощью команды CREATE TYPE.

	CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');

	Созданные типы enum можно использовать в определениях таблиц и функций, как и любые другие:

		CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
		CREATE TABLE person (
		    name text,
		    current_mood mood
		);

	Все типы перечислений считаются уникальными и поэтому значения разных типов нельзя сравнивать.

	В метках значений регистр имеет значение, т. е. 'happy' и 'HAPPY' — не одно и то же. Также в метках имеют значение пробелы.

	Удалять существующие значения из перечисления, а также изменять их порядок, нельзя — для получения нужного результата придётся удалить и воссоздать это перечисление.

Геометрические типы.

	Геометрические типы данных представляют объекты в двумерном пространстве.

	point, line (бесконечная прямая), lseg (отрезок), box (прямоугольник), path (закрытый путь подобный многоугольнику), path (открытый путь), polygon (многоугольник), circle.

Типы, описывающие сетевые адреса.

	PostgreSQL предлагает типы данных для хранения адресов IPv4, IPv6 и MAC.

	Для хранения сетевых адресов лучше использовать эти типы, а не простые текстовые строки, так как PostgreSQL проверяет вводимые значения данных типов и предоставляет специализированные операторы и функции для работы с ними.

	cidr (сети IPv4 и IPv6), inet (узлы и сети IPv4 и IPv6), macaddr (MAC-адреса), macaddr8 (MAC-адреса в формате EUI-64)

	Заметьте, что когда нужно, чтобы принимались только адреса сетей, следует использовать тип cidr, а не inet.

	Существенным различием типов данных inet и cidr является то, что inet принимает значения с ненулевыми битами справа от маски сети, а cidr — нет. Например, значение 192.168.0.1/24 является допустимым для типа inet, но не для cidr.

Битовые строки.

	Битовые строки представляют собой последовательности из 1 и 0. Их можно использовать для хранения или отображения битовых масок. В SQL есть два битовых типа: bit(n) и bit varying(n), где n — положительное целое число.

Типы, предназначенные для текстового поиска.
	
	tsvector, tsquery.

	PostgreSQL предоставляет два типа данных для поддержки полнотекстового поиска. Текстовым поиском называется операция анализа набора документов с текстом на естественном языке, в результате которой находятся фрагменты, наиболее соответствующие запросу.

Тип UUID.

	Тип данных uuid сохраняет универсальные уникальные идентификаторы. 

	Эти идентификаторы будут уникальными и в распределённых системах, а не только в единственной базе данных, как значения генераторов последовательностей.

	В PostgreSQL встроены функции хранения и сравнения идентификаторов UUID, но нет внутренней функции генерирования UUID, потому что не существует какого-то единственного алгоритма, подходящего для всех приложений. Сгенерировать UUID можно с помощью дополнительного модуля uuid-ossp, в котором реализованы несколько стандартных алгоритмов, а можно воспользоваться модулем pgcrypto, где тоже есть функция генерирования случайных UUID. Кроме того, можно сделать это в клиентском приложении или в другой библиотеке, подключённой на стороне сервера.

Тип XML.

	Тип xml предназначен для хранения XML-данных. Его преимущество по сравнению с обычным типом text в том, что он проверяет вводимые значения на допустимость по правилам XML и для работы с ним есть типобезопасные функции.

	Для использования этого типа дистрибутив должен быть скомпилирован в конфигурации configure --with-libxml.

	Определить, является ли определённое значение типа xml полным документом или фрагментом содержимого, позволяет выражение xmlvalue IS DOCUMENT.

	Тип xml отличается от других тем, что для него не определены никакие операторы сравнения, так как чётко определённого и универсального алгоритма сравнения XML-данных не существует. Одно из следствий этого — нельзя отфильтровать строки таблицы, сравнив столбец xml с искомым значением. Поэтому обычно XML-значения должны дополняться отдельным ключевым полем, например ID. Можно также сравнивать XML-значения, преобразовав их сначала в текстовые строки, но заметьте, что с учётом специфики XML-данных этот метод практически бесполезен.

	Из-за отсутствия операторов сравнения для типа xml, для столбца этого типа также нельзя создать индекс. Поэтому, когда требуется быстрый поиск в XML данных, обойти это ограничение можно, приведя данные к типу текстовой строки и проиндексировав эти строки, либо проиндексировав выражение XPath. Конечно сам запрос при этом следует изменить, чтобы поиск выполнялся по индексированному выражению.

Типы JSON.

	Такие данные можно хранить и в типе text, но типы JSON лучше тем, что проверяют, соответствует ли вводимое значение формату JSON. Для работы с ними есть также несколько специальных функций и операторов.

	Существуют два типа данных JSON: json и jsonb. Они принимают на вход почти одинаковые наборы значений, но основное их отличие в эффективности. Тип json сохраняет точную копию введённого текста, которую функции обработки должны разбирать заново при каждом выполнении, тогда как данные jsonb сохраняются в разобранном двоичном формате, что несколько замедляет ввод из-за преобразования, но значительно ускоряет обработку, не требуя многократного разбора текста. Кроме того, jsonb поддерживает индексацию, что тоже может быть очень полезно.

	Для большинства приложений предпочтительнее хранить данные JSON в типе jsonb (если нет особых противопоказаний, например важны прежние предположения о порядке ключей объектов).

	В идеале каждый документ JSON должен собой представлять атомарный информационный блок, который, согласно бизнес-логике, нельзя разделить на меньшие, индивидуально изменяемые блоки.

	Проверка вхождения — важная особенность типа jsonb, не имеющая аналога для типа json. Эта проверка определяет, входит ли один документ jsonb в другой.

	Объекты JSON для проверок на существование и вхождение со множеством ключей или элементов подходят больше, чем массивы, так как, в отличие от массивов, они внутри оптимизируются для поиска, и поиск элемента не будет линейным.

	Для эффективного поиска ключей или пар ключ/значение в большом количестве документов jsonb можно успешно применять индексы GIN.

Массивы.

	Элементами массивов могут быть любые встроенные или определённые пользователями типы, перечисления или составные типы. Массивы доменов в данный момент не поддерживаются.

	CREATE TABLE sal_emp (
	    name            text,
	    pay_by_quarter  integer[],
	    schedule        text[][]
	);

	Команда CREATE TABLE позволяет также указать точный размер массивов, например так:

	CREATE TABLE tictactoe (
	    squares   integer[3][3]
	);

	Добавив данные в таблицу, мы можем перейти к выборкам. Сначала мы покажем, как получить один элемент массива. Этот запрос получает имена сотрудников, зарплата которых изменилась во втором квартале:

	SELECT name FROM sal_emp WHERE pay_by_quarter[1] <> pay_by_quarter[2];

	Массивы — это не множества; необходимость поиска определённых элементов в массиве может быть признаком неудачно сконструированной базы данных. Возможно, вместо массива лучше использовать отдельную таблицу, строки которой будут содержать данные элементов массива. Это может быть лучше и для поиска, и для работы с большим количеством элементов.

	Записывать значения массивов в командах SQL часто бывает удобнее с помощью конструктора ARRAY.

Составные типы.

	Составной тип - это просто список имён полей и соответствующих типов данных.

Диапазонные типы.

	Диапазонные типы представляют диапазоны значений некоторого типа данных (он также называется подтипом диапазона). Например, диапазон типа timestamp может представлять временной интервал. 

	int4range, int8range, numrange, tsrange, tstzrange, daterange.

	Нижнюю границу диапазона можно опустить и определить тем самым диапазон, включающий все точки, лежащие ниже верхней границы. Подобным образом, если не определить верхнюю границу, в диапазон войдут все точки, лежащие выше нижней границы. Если же опущена и нижняя, и правая границы, такой диапазон будет включать все возможные значения своего подтипа.

	Проверить, определена ли верхняя или нижняя граница, можно с помощью функций lower_inf и upper_inf, соответственно.

	Пользователи могут определять собственные диапазонные типы. Это может быть полезно, когда нужно использовать диапазоны с подтипами, для которых нет встроенных диапазонных типов. Например, можно определить новый тип диапазона для подтипа float8.

	Для столбцов, имеющих диапазонный тип, можно создать индексы GiST и SP-GiST.

Идентификаторы объектов.

	Идентификатор объекта (Object Identifier, OID) используется внутри PostgreSQL в качестве первичного ключа различных системных таблиц. В пользовательские таблицы столбец OID добавляется, только если при создании таблицы указывается WITH OIDS или включён параметр конфигурации default_with_oids.

	В настоящее время тип oid реализован как четырёхбайтное целое. Таким образом оно может быть недостаточно большим для обеспечения уникальности в базе данных или даже в отдельных больших таблицах. Поэтому в пользовательских таблицах использовать столбец типа OID в качестве первичного ключа не рекомендуется. Лучше всего ограничить применение этого типа обращениями к системным таблицам.

	Типы псевдонимов OID не полностью следуют правилам изоляции транзакций. Планировщик тоже воспринимает их как простые константы, что может привести к неоптимальному планированию запросов.

Тип pg_lsn.

	Тип данных pg_lsn может применяться для хранения значения LSN (последовательный номер в журнале, Log Sequence Number), которое представляет собой указатель на позицию в журнале WAL. Этот тип содержит XLogRecPtr и является внутренним системным типом PostgreSQL.

Псевдотипы.

	В систему типов PostgreSQL включены несколько специальных элементов, которые в совокупности называются псевдотипами. Псевдотип нельзя использовать в качестве типа данных столбца, но можно объявить функцию с аргументом или результатом такого типа. Каждый из существующих псевдотипов полезен в ситуациях, когда характер функции не позволяет просто получить или вернуть определённый тип данных SQL.

	











	





