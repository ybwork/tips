<?php

/*
    Предисловие.

        - Мелочи важны

        - Профессионалы выделяют некоторое время на обдумывание и планироване проекта

        - Рассматривайте свой код, как красивое воплощение благородных усилий по проектированию, как процесса, а не конечной статической точки
*/

/*
    Глава 1. Чистый код.

    Более того, они - и все остальные участники группы - находятся под страшным давлением со стороны начальства. В спешке они работают все небрежнее, отчего производительность только продолжает падать.

    Но постойте! - скажете вы. Если я не сделаю то, что говорит мой начальник, меня уволят. Скорее всего нет. Обычно начальники хотят знать правду, даже если по их поведению этого не скажешь. Они могут страстно защищать график и требования, но это их работа. А ваша работа - так же страстно защищать код.

    Единственный способ выдержать график и работать быстро - постоянно поддерживать чистоту в коде.

    Суть в том, что чистый код уделяет пристальное внимание мелочам.

    Не язык делает программы простыми. Программа выглядит простой благодаря работе программиста.

    Когда вы в следующий раз напишите строку кода, вспомните, что вы - автор, и пишите для читателей, которые будут оценивать плоды вашей работы.

    Соотношение времени чтения и написания кода превышает 10:1, поэтому наш код должен легко читаться, даже если это затрудняет его написание.

    Хорошо написать код недостаточно. Нобходимо поддерживать чистоту кода с течением времени. "Оставь место стоянки чище, чем оно было до твоего прихода". Чистка не обязана быть глобальной. Можно присвоить более понятное имя переменной, разбить слишком большую функцию или устранить сложную цепочку if.
*/

/*
    Глава 2. Содержательные имена.

    Имена переменных должны передавать намерения программиста. Они должны отвечать на все главные вопросы. Например, что измеряется и в каких единицах - $days_since_creation (дни со времени создания)

    Не использовать слова со скрытыми значениями. Например $hp, aix и т.д.

    Остерегаться малозаметных различий в именах. Например XyzControllerHandlingOfString и XyzControllerStorageOfString

    Не создавать имена, которые не несут полезной иформации. Например Product, ProductInfo, ProductData. В данном примере Info и Data не несут полезной информации.

    Проблема возникает тогда, когда вы называете переменную theZork, потому что в программе уже есть другая переменная с именем zork. Пример:

        getActiveAccount()
        getActiveAccounts()
        getActiveAccountInfo()

    Как участвующему в проекте программисту понять, какую из этих функций вызывать в конкретном случае? Поэтому записывайте так, чтобы читатель кода понимал различия.

    Используйте удобопроизносимые имена. Сравним два имени:

        - private $genymdns;

        - private $generationTimestamp;

    Второе имена можно легко произнести и сразу понять что лежит в данной переменной.

    Выбирайте имена удобные для поиска. Для лёгкого поиска не желательно использовать в названии переменной числа.

    Избегайте схем кодирования имён. (например IProduct, то есть интерфейс продукта)

    Префиксы стали ненужны.

    При создании файлов интерфейска и реализации Роберт предпочитает при необходимости, кодировать реализацию Shop (интерфейс) - ShopImp (реализация), нежели интерфейс IShop (интерфейс) - Shop (реализация). Проверить возможность создания и работы двух файлов с одинаковыми названиями.

    Имена классов должны представлять из себя существительные и их комбинации, если это необходимо. Например AddressParser, Product и т.д.

    Имена методов должны быть глаголами или глагольными сочетаниями. Например: getName, save и т.д.

    Избегайте остроумия и сленга в именовании.

    Выберите одно слово для каждой концепции. Например если в разных классах есть методы fetch, get, retrieve, которые обозначают одно и то же - получать. Соответственно это несёт путаницу, поэтому выбираем одно название метода для получения чего-либо и используем его везде. При этом не следует делать это везде и бездумно. Например мы создаём новый класс, где есть фунция, которая добавляет один элемент в коллекцию. Если подумать, то данная функция не создаёт, а добавляет, поэтому её можно назвать append.

    Короткие имена лучше длинных, если только их смысл понятен читателю.
*/

/*
    Глава 3. Функции.

    Первое правило - функции должны быть компактными, второе правило - функции должны быть ещё компактней. "Мой практический опыт научил меня, что функции должны быть очень маленькими".

    "Однако каждая функция Кента занимала всего 3-4 строки". Этого можно достигнуть например с помощью вызова дополнительной функции в конструкциях if, while.

    Функции не должны содержать вложенных структур типа if, while.

    Функция должна выполнять только одну операцию и ничего другого она делать не должна. Но как быть если в функции идёт проверка входного параметра, потом вызвается другая функция и происходит третье действие? Ответ такой: если функция выполняет только те действия, которые находятся на одном уровне с именем фунции. Например в функции renderPageWithSetupsAndTeardowns мы проверяем является ли страница тестовой, и если да, то включаем начальные и конечные блоки.

    Функцию выполняющую только одну операцию, невозможно осмысленно разделить на секции. Под секциями здесь понимается разделение функции на такие операции, как (инициализирует, отбирает, объявляет и т.п.)

    Код должен читаться, как разссказ - сверху вниз. За каждой функции должна следовать функция следующей абстракции.

    К сожаление без команд if и switch не всегда удаётся обойтись, поэтому здесь нам может помочь полиморфизм. Если команды if и switch используются в коде однократно, то их можно оставить. Но как всегда бывают и исключения.

    Не бойтесь использовать длинные имена, потому что длинное, содержательное имя лучше короткого.

    Оставьте из придуманных слов функции только те, которые чётко описывают назначение функции.

    Используйте содержательные имена, например SetupTeardownIncluder.

    Не бойтесь тратить время на выбор имени. Опробуйте несколько разных имён и посмотрите, как код читается с каждым из них.

    В идеальном случае кол-во аргументов функции равно нулю. Функция с тремя аргументами по возможности следует избегать. Аргументы плохи тем, что читающему код нужно постоянно помнить о подробностях. Под подробностями понимается аргумент функции. Так же аргументы создают проблемы при написании тестов, потому что нужно много вариантов чтобы оттестировать функцию.

    Передача логического значения в функцию - воистину ужасная привыска. То есть, когда при ложном агрументе выполняется одно, а при истинном, другое.

    Если функция должна принимать более двух или трёх агрументов стоит упаковать их в класс и передать - public function set_product(new Product(), $params)

    Функция что то должна делать или отвечать на какой то вопрос, но не одновременно!

    Возвращение кода ошибки обычно подразуменвает наличие класса или функция в котором определяются все коды ошибок.

    Не повторяйтесь.

    Как научиться писать функции описанные в этой главе? - писать код, а потом его причёсывать.

    "Искусство прораммирования является и всегда было искусством языкового проектирования". Опытные программисты рассматривают систему, как историю, которую они должны рассказать, а не как программу, которую можно написать.
*/

/*
    Глава 4. Комментарии.

    "Не комментируйте плохой код - перепишите его". 

    Если вы оказались в ситуации, когда нужно написать комментарий, подумайте о возможности переписать код так, чтобы не пришлось оставлять комментарий.

    Комментарии - зло, потому что код изменяется и эволюционирует, при этом не всегда программист вспоминает о поддержке комментариев. В итоге они становятся устаревшими и дизенформируют других читателей кода.

    Чтобы объяснить намерение кодом, а не комментарием можно написать функцию.

    Но всё же есть полезные комментарии:

        - которые обычно помещают для описания работы модуля в общем

        - которые описывают функцию в общем и рассказывают о её аргументах

        - комментирование кусков из инородных модулей, изменить код которых нет возможности

        - предупреждение о последствиях (запускайте данный метод только для тестирования)

        - заметки на будущее или TODO комментарии (на данный момент не используется, но ситуация измениться при переходе к отладке)

        - усиление значения (вызов данной функции очень важен, потому что)

        - если идёт разработки api

    Если вы всё же решили написать комментарий, то потратьте на это время и сделайте самый лучший комментарий на сколько это возможно.

    Любой комментарий смысл которого приходится искать в других модулей, не несёт полезной информации.

    Не создавайте журнальных комментариев - это когда в начале модуля формируется лист из записей по каждому апдейту.

    Использовать функции или переменные вместо комментированя.

    Не использовать комментарии после фигурных скобок.

    Не включайте в комментарии исторические дискуссии.
*/

/*
    Глава 5. Форматирование.

    Если вы работаете в группе, то нужно разработать набор правил форматирования.

    Маленькие файлы обычно более понятны, чем большие.

    Имя файла должно быть простым, но содержательным.

    Каждая группа строк должна представлять собой законченную мысль и отделяться от другой группы пустой строкой.

    Концепции связанные друг с другом, должны находиться рядом друг с другом. Например внутри класса контроллера есть метод обрабатывающий роут и рядом с ним объявленны функции, которые он использует.

    Переменные следует объявлять, как можно ближе к месту использования.

    Функция, которая вызывает другую, должна находиться выше вызываемой.

    Строки по возможности должны быть короткими.

    
*/