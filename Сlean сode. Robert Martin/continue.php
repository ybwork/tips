<?php

/*
	Глава 5. Форматирование. (Продолжение)

	Работая в группе нужно согласовать единый стиль форматирования и его должен придерживаться каждый программист. "Это были не правила, которые предпочитал лично я, это были правила выбранные группой. И я, как участник группы неуклонно соблюдал их"

	Не усложняйте код, допуская его оформление в разных стилях.
*/

/*
	Глава 6. Объекты и структуры данных.

	Опытные программисты хорошо знают: представление о том, что все данные должны представляться в виде объектов - миф.

	Закон Деметры гласит: модуль не должен знать внутреннее устройство объектов с которыми он работает. Это означает, что метод не должен расскрывать свою внутреннюю структуру через методы доступа.
*/

/*
	Глава 7. Обработка ошибок.

	Обработка ошибок важна, но если она засоряет логику программы, значит она реализованна неверно.

	Используйте исключени вместо кодов ошибок, потому что если мы возвращаем код ошибки, то вызывающая сторона должна проверить ответ, а это ведёт к условным оператрам и загромождению кода, плюс можно забыть проверить ответ.

	Создавайте содержательные сообщения об ошибках и передавайте их со своими исключениями.

	Не возвращайте null, потому что это загромождает клиентский код условными операторами if. Если вы работаете с сторонним api и он возвращает null, то можно создать метод, который будет обрабатывать ответ api и вместо null выбрасывать исключение.

	Не передавать в функцию null.
*/

/*
	Глава 8. Границы.

	В этой главе идёт речь о внедрении чужого кода, например использование сторонней библиотеки. Для успешной работы этого кода его нужно проверить, автор предлагает учебные тесты. (beckTDD)

	Класс адаптер инкапсулировал взаимодействие с api.
*/

/*
	Глава 9. Модульные тесты.

	По требованиям методологии TDD модульный тест должен писаться до написания кода продукта. Но есть ещё 3 важных закона:

		1. Не пишите код продукта пока не напишите отказной модульный тест

		2. Не пишите модульный тест в объёме большем, чем необходимо для отказа

		3. Не пишите код продукта в объёме большем, чем необходимо для прохождения написанного для него теста

		При этом тесты пишутся вместе с кодом, но немного опережают его. То есть написали тест для данного куска, затем написали кусок. Потому ещё написали тест на следующий кусок и написали код для этого куска и т.д.

	Тесты на скорую руку равнозначны, если не хуже отсутствию тестов.

	Без тестов нельзя понять, влияет ли внесение изменений в одну часть программы на изменения в других?

	Тестовый код не менее важен, чем код продукта.

	В каждой тестовой функции должна тестироваться одна концепция

	Помимо этого тесты должны обладать следующими характеристиками:

		- должны выполняться быстро чтобы их хотелось запускать

		- не должны зависеть друг от друга

		- должны выдавать повторяемые результаты в любой среде

		- результатом теста должен быть логический признак, то есть прошёл тест или не прошёл
*/

/*
	Глава 10. Классы.

	По стандартам Java класс должен начинаться со списка переменных. Открытых переменных обычно нет.

	За списком переменных обычно следуют открытые функции. Если открытая функция использует вспомогательную функцию, то её делают закрытой и размещают сразу за основной.

	Если для тестов необходим доступ к приватному св-ву или методу, то их можно открыть, но всегда следует проектировать класс с поиска способа, сохраняющего приватность.

	Классы должны быть компактными.

	Использовать:

		Имя класса должно описывать его ответственности. Чтобы понять использует класс одну ответственность или нет нужно описать то, что он делает. Если описание больше 25 слов и в нём присутствуют слова: "и", "или", "если", "но", то указывает на то, что класс имеет много ответственностей.

	Система должна состоять из множества мелких классов, а не из большого числа больших. Каждый класс имеет одну ответственность и взаимодействует с другими классами для достижения нужной функциональности программы.

	Разбивайте большие классы и функции на более маленькие.

	Использовать (возможно и только в нужных ситуациях):

		Для каждого метода интерфейса используем отдельный класс

		abstract class Sql
		{
			public function sql(string $table_name, array table_columns);
			abstract public function generate();
		}

		class Insert extends Sql
		{
			code...
		}

	Классы должны быть открыты для расширений, но закрыты для модификации. В идеале новая функциональность должна реализовываться расширением системы, а не внесением изменений в уже существующий код.

	Классы системы должны зависеть от абстракций, а не от конкретных подробностей.
*/

/*
	Глава 11. Системы.

	Прежде всего необходимо понять, что конструирование и использование системы - два совершенно разных процесса.

	Например такой код создаёт зависимости и его следует избегать:

	public function get()
	{
		$model = new User();
		$model->get();
	}

	Исправить ситуацию может внедрение зависимостей

	public function get(User $user)
	{
		$user->get();
	}

	BDUF - привычка проектировать заранее всё без исключения, до написания какого-либо кода реализации.

	Принятие решений лучше всего откладывать до последнего, потому что это позволяет собрать всю информацию о проекте и принять правильное, информативное решение.

	Чистым должен быть не только код, но и архитектура системы.

	Используйте самое простое решение из всех возможных. 
*/

/*
	Глава 12. Формирование архитектуры.

	Согласно Кенту Беку архитектура может считаться "простой" если она:

		- обеспечивает прохождение всех тестов

		- не содержить дублирующегося кода

		- выражает намерения программиста

		- использует минимальное колличество классов и методов

	Паттерн "Шаблонный метод" может помочь в устранении дублирования.
*/

/*
	Глава 13. Многопоточность.

	Многопоточность устраняет привязки, помогая отделить выполняемую операцию от момента её выполнения.

	Многопоточность хорошо выручает там, где время отклика системы должно быть быстрым. Например есть сайт на котором собирается информация с других сайтов. Если это однопоточное приложение, то пока вся информация с каждого сайта не будет собрана, приложение не покажет пользователю результат или не запишет его в базу. Но что если на это требуется больше 24 часов, а ждать пользователь может только 23. Именно в такой ситуации на сцену выходит многопоточность, которая может паралельно собирать информацию с нескольких сайтов.

	Для правильной реализации многопоточности серьёзно отнеситесь к инкапсуляции данных и жётско ограничьте доступ к общим данным.

	Использовать:

		Постарайтесь писать многопоточный код так, чтобы каждый поток существовал в собственном замкнутом пространстве и не использовал данные совместно с другими процессами. Каждый поток обрабатывает один клиентский запрос, все его данные берутся из отдельного источника и хроняться в локальных переменных.

	После создания многопоточность нужно протестировать на разных платформах, потому что её реализация отличается в windows и os x

	Если понадобиться реализовать многопоточность прочитать данную главу ещё раз.
*/

/*
	Глава 14. Последовательное очищение.

	Чтобы написать чистый код, мы сначала пишем грязный код, а затем очищаем его.

	Писать программу лишь бы она заработала равносильно самоубийству.

	Согласно TDD система должна работать в любой момент в процессе внесения изменений. Иначе говоря, нельзя вносить изменения, которые нарушат её работоспособность. Для этого нужно тестировать каждый новый шаг.

	Иногда лучше перестроить систему, чем добавлять изменения.
*/

/*
	Глава 15. Внутреннее строение JUnit.

	JUnit - это библиотека для модульного тестирования.

	Не читаю дальше, так как эта информация пока ненужна.
*/

/*
	Глава 16. Переработка SerialDate.

	Здесь разбор кода библиотеки JCommon. (изучить потом, если понадобится)
*/

/*
	Глава 17. Запахи и эвристические правила.

	Список того, что "дурно пахнет" при чтении кода:

		- в комментариях не уместно хранить информацию о истории изменений, авторах и т.п.

		- не пишите комментарии, которые с течением времени устареют

		- избыточным считается комментарий, который описывает то, что и так очевидно (например эта переменная возрастает $i++;)

		- комментарии должны говорить то, что не может сказать сам код

		- увидев закомментированный код, удалите его

		- все модульные тесты должны выполняться одной командой и должны быть быстрыми

		- желательно делать функции без аргументов, но в пределе 3-х аргументов это терпимо

		- выходные аргументы функции противоестественны

		- избегать флаги в аргументах, потому что это как минимум говорит о том, что функция делает не одно действие

		- не бойтесь удалять функции, которые не используются

		- свести к минимуму использование разных языков в одном файле

		- на этапе разработки не отключать вывод ошибок

		- не повторяйтесь

		- хорошо определённый интерфейс имеет небольшое кол-во функций

		- скрывайте вспомогательные функции, константы и переменные класса

		- переменные и функции должны объявляться вблизи от места их использования

		- когда метод одного класса использует метод другого класса, пусть и через внедрение зависимостей, то это плохо (проверить)

		- функция не должна вызываться с аргументами типа true/false

		- лучше использовать нестатические функции, но если вы уверены, что не понадобиться полиморфное поведение, то можно и статические

		- используйте пояснительные переменные

		- имена функций должны описывать выполняемые действия (если приходится читать функцию, чтобы понять, что она делает, её лучше переназвать)

		- Правило одной команды if/switch

		- Общие стандарты кодирования

		- числа стоит скрыть в константах с содержательными названиями

		- передавать в функцию аргументы в виде переменных, а не волшебные числа и строки - show(1, 'John');

		- архитектура важнее кода

		- инкапсулируйте условные инструкции

		- избегать отрицательных условий в if, потому что они сложнее для понимания

		- Функция должна выполнять одну операцию. Пример неправильной функции:
                
        public void pay()
        {
            for (Employe $e as $employes) {
                if (e.isPayDay()) {
                    Money pay = e.calculatePay();
                    e.deliverPay(pay);
                }
            }
        }

        Эта функция выполняет сразу три операции: перебирает всех работников, проверяет начисленны ли работнику какие-то выплаты и наконец производит оплату. Поэтому её лучше разбить на 3 отдельных.

        - модуль не должен обладать знаниями о других компонентах с которыми он работает

        - используйте содержательные имена

        - не используйте имена, передающие информацию о реализации

        - используйте в именах переменных стандартные имена, наприме для шаблона декоратор - decorator, для работы со строкой - toString()
*/