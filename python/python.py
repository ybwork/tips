# Вложенные инструкции объединяются в блоки по величине отступов

# Конец строки является концом инструкции (точка с запятой не требуется)

# Иногда возможно записать несколько инструкций в одной строке, разделяя их точкой с запятой (но лучше так не делать)
a = 1; b = 2; print(a, b)

# Допустимо записывать одну инструкцию в нескольких строках
if (a == 1 and b == 2 and
    c == 3 and d == 4):
      print('spam' * 3)

# if может быть в одну строку
if x > y: print(x)

# if
if a == b:
    print("good")
elif a < b:
    print("bad")
else:
    print("normal")

# Истинность в Python:

    # Числа, равные 0, пустые объекты и значение None - ложь

    # and, or, not

# while (довольно медленный)
i = 5

while i < 15:
    print(i)

    i = i + 2

# for (выполняется гораздо быстрее цикла while)
for user in users
    print(user)

# continue (начинает следующий проход цикла, минуя оставшееся тело цикла)
for user in users
    if user == ''
        continue
    print('hi')


# break (досрочно прерывает цикл)
for user in users
    if user == 'test'
        break
    print('hi')

# with as

    # Используется для гарантии того, что критические функции выполнятся в любом случае. Самый распространённый пример использования этой конструкции - открытие файлов.

# типы чисел:

    # int (целые)

    # float (вещественные)

        # Для высокой точности используют другие объекты (например Decimal или Fraction)

        # Не поддерживают длинную арифметику

    # complex (комплексные)

# модули для работы с числами:

    # Модуль math предоставляет более сложные математические функции

    # Модуль random реализует генератор случайных чисел и функции случайного выбора.

    # Модуль cmath реализует для работы с комплексными числами

'''
    Строки
'''

    # строки в Python относятся к категории неизменяемых последовательностей, то есть все функции и методы могут лишь создавать новую строку.

    # конкатенация
    a = 'test'
    b = 'test2'
    print(a + b)

    # дублирование
    print('test3' * 3)

    # длинна строки
    len('spam')

    # доступ по индексу
    t = 'test'
    t[0]

    # срез (X – начало среза и в срез не входит, а Y – окончание)
    a = 'testimo'
    # выведет mo
    a[5:2]
    # 3 число это шаг, с которым нужно извлекать срез
    a[2:2:1]

    # форматирование строк (динамическое подставление в строку)
    'hello {}'.format('Ilya')

'''
    байтовые строки
'''
    
    # Байт - минимальная единица хранения и обработки цифровой информации. Последовательность байт представляет собой какую-либо информацию (текст, картинку, мелодию...)

    '''
        Неизменяемый тип.

        Функция bytes принимает список чисел от 0 до 255 и возвращает байты, получающиеся применением функции chr.
    '''
    bytes([50, 100, 76, 72, 41])

    # отличается только тем, что является изменяемым
    bytearray("Строка", "utf-8")

    # Обычно байты надо записать в файл / прочесть из файла и преобразовать во что-либо другое

'''
    списки (lists)
'''

    # это изменяемые коллекции объектов произвольных типов (почти как массив, но типы могут отличаться).

    # обычное создание
    a = list('test')
    b = []

    # создание с помощью генератора (позволяет написать более короткий код)
    [c * 3 for c in 'list']

    # методы списков изменяют сам список

'''
   срезы списков
'''
    
    # срез
    item[START:STOP:STEP]

    # С помощью срезов можно не только извлекать элементы, но и добавлять и удалять элементы

'''
    кортежи (tuple)
'''

    # это неизменяемый список, который имеет меньший размер и который можно использовать в качестве ключа словаря

    a = tuple()
    b = ('a', )
    c = 'a',

'''
    словари (dictionaries)
'''

    # это ассоциативными массивами или хеш-таблицами

    a = {}
    b = dict(name = 'ilya', surname = 'kaduk')
    d = dict.fromkeys(['a', 'b'])
    c = {a: a ** 2 for a in range(7)}

'''
    множество
'''

    # это "контейнер", содержащий не повторяющиеся элементы в случайном порядке

    '''
        изменяемый тип данных

        выведет {'h', 'o', 'l', 'e'}
    '''
    a = set('hello')

    # неизменяемый тип данных
    b = frozenset('nice')


'''
    Исключения
'''
    
    try:
        k = 1 / 0
    except Exception:
        print('bad')
    else:
        print('good')
    finally:
        print('need show')

'''
   работа с файлами
'''

    f = open('text.txt', 'r')

    f.read()

    f.write('test')

    f.close()

'''
    with as
'''
    
    # это менеджеры контекста, использовать, когда нужно чтобы критические функции выполнились в любом случае, а если идёт работа с файлом, то он будет закрыт автоматически

    # положи файл в переменную g
    with open('newfile.txt', 'w', encoding='utf-8') as g:
        print(g)

'''
    модули
'''

    # модулем в Python называется любой файл с программой

    # подключение
    import time, random as r

    # подключение и импортом выбранных атрибутов
    from math import e, ceil

    # пути поиска модулей указаны в переменной sys.path

'''
    ключевые слова:

        keyword.kwlist (показывает все ключевые слова)

        false

        true

        none

        and

        with as

        assert (возбуждает исключение, если условие ложно)

        break

        class 

        continue

        def (определение функции)

        del (удаление объекта)

        if

        elif

        else

        except (перехватить исключение)

        finally (выполняет инструкции независимо от того, было ли исключение или нет)

        for

        in (проверка на вхождение)

        import (импорт модуля)

        from (импорт нескольких функций из модуля)

        global (делает значение доступным вне функции)

        is (ссылаются ли 2 объекта на класс)

        lambda (определение анонимной функции)

        raise (возбудить исключение)

        yield (определение функции-генератора)

'''

""" Функции """

    def all():
        return 'all users'

    @staticmethod
    def get():
        return 'result static function'

""" Методы """

    class A:
        def all(self):
            return 'all users'

""" 
Один из важных фактов, которые следует понимать, заключается в том, что функции и методы в Python — это практически одно и то же, за исключением того, что методы всегда ожидают первым параметром ссылку на сам объект (self).
"""

""" Магические переменные *args и **kwargs """

    """ 
        Я много раз замечал, что у новых Python разработчиков вызывают трудности магические переменные *args и **kwargs. Так что же они из себя представляют? Во-первых, позвольте сказать, что вам не обязательно называть их именно *args и **kwargs. Только * (звездочка) действительно необходима. К примеру, их можно назвать *var и **vars. Использование *args и **kwargs идет на уровне соглашения между разработчиками.

        *args используется для передачи произвольного числа неименованных аргументов функции. 

        **kwargs позволяет вам передавать произвольное число именованных аргументов в функцию.
    """

    def test_args_kwargs(arg1, arg2, arg3):
        print("arg1:", arg1)
        print("arg2:", arg2)
        print("arg3:", arg3)

    args = ("two", 3, 5)
    test_args_kwargs(*args)
    """ 
    arg1: two
    arg2: 3
    arg3: 5
    """

    kwargs = {"arg3": 3, "arg2": "two", "arg1": 5}
    test_args_kwargs(**kwargs)
    """ 
    arg1: 5
    arg2: two
    arg3: 3
    """

""" Lambda функции """

    """ 
    Анонимные функции могут содержать лишь одно выражение, но и выполняются они быстрее. Анонимные функции создаются с помощью инструкции lambda. Кроме этого, их не обязательно присваивать переменной
    """

    func = lambda x, y: x + y
    func(1, 2) 
