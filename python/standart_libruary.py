Стандартная библиотека Python
Хотя "Справочник по языку Python" описывает точный синтаксис и семантику языка Python, это справочное руководство описывает стандартную библиотеку, распространяемую с Python. Здесь также описываются некоторые дополнительные компоненты, которые обычно включены в дистрибутивы Python.

Стандартная библиотека языка Python очень обширна, предлагает большой набор средств, что можно увидеть из длинного оглавления ниже. Библиотека содержит встроенные модули (написанные на Си), которые обеспечивают доступ к функциям системы, таким как файловый ввод/вывод, и которые могли бы оказаться недоступными для Python-программистов, а также модули, написанные на Python, которые предоставляют стандартные решения для многих проблем, которые возникают при каждодневном программировании. Некоторые из этих модулей предназначены исключительно для поддержки и повышения переносимости программ на Python путем абстрагирования от специфики платформы в платформенно-нейтральный API.

Установщики Python для платформы Windows, как правило, включают в себя всю стандартную библиотеку и часто также включают множество дополнительных компонентов. Для Unix-подобных операционных систем Python обычно поставляется в виде набора пакетов, так что может оказаться необходимым использовать упаковочные инструменты, предоставляемые вместе с операционной системой, чтобы получить некоторые или все из дополнительных компонентов.

В дополнение к стандартной библиотеке, есть растущая коллекция из нескольких тысяч компонентов (от отдельных программ и модулей в пакетах до ​​целых фреймворков разработки приложений), доступных на Python Package Index (pypi.python.org/pypi).

1. Введение
"Библиотека Python" включает несколько разных видов компонентов.

Она содержит типы данных, которые обычно считаются частью «ядра» языка, как, например, числа и списки. Для этих типов ядро ​​языка Python определяет форму литералов и накладывает некоторые ограничения на их семантику, но полностью не определяет ее. (С другой стороны ядро ​​языка определяет синтаксические свойства как в написании, так и в приоритете операторов.)

Библиотека также содержит встроенные функции и исключения - объекты, которые могут использоваться во всем коде Python без необходимости использования оператора import (docs.python.org/3/reference/simple_stmts.html#import). Некоторые из них определяются ядром языка, но многие не является необходимыми для семантики ядра и только описаны здесь.

Однако основная часть библиотеки состоит из набора модулей. Существует много способов проанализировать эту коллекцию. Некоторые модули написаны на языке C и встроены в интерпретатор Python; другие написаны на Python и импортированы в виде исходного кода. Некоторые модули обеспечивают интерфейсы, которые весьма специфичны для Python, например вывод трассировки стека; некоторые предоставляют интерфейсы, которые являются специфическими для конкретных операционных систем, такие как доступ к конкретному оборудованию; другие предоставляют интерфейсы, которые являются специфическими для конкретной области приложений, как, например, World Wide Web. Некоторые модули доступны во всех версиях и портах Python; другие доступны только тогда, когда лежащая в основе система поддерживает или требует их; другие доступны только тогда, когда был выбран конкретный параметр конфигурации при компиляции и установки Python.

Это руководство организовано "шиворот навыворот": оно сначала описывает встроенные типы данных, затем встроенные функции и исключения, и, наконец, модули, сгруппированные в главах связанных модулей.

Это означает, что если вы начнете читать данное руководство с самого начала и переходите к следующей главе, то когда вам надоест, вы уже получите приемлемый обзор доступных модулей и областей применения, которые поддерживаются библиотеками Python. Конечно, вы не обязаны читать руководство как роман - вы также можете просмотреть оглавление (в начале руководства), или искать конкретную функцию, модуль или термин в индексе (в конце). И, наконец, если вам нравится узнавать о случайных предметах, вы выбираете случайный номер страницы (см. модуль random (docs.python.org/3/library/random.html#module-random)) и читаете раздел или два. Независимо от того, как вы будете читать разделы данного руководства, начните с главы "Встроенные функции", так как остальная часть руководства предполагает знакомство с этим материалом.

2. Встроенные функции
У интерпретатора Python есть ряд встроенных в него функций и типов, которые доступны всегда. Здесь они перечислены в алфавитном порядке.

abs(x)

Возвращает абсолютное значение числа. Аргумент может быть целым или числом с плавающей точкой. Если аргумент является комплексном числом, возвращается его величина.

all(iterable)

Возвращает True, если все элементы iterable возвращают правду (или если итерируемый объект пуст). Эквивалентно к:

def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
any(iterable)

Возвращает True, если какой-нибудь элемент iterable возвращает истину. Если итерируемый объект пуст, возвращается False. Эквивалентно к:

def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
ascii(object)

Как repr() возвращает строку, содержащую представление объекта для печати, но избегая не-ASCII символов в строке, возвращаемых repr(), используя \x, \u или \U выходы. Это создает строку, подобную той, что возвращает repr() в Python 2.

bin(x)

Преобразует целое число в двоичную строку, имеющую префикс '0b'. Результатом является допустимое выражение Python. Если x не является Python-объектом int, он должен определить метод __index__() (docs.python.org/3/reference/datamodel.html#object.__index__), который возвращает целое. Несколько примеров:

>>> bin(3)
'0b11'
>>> bin(-10)
'-0b1010'
В зависимости от того, требуется префикс '0b' или нет, вы можете использовать любой из следующих способов.

>>> format(14, '#b'), format(14, 'b')
('0b1110', '1110')
>>> f'{14:#b}', f'{14:b}'
('0b1110', '1110')
См. также format() для большей информации.

class bool([x])

Возвращает значение Boolean (логический, или двоичный, тип данных - прим. пер.), т. е. True или False. x преобразуется с помощью стандартной процедуры тестирования истины. Если x является ложью или пропущен (вызов без аргумента - прим. пер.), то возвращается False; в противном случае возвращается True. Класс bool - это подкласс int (см. Числовые типы - int, float, complex). От него нельзя образовывать подклассы дальше. Единственные его экземпляры - это False и True (см. Булевы значения).

class bytearray([source[, encoding[, errors]]])

Возвращает новый массив байтов. Класс bytearray представляет собой изменяемую последовательность целых чисел в диапазоне 0 <= x < 256. У нее есть большинство обычных методов изменяемых последовательностей, описанных в Изменяемые типы последовательностей, а также большинства методов, которые имеет тип bytes, см. Операции Bytes и Bytearray.

Необязательный параметр source можно использовать для инициализации массива несколькими различными способами:

Если это string, необходимо также задать параметр encoding (и необязательно errors); затем bytearray() преобразует строку в байты используя str.encode().
Если это integer, массив будет иметь тот же размер и будет инициализирован нулевыми байтами.
Если это объект, соответствующий интерфейсу buffer, для инициализации массива байтов будет использоваться read-only буфер объекта.
Если это iterable, он должен быть итерацией целых чисел в диапазоне 0 <= x < 256, которые используются в качестве начального содержимого массива.
Без аргумента создается массив размером 0.

См. также Типы бинарных последовательностей - bytes, bytearray, memoryview и Объекты Bytearray.

class bytes([source[, encoding[, errors]]])

Возвращает новый объект “bytes”, который является неизменной последовательностью целых чисел в диапазоне 0 <= x < 256. bytes - это неизменяемая версия bytearray - она имеет те же неизменяющие методы и такую же индексацию и взятие срезов.

Соответственно, аргументы конструктора интерпретируются также как для bytearray().

Объекты bytes также могут быть созданы с литералов, см. String and Bytes literals (docs.python.org/3/reference/lexical_analysis.html#strings).

См. также Типы бинарных последовательностей - bytes, bytearray, memoryview, Объекты Bytes и Операции Bytes и Bytearray.

callable(object)

Возвращает True, если аргумент object является вызываемым, False, если нет. Если возвращается истина, все еще возможно, что вызов не удастся, но если это ложь, вызов object никогда не удастся. Обратите внимание, что классы вызываемы (вызов класс возвращает новый экземпляр); экземпляры вызываемы, если их класс имеет метод __call__() (docs.python.org/3/reference/datamodel.html#object.__call__).

Новое в версии 3.2: Эта функция была сначала удалена из Python 3.0, а затем занесена обратно в Python 3.2.

chr(i)

Возвращает строку, представляющую символ, чей код Юникода является целым числом i. Например, chr(97) возвращает строку 'a', в то время как chr(8364) вернет строку '€'  Эта функция является противоположной для ord().

Допустимый диапазон для аргумента: от 0 до 1,114,111 (0x10FFFF по основанию 16). Будет возбуждаться ValueError, если i выходит за эти пределы.

classmethod(function)

Возвращает метод класса для function.

Метод класса получает класс как неявный первый аргумент, также как метод экземпляра получает экземпляр. Чтобы объявить метод класса, используйте эту идиому:

class C:
    @classmethod
    def f(cls, arg1, arg2, ...): ...
Форма @classmethod является декоратором (docs.python.org/3/glossary.html#term-decorator) функции - для дополнительной информации см. описание определений функций в Function definitions (docs.python.org/3/reference/compound_stmts.html#function).

Функцию можно вызвать либо на класс (как C.f()), либо на экземпляр (как C().f()). Экземпляр игнорируется за исключением его класса. Если метод класса вызывается для производного класса, объект производного класса передается как предполагаемый первый аргумент.

Методы класса отличаются от статических методов C++ или Java. Если вам необходимо подобное, см. staticmethod() в этом разделе.

Для получения более подробной информации о методах класса, обратитесь к документации по стандартной иерархии типов в The standard type hierarchy (docs.python.org/3/reference/datamodel.html#types).

compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)

Компиляция source в код или объект AST. Кодовые объекты могут быть выполнены exec() или eval(). source может быть либо обычной строкой, либо строкой байтов или объектом AST. Обратитесь к документации модуля ast (docs.python.org/3/library/ast.html#module-ast) для получения информации о том, как работать с объектами AST.

Аргумент filename должен передать файл, из которого читается код; передается некоторое распознаваемое значение, если не было чтения из файла (обычно используется '<string>').

Аргумент mode определяет, какой код должен быть скомпилирован; это может быть 'exec', если source состоит из последовательности операторов,'eval', если состоит из одного выражения, или 'single', если он состоит из одного интерактивного оператора (в последнем случае операторы выражения, которые расцениваются как что-то другое, чем None, будут напечатаны).

Необязательные аргументы flags и dont_inherit управляют будущими операторами (см. PEP 236 (www.python.org/dev/peps/pep-0236)), влияющими на компиляцию source. Если их нет (или оба равны нулю) код компилируется с теми будущими операторами, которые в действительности в коде, который вызывает compile(). Если аргумент flags задан, а dont_inherit нет (или равен нулю), то будущие операторы, указанные в аргументе flags используются в дополнение к тем, которые использовались бы в любом случае. Если dont_inherit является ненулевым целым, то аргумент flags - будущие операторы в действительности вокруг вызова компиляции игнорируются.

Будущие операторы задаются битами, которые могут быть побитово ORed вместе для задания нескольких операторов. Логическое поле необходимое к указанию переданной функции можно найти как атрибут compiler_flag экземпляра _Feature в модуле __future__ (docs.python.org/3/library/__future__.html#module-__future__).

Аргумент optimize определяет уровень оптимизации компилятора; значение по умолчанию -1 выбирает уровень оптимизации интерпретатора как заданный опцией -O (docs.python.org/3/using/cmdline.html#cmdoption-O). Явные уровни 0 (нет оптимизация; __debug__ есть true), 1 (утверждения удаляются, __debug__ есть false) или 2 (строки документации удаляются также).

Эта функция возбуждает SyntaxError (docs.python.org/3/library/exceptions.html#SyntaxError), если компилируемый код содержит ошибки, и ValueError (docs.python.org/3/library/exceptions.html#ValueError), если код содержит несуществующие (null) байты.

Если вы хотите парсить код Python в его предтавление AST, см. ast.parse() (docs.python.org/3/library/ast.html#ast.parse).

Примечание. Когда компилируется строка с многострочным кодом в режимах 'single' или 'eval', ввод должен быть завершен по крайней мере одним символом новой строки. Это необходимо для облегчения обнаружения неполных и полных выражений в модуле code (docs.python.org/3/library/code.html#module-code).

Изменено в версии 3.2: Разрешено использование новой строки Windows и Mac. Также ввод в режиме 'exec' не должен больше заканчиваться символом новой строки. Добавлен параметр optimize.

Изменено в версии 3.5: Ранее возбуждалось TypeError (docs.python.org/3/library/exceptions.html#TypeError), когда в sourse встречались несуществующие байты.

class complex([real[, imag]])

Возвращает комплексное число со значением real + imag*1j или преобразовывает строку или число в комплексное число. Если первый параметр является строкой, она будет интерпретирована как комплексное число, и функция должна быть вызвана без второго параметра. Второй параметр никогда не может быть строкой. Каждый аргумент может быть любым числовым типом (в том числе комплексным). Если imag опущен, то по умолчанию равен нулю, и конструктор работает как числовое преобразование подобно int() и float(). Если оба аргумента опущены, возвращается 0j.

Примечание: При преобразовании из строки, она не должна содержать пробелы вокруг центрального оператора + или -. Например, complex('1+2j') правильно, но complex('1 + 2j') вызовет ValueError (docs.python.org/3/library/exceptions.html#ValueError).

Комплексный тип описан в Числовые типы — int, float, complex.

Изменено в версии 3.6: Допускается группировка цифр с символами подчеркивания, как в литералах кода.

delattr(object, name)

Родственный с setattr(). Аргументы являются объектом и строкой. Строка должна быть именем одного из атрибутов объекта. Функция удаляет названный атрибут, если предоставленный объект это позволяет. Например, delattr(x, 'foobar') эквивалентно del x.foobar.

class dict(**kwarg)
class dict(mapping, **kwarg)
class dict(iterable, **kwarg)

Создает новый словарь. Объект dict является классом словаря. См. dict и Типы отображений — dict для получения сведений об этом классе.

Для других контейнеров см. встроенные классы list, set и tuple, также как модуль collections (docs.python.org/3/library/collections.html#module-collections).

dir([object])

Без аргументов возвращает список имен в текущем локальной области видимости. С аргументом пытаться вернуть список допустимых атрибутов для указанного объекта.

Если у объекта есть метод с именем __dir__() (docs.python.org/3/reference/datamodel.html#object.__dir__), этот метод будет вызван и должен вернуть список атрибутов. Это позволяет объектам, которые реализуют обычные функции __getattr__() (docs.python.org/3/reference/datamodel.html#object.__getattr__) или __getattribute__() (docs.python.org/3/reference/datamodel.html#object.__getattribute__), настроить способ, каким dir() будет представлять их атрибуты.

Если объект не предоставляет __dir__(), функция пытается сделать все возможное, чтобы собрать информацию из атрибута объекта __dict__, если он определен, и от его типа объекта. Результирующий список не обязательно является полным и может быть неточным по-сравнению с тем, когда у объекта есть __getattr__().

По умолчанию механизм dir() ведет себя по-разному с различными типами объектов, так как он пытается произвести наиболее актуальную, а не полную информацию:

Если объект является объектом-модулем, список содержит имена атрибутов модуля.
Если объект представляет собой объект-тип или объект-класс, список содержит имена его атрибутов и рекурсивно атрибуты его базовых классов.
Иначе список содержит имена атрибутов объекта, имена атрибутов его класса, и рекурсивно атрибутов базовых классов его класса.
Результирующий список отсортирован в алфавитном порядке. Например:

>>> import struct
>>> dir()   # показывает имена в пространстве имен модуля
['__builtins__', '__name__', 'struct']
>>> dir(struct)   # показывает имена в модуле struct 
['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',
 '__initializing__', '__loader__', '__name__', '__package__',
 '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
 'unpack', 'unpack_from']
>>> class Shape:
...     def __dir__(self):
...         return ['area', 'perimeter', 'location']
>>> s = Shape()
>>> dir(s)
['area', 'location', 'perimeter']
Примечание. Поскольку dir() предоставляется в основном как удобство для использования в интерактивном режиме, он пытается предоставить интересующий набор имен в большей степени, чем пытается поставить строго или последовательно определенный набор имен, и его подробное поведение может измениться через релизы. Например, атрибутов метакласса нет в списке результатов, когда аргумент является классом.

divmod(a, b)

Принимает два (не комплексных) числа в качестве аргументов и возвращает пару чисел, составляющих их частное и остаток, когда используется целочисленного деление. Если операнды разных типов, применяются правила для бинарных арифметических операторов. Для целых чисел результат будет таким же, как (a // b, a % b). Для вещественных чисел результат есть (q, a % b), где q обычно math.floor(a / b), но может быть 1 меньше, чем то. В любом случае q * b + a % b очень близко к a, если a % b не равна нулю, то имеет тот же знак, что и b, 0 <= abs(a % b) < abs(b).

enumerate(iterable, start=0)

Возвращает перечисляемый объект. iterable должен быть последовательностью, iterator (docs.python.org/3/glossary.html#term-iterator) или другим объектом с поддержкой итераций. Метод __next__() итератора, возвращаемого enumerate(), возвращает кортеж, содержащий счетчик (start которого по умолчанию 0) и значения, полученные из перебора по iterable.

>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
Эквивалентно:

def enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1
eval(expression, globals=None, locals=None)

Аргументы - это строка и необязательные globals и locals. При наличии, globals должен быть словарем. Если предоставлен, locals может быть любым объектом отображения (mapping).

Аргумент expression анализируется и оценивается как выражение Python (с технической точки зрения, список условий), использующее globals и locals словари как глобальные и локальные пространства имен. Если словарь globals присутствует и не хватает '__builtins__', текущие глобальные копируются в globals перед тем, как анализируется expression. Это означает, что expression обычно имеет полный доступ к стандартному модулю builtins (docs.python.org/3/library/builtins.html#module-builtins) и распространяются ограничения окружения. Если словарь locals опущен, по умолчанию используется словарь globals. Если оба словаря опущены, выражение выполняется в среде, где вызывается eval(). Возвращаемое значение является результатом вычисляемого выражения. Синтаксические ошибки сообщаются как исключения. Пример:

>>> x = 1
>>> eval('x+1')
2
Эта функция также может быть использована для выполнения произвольных кодов-объектов (например, тех, которые созданы compile()). В этом случае передается объект кода вместо строки. Если объект-код был скомпилирован с 'exec' как аргумент mode, возвращаемое значение eval() будет None.

Советы: динамическое исполнение операторов поддерживается функцией exec(). Функции globals() и locals() возвращают текущие глобальные и локальные словари соответственно, которые могут быть полезны к распространению для использования eval() или exec().

См. ast.literal_eval() (docs.python.org/3/library/ast.html#ast.literal_eval) для функции, которая может безопасно оценить строки с выражениями, содержащими только литералы.

exec(object[, globals[, locals]])

Эта функция поддерживает динамическое выполнение Python-кода. object должен быть строкой или кодовым объектом. Если это строка, она обрабатывается как набор операторов Python, которые затем выполняются (если только не происходит ошибка синтаксиса). [1] Если это объект-код, он просто выполняется. Во всех случаях код, который выполняется, как предполагается будет действителен в качестве входных файлов (см раздел "File input" в справочном руководстве). Знайте, что операторы return и yield не могут быть использованы за пределами определений функций даже в контексте кода переданного функции exec(). Возвращаемое значение None.

Во всех случаях если дополнительные части опущены, код выполняется в текущей области видимости. Если предоставляется только globals, это должен быть словарь, который будет использоваться как для глобальных так и локальных переменных. Если даны globals и locals, они используются для глобальных и локальных переменных соответственно. Если задан, locals может быть любым объектом-отображением (mapping object). Помните, что на уровне модуля, глобальные и локальные - один и тот же словарь. Если exec получает два отдельных объекта как globals и locals, код будет выполняться, как будто они были встроены в определение класса.

Если словарь globals не содержит значение для ключа __builtins__, ссылка на словарь из встроенного модуля builtins (docs.python.org/3/library/builtins.html#module-builtins) вставляется под этим ключом. Таким образом вы можете контролировать то, что встроенные функции доступны для исполняемого кода, вставив свой ​​собственный словарь __builtins__ в globals, прежде чем передать его exec().

Примечание: Встроенные функцие globals() и locals() возвращают текущие глобальный и локальный словари соответственно, которые могут быть полезны для раздачи использования в качестве второго и третьего аргумента exec().

Примечание: По умолчанию locals действует, как описано для функции locals() ниже: изменения в словаре по умолчанию locals не должно быть предпринято. Передается явный словарь locals, если вам нужно увидеть эффекты кода на locals после возврата из функции exec().

filter(function, iterable)

Строит итератор из тех элементов iterable, для которых function возвращает true. iterable может быть либо последовательностью, контейнером, который поддерживает итерацию, либо итератором. Если function есть None, предполагается идентичная функция, то есть все элементы iterable, которые являются false, удаляются.

Обратите внимание, что filter(function, iterable) есть эквивалент выражению-генератору (item for item in iterable if function(item)), если функция не None и (item for item in iterable if item), если функция является None.

См. itertools.filterfalse() (docs.python.org/3/library/itertools.html#itertools.filterfalse) для дополнительной функции, которая возвращает элементы iterable, для которых function возвращает false.

class float([x])

Возвращает число с плавающей точкой, созданное из числа или строки x.

Если аргумент является строкой, он должен содержать десятичное число с необязательным предшествующим знаком, и необязательным вставленным в эту строку пробелом. Необязательный знак может быть '+' или '-'; знак '+' не оказывает никакого эффекта на получаемое значение. Аргумент может также быть строкой, представляющей NaN (not-a-number), или положительной или отрицательной бесконечностью. Более точно, ввод должен соответствовать следующей грамматике после того, как начальные и конечные пробельные символы будут удалены:

sign           ::=  "+" | "-"
infinity       ::=  "Infinity" | "inf"
nan            ::=  "nan"
numeric_value  ::=  floatnumber | infinity | nan
numeric_string ::=  [sign] numeric_value
Здесь floatnumber является формой литерала с плавающей точкой в Python, описанный в Floating point literals (docs.python.org/3/reference/lexical_analysis.html#floating). Регистр не имеет значения, так, например, “inf”, “Inf”, “INFINITY” и “iNfINity” - все приемлемые варианты написания для положительной бесконечности.

В ином случае, если аргумент является целым числом или числом с плавающей точкой, возвращается число с плавающей точкой с тем же значением (в пределах точности числа с плавающей точкой в Python). Если аргумент находится вне диапазона float в Python, будет возбуждено OverflowError (docs.python.org/3/library/exceptions.html#OverflowError).

Для общего объекта Python x float(x) представляется в x.__float__().

Если аргумент не задан, то возвращается 0.0.

Примеры:

>>> float('+1.23')
1.23
>>> float('   -12345\n')
-12345.0
>>> float('1e-003')
0.001
>>> float('+1E6')
1000000.0
>>> float('-Infinity')
-inf
Тип float описан в Числовые типы — int, float, complex.

Изменено в версии 3.6: позволена группировка цифр с помощью нижнего подчеркивания как в кодовых литералах.

format(value[, format_spec])

Преобразует value к "отформатированному" представлению, как контролируется format_spec. Интерпретация format_spec будет зависеть от типа аргумента value, однако есть стандартный синтаксис форматирования, который используется большинством встроенных типов: Format Specification Mini-Language (docs.python.org/3/library/string.html#formatspec).

По умолчанию format_spec - это пустая строка, которая обычно дает тот же эффект, что и вызов str(value) (docs.python.org/3/library/stdtypes.html#str).

Вызов format(value, format_spec) переводится в type(value).__format__(format_spec), который обходит словарь экземпляра при поиске значения метода __format__() (docs.python.org/3/reference/datamodel.html#object.__format__). Возникает исключение TypeError (docs.python.org/3/library/exceptions.html#TypeError), если поиск метода достигает object и format_spec не пустой, или если либо format_spec, либо возвращаемое значение не являются строками.

Изменено в версии 3.4: object().__format__(format_spec) возбуждает TypeError, если format_spec не пустая строка.

class frozenset([iterable])

Возвращает новый объект frozenset, опционально с элементами, взятыми из iterable. frozenset является встроенным классом. Смотрите frozenset и Типы множеств — set, frozenset для обзора документации по этому классу.

Для других контейнеров смотрите встроенные классы set, list, tuple и dict, а также модуль collections (docs.python.org/3/library/collections.html#module-collections).

getattr(object, name[, default])

Возвращает значение атрибута object с указанным именем. name должен быть строкой. Если строка является именем одного из атрибутов объекта, результатом является значение этого атрибута. Например, getattr(x, 'foobar') эквивалентна x.foobar. Если названный атрибут не существует, то возвращается то, что задано по умолчанию, если предусмотрено, в противном случае возбуждается AttributeError (docs.python.org/3/library/exceptions.html#AttributeError).

globals()

Возвращает словарь, представляющий текущую глобальную таблицу обозначений. Это всегда словарь текущего модуля (внутри функции или метода, это модуль, где она определена, не модуль, из которого она вызывается).

hasattr(object, name)

Аргументами являются объект и строка. Результат истина, если строка является именем одного из атрибутов объекта, ложь, если нет. (Это реализуется путем вызова getattr(object, name) и обзора, возбуждает ли он AttributeError или нет.)

hash(object)

Возвращает хэш-значение объекта (если он есть). Хэш-значения являются целыми числами. Они используются для быстрого сравнения ключей словаря во время просмотра словаря. Числовые значения, которые сравнивают, равны, если имеют одинаковое значение хеш (даже если они имеют разные типы, как это имеет место для 1 и 1,0).

Примечание. Для объекта с пользовательскими методами __hash__(), обратите внимание, что hash() обрезает возвращаемое значение на основе битовой ширины хост-машины. Смотрите __hash__()  (docs.python.org/3/reference/datamodel.html#object.__hash__) для получения подробной информации.

help([object])

Вызывает встроенную справочную систему. (Эта функция предназначена для интерактивного использования.) Если аргумент не задан, интерактивная справочная система запускает консольную справку. Если аргумент является строкой, то строка рассматривается как имя модуля, функции, класса, метода, ключевое слово или тема документации, и справочной страница выводится в консоли. Если аргумент является любой другой вид объекта, генерируется страница помощи по объекту.

Эта функция добавлена к встроенному пространству имен модуля site (docs.python.org/3/library/site.html#module-site).

Изменено в версии 3.4: Изменения в pydoc (docs.python.org/3/library/pydoc.html#module-pydoc) и inspect (docs.python.org/3/library/inspect.html#module-inspect) означают, что сообщаемые подписи для вызываемых объектов в настоящее время более полный и последовательный.

hex(x)

Преобразует целое число в строчное шестнадцатеричное представление с префиксом “0x”, например:

>>> hex(255)
'0xff'
>>> hex(-42)
'-0x2a'
Если x не является объектом int Python, у него должен быть определен метод __index__(), возвращающий целое.

Смотрите также int() для преобразования шестнадцатеричной строки в целое, используя основание 16.

Примечание. Для получения строки шестнадцатеричного представления вещественного числа используйте метод float.hex().

id(object)

Возвращает "индивидуальность" объекта. Это целое число, которое гарантированно будет уникальным и постоянным для этого объекта во время его жизни. Два объекта с неперекрывающимся временем жизни могут иметь одинаковые значения id().

Детали реализации CPython: Это адрес объекта в памяти.

input([prompt])

Если аргумент prompt присутствует, он пишется в стандартный вывод без последующего символа новой строки. Затем функция считывает строку из ввода, преобразует ее в строковый тип данных (удаляя символ конца строки) и возвращает результат. Когда считывается EOF, возбуждается EOFError (docs.python.org/3/library/exceptions.html#EOFError). Пример:

>>> s = input('--> ')  
--> Monty Python's Flying Circus
>>> s  
"Monty Python's Flying Circus"
Если был загружен модуль readline (docs.python.org/3/library/readline.html#module-readline), то input() будет использовать его для предоставления сложного редактирования строки и возможностей истории.

class int(x=0)
class int(x, base=10)

Возвращает целочисленный объект, созданный из числа или строки x, или возвращает 0, если аргументы не заданы. Если x является числом, возвращает x.__int__() (docs.python.org/3/reference/datamodel.html#object.__int__). У вещественных чисел удаляется дробная часть.

Если x не число или если задано base, то x должен быть строкой, байтами, или экземпляром bytearray, представляющим литерал целого числа (docs.python.org/3/reference/lexical_analysis.html#integers) по основанию base. Литералу может предшествовать + или - (без пробела между ними) и окруженный пробелами. Литерал по основанию n состоит из цифр от 0 до n-1, включая от a до z (или от A до Z), имеющих значения от 10 до 35. По умолчанию base равно 10. Допустимые значения 0 и 2-36. Основания -2, -8, и -16 могут иметь необязательные префиксы 0b/0B, 0o/0O или 0x/0X, как с целочисленными литералами в коде. Основание 0 означает точно интерпретировать как кодовый литерал, так что фактическое основание 2, 8, 10 или 16, и так что int('010', 0) не является правильным, в то время как int('010') верно, а также int('010', 8).

Целочисленный тип описан в Числовые типы — int, float, complex.

Изменено в версии 3.4: Если base не является экземпляром int и объект base имеет метод base.__index__ (docs.python.org/3/reference/datamodel.html#object.__index__), то этот метод вызывается для получения целого для base. В предыдущих версиях использовали base.__int__ (docs.python.org/3/reference/datamodel.html#object.__int__) вместо base.__index__.

Изменения в версии 3.6: Как в кодовых литералах позволено группировать цифры с помощью символов нижнего подчеркивания.

isinstance(object, classinfo)

Возвращает правду, если аргумент object является экземпляром аргумента classinfo, или (прямым, косвенным или виртуальным (docs.python.org/3/glossary.html#term-abstract-base-class)) подклассом от него. Если object не является объектом данного типа, функция всегда возвращает ложь. Если classinfo не является классом (тип объекта), это может быть кортеж объектов типа, или может рекурсивно содержать другие такие кортежи (другие типы последовательностей не принимаются). Если classinfo не является типом или кортежем типов и подобных кортежей, возбуждается исключение TypeError (docs.python.org/3/library/exceptions.html#TypeError).

issubclass(class, classinfo)

Возвращает правду, если class является подклассом (прямым, косвенным или виртуальным) от classinfo. Класс считается подклассом самого себя. classinfo может быть кортеж из объектов классов, и в этом случае каждая запись в classinfo будут проверена. В любом другом случае, возбуждается исключение TypeError.

iter(object[, sentinel])

Возвращает объект iterator (docs.python.org/3/glossary.html#term-iterator). Первый аргумент интерпретируется по-разному в зависимости от наличия второго аргумента. Без второго аргумента, object должен быть объектом-коллекцией, которая поддерживает протокол итераций (метод __iter__()), или он должен поддерживать протокол последовательности (метод __getitem__() с целыми аргументами, начиная с 0). Если он не поддерживает любой из этих протоколов, возбуждается TypeError. Если второй аргумент, sentinel, передается, то object должен быть вызываемым объектом. В этом случае созданный итератор будем вызывать object без аргументов для каждого вызова его метода __next__(); если возвращенное значение равно sentinel, будет возбуждено StopIteration, иначе будет возвращено значение.

Смотри также Типы итераторов.

Один из вариантов применения второй формы iter() является чтение строк файла, пока не будет достигнута определенная линия. Следующий пример считывает до тех пор, пока метод readline() не возвращает пустую строку:

with open('mydata.txt') as fp:
    for line in iter(fp.readline, ''):
        process_line(line)
len(s)

Возвращает длину (число элементов) объекта. Аргумент может быть последовательностью (например, строка, байты, кортеж, список или диапазон) или коллекцией (например, словарь, множество или frozen множество).

class list([iterable])

Вместо того, чтобы быть функцией, list на самом деле является изменяемым типом последовательности, как описано в Lists и Типы последовательностей — list, tuple, range.

locals()

Обновляет и возвращает словарь, представляющий текущую локальную таблицу имен. Свободные переменные возвращаются locals(), когда она вызывается в блоках функций, но не в блоках классов.

Примечание: Содержимое этого словаря не должны быть изменено; изменения не могут повлиять на значения локальных и свободных переменных, используемых интерпретатором.

map(function, iterable, ...)

Возвращает итератор, который применяет function к каждому элементу из iterable, принося результаты. Если передаются дополнительные аргументы iterable, function должна принять все множество аргументов и применится к элементам из всех параллельно. С несколькими итерируемыми итератор останавливается, когда самая короткая итерация исчерпана. Для случаев, когда входы функции уже расположены в аргументе кортежей см itertools.starmap() (docs.python.org/3/library/itertools.html#itertools.starmap).

max(iterable, *[, key, default])
max(arg1, arg2, *args[, key])

Возвращает самый большой элемент в iterable или самый большой из двух или более аргументов.

Если предоставляется один позиционный аргумент, он должен быть iterable (docs.python.org/3/glossary.html#term-iterable). Возвращается наибольший элемент из итерации. Если передаются два или более позиционных аргументов, возвращается самый большой из них.

Есть два необязательных keyword-only (именованных - прим. пер.) аргумента. Аргумент key определяет одно-аргументную упорядочивающую функцию такую же, как используемую для list.sort(). Аргумент default определяет возвращаемый объект, если предоставленная итерация пуста. Если итерация пуста и default не предоставлен, возбуждается ValueError (docs.python.org/3/library/exceptions.html#ValueError).

Если множество элементов являются максимальными, функция возвращает первый, который попадается. Это совпадает с другими сохраняющими сортировку инструментами как sorted(iterable, key=keyfunc, reverse=True)[0] и heapq.nlargest(1, iterable, key=keyfunc).

Новое в версии 3.4: default keyword-only аргумент.

memoryview(obj)

Возвращает объект “memory view”, созданный из данного аргумента. Для детальной информации см. Memory Views.

min(iterable, *[, key, default])
min(arg1, arg2, *args[, key])

Возвращает наименьший элемент в iterable или наименьший из двух или более аргументов.

Если предоставлен один позиционный аргумент, он должен быть iterable (docs.python.org/3/glossary.html#term-iterable). Если предоставляются два и более позиционных аргумента, возвращается наименьший позиционный аргумент.

Существует два необязательных keyword-only аргумента. Аргумент key определяет одно-аргументную порядковую функцию такую же, как используемую для list.sort(). Аргумент default определяет возвращаемый объект, если предоставленная итерация пуста. Если итерация пуста и default не предоставлен, возбуждается ValueError (docs.python.org/3/library/exceptions.html#ValueError).

Если не один элемент является минимальными, функция возвращает первый, который попадается. Это совпадает с другими сохраняющими сортировку инструментами как sorted(iterable, key=keyfunc)[0] и heapq.nsmallest(1, iterable, key=keyfunc).

Новое в версии 3.4: default keyword-only аргумент.

next(iterator[, default])

Извлекает следующий элемент из iterator, путем вызова его методом __next__(). Если дан default, то он возвращается, если итератор исчерпан, иначе возбуждается StopIteration (docs.python.org/3/library/exceptions.html#StopIteration).

class object

Возвращает новый безликий объект. object является основой для всех классов. У него есть методы, которые общие для всех экземпляров классов Python. Эта функция не принимает никакие аргументы.

Примечание: у object нет __dict__, таким образом вы не можете назначать произвольные атрибуты экземплярам класса object.

oct(x)

Обращает целое десятичное число в восьмеричное число в виде строки. Результатом является валидное выражение Python. Если x не является объектом int, он должен определить метод __index__() (docs.python.org/3/reference/datamodel.html#object.__index__), который возвращает целое десятичное число.

open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)

Открывает file и возвращает соответствующий file object (docs.python.org/3/glossary.html#term-file-object). Если файл не может быть открыт, то возбуждается OSError (docs.python.org/3/library/exceptions.html#OSError).

file - это path-like object (docs.python.org/3/glossary.html#term-path-like-object), задающий путь-имя (абсолютное или относительное к текущей рабочей директории) файла, который открыт, или числовой файловый дескриптор файла, который был обернут. (Если дан файловый дескриптор, он закрывается, когда возвращаемый объект I/O закрыт, до тех пор пока closefd не установлен в False.

mode является необязательной строкой, которая определяет режим, в котором файл открывается. По умолчанию это 'r', что обозначает открытие для чтения в текстовом режиме. Другое распространенное значение - это 'w' для записи (стирает содержимое файла, если он уже существует), 'x' для исключительного создания и 'a' для добавления (что на некоторых Unix-системах означает, что все записи добавляются в конец файла, несмотря на текущую позицию seek). В текстовом режиме если параметр encoding не указан, то использование кодирования зависит от платформы: вызывается locale.getpreferredencoding(False), чтобы получить текущую локальную кодировку. (Для чтения и написания необработанные байты используют бинарный режим или оставляют кодировку неопределенной.) Доступными режимами являются:

Символ	Значение
'r'	открывает для чтения (по умолчанию)
'w'	открывает для записи, сначала усекая файл
'x'	открывает исключительно для создания, терпит неудачу, если файл уже существует
'a'	открывает для записи, если файл уже существует, то для добавления в его конец
'b'	бинарный режим
't'	текстовый режим (по умолчанию)
'+'	открывает дисковый файл для обновления (чтения или записи)
'U'	режим universal newlines (docs.python.org/3/glossary.html#term-universal-newlines) (устаревший)
Режимом по умолчанию является 'r' (открывает для чтения текст, синоним 'rt'). Для доступа к бинарному чтению-записи режим 'w+b' открывает и усекает файл до 0 байтов. 'r+b' открывает файл без усечения.

Как уже упоминалось в Overview (docs.python.org/3/library/io.html#io-overview), Python делает различия между бинарным и текстовым вводом-выводом. Файлы, открытые в бинарном режиме (включающие 'b' в аргументе mode) возвращают содержимое как объекты bytes (docs.python.org/3/library/stdtypes.html#bytes) без какого-либо декодирования. В текстовом режиме (по умолчанию или когда 't' включено в аргумент mode) содержимое файла возвращается как str (docs.python.org/3/library/stdtypes.html#str), байты сначала декодируются, используя платформенно-зависимую кодировку или используя указанную кодировку, если она задана.

Замечание: Python не зависит от идеи текстовых файлов, лежащей в основе операционной системы; вся обработка выполняется Python'ом самостоятельно и является поэтому платформенно-независимой.

buffering есть необязательное целое число, которое используется для установки политики буферизации. Передайте 0 для выключения буферизации (позволено только в бинарном режиме), 1 для выбора строки буферизации и целое число > 1 для указания размера в байтах порции буфера фиксированного размера. Когда нет заданного аргумента buffering, по умолчанию политика буферизации работает следующим образом:

Бинарные файлы буферизуются частями фиксированного размера; размер буфера выбирается, используя эвристическую попытку определить лежащий в основе "размер блока" устройства и отступание на io.DEFAULT_BUFFER_SIZE (docs.python.org/3/library/io.html#io.DEFAULT_BUFFER_SIZE). Во многих системах буфер обычно будет 4096 или 8192 байтов длиной.
"Интерактивные" текстовые файлы (файлы, для которых isatty() (docs.python.org/3/library/io.html#io.IOBase.isatty) возвращает True) используют строчную буферизацию. Другие текстовые файлы используют политику, описанную выше для бинарных файлов.
encoding есть название кодирования, используемого для декодирования или кодирования файла. Его следует использовать только в текстовом режиме. По умолчанию кодирование платформенно-зависимо (что бы ни вернул locale.getpreferredencoding() (docs.python.org/3/library/locale.html#locale.getpreferredencoding)), но любой
text encoding (docs.python.org/3/glossary.html#term-text-encoding), поддерживаемый Python, может быть использован. Смотрите модуль codecs (docs.python.org/3/library/codecs.html#module-codecs) для списка поддерживаемых кодировок.

errors - это необязательная строка, которая определяет, как ошибки кодирования и декодирования должны быть обработаны, она не может быть использовано в бинарном режиме. Разнообразие обработчиков стандартных ошибок доступно (перечислены в Error Handlers (docs.python.org/3/library/codecs.html#error-handlers)), хотя любое имя обрабатываемой ошибки, которая была зарегистрирована с codecs.register_error() (docs.python.org/3/library/codecs.html#codecs.register_error) также действительна. Стандартные имена включают:

'strict' возбуждает исключение ValueError (docs.python.org/3/library/exceptions.html#ValueError), если есть ошибка кодирования. По умолчанию значение None имеет тот же эффект.
'ignore' игнорирует ошибки. Заметьте, что игнорирование ошибок кодирования может привести к потере данных.
'replace' вызывает замену маркера (таких как '?'), который будет вставлен, где есть бесформенные данные.
'surrogateescape' будет представлять любые некорректные байты как указатели кода в Unicode Private Use Area, находящиеся в диапазоне от U+DC80 до U+DCFF. Эти частные указатели кода будут затем переведены назад в те же байты, когда обработчик ошибок 'surrogateescape' используется, когда данные записываются. Это полезно при обработки файлов в неизвестной кодировке.
'xmlcharrefreplace' поддерживается только при записи в файл. Неподдерживаемые кодировкой символы заменяются ссылкой соответствующего символа XML &#nnn;.
'backslashreplace' заменяет бесформенные данные backslashed escape последовательностями Python.
'namereplace' (также поддерживается только при записи) заменяет неподдерживаемые символы на \N{...} escape-последовательности.
newline контролирует, как работает режим universal newlines (docs.python.org/3/glossary.html#term-universal-newlines) (это применяется только к текстовому режиму). Это может быть None, '', '\n', '\r' и '\r\n'. Это работает следующим образом:

При чтении ввода из потока, если newline есть None, режим universal newlines включен. Строки во вводе могут заканчиваться '\n', '\r' или '\r\n', и это переводится в '\n' перед возвратом к вызывающему. Если это есть '', режим universal newlines включен, но концы строк возвращаются к вызывающему непереведенными. Если у него любое другое допустимое значение, вводимые строки прерываются только заданной строкой, и концы строк возвращаются к вызывающему непереведенными.
При записи вывода в поток, если newline есть None, любые записываемые символы '\n' переводятся в системный по умолчанию разделитель строк, os.linesep (docs.python.org/3/library/os.html#os.linesep). Если newline есть '' или '\n', перевод не происходит. Если newline есть любое другое допустимое значение, любые записываемые символы '\n' переводятся в заданную строку.
Если closefd есть False и файловый дескриптор предпочтительней, чем заданное имя файла, лежащий в основе файловый дескриптор будет оставаться открытым, когда файл закрывается. Если имя файла дано, closefd должен быть True (по умолчанию), иначе будет возбуждена ошибка.

Пользовательский открыватель можно использовать, передавая вызываемый как opener. Лежащий в основе файловый дескриптор для файлового объекта есть затем полученный с вызывающим opener (file, flags). opener должен возвращать открытый файловый дескриптор (передающий os.open (docs.python.org/3/library/os.html#os.open) как результаты opener в функциональности похожей на передающийся None).

Вновь созданный файл является non-inheritable (docs.python.org/3/library/os.html#fd-inheritance).

Следующий пример использует параметр dir_fd (docs.python.org/3/library/os.html#dir-fd) функции os.open() (docs.python.org/3/library/os.html#os.open) для открытия файлового отношения к заданной директории.

>>> import os
>>> dir_fd = os.open('somedir', os.O_RDONLY)
>>> def opener(path, flags):
...     return os.open(path, flags, dir_fd=dir_fd)
...
>>> with open('spamspam.txt', 'w', opener=opener) as f:
...     print('This will be written to somedir/spamspam.txt', file=f)
...
>>> os.close(dir_fd)  # файловый дескриптор не просачивается
Тип file object (docs.python.org/3/glossary.html#term-file-object), возвращаемый функцией open(), зависит от режима. Когда open() используется для открытия файла в текстовом режиме ('w', 'r', 'wt', 'rt', т. д.), возвращается подкласс io.TextIOBase (а именно io.TextIOWrapper). Когда используется для открытия файл в бинарном режиме с буферизацией, возвращаемый класс есть подкласс io.BufferedIOBase. Точный класс изменяется: в режиме бинарного чтения возвращает io.BufferedReader; в режимах бинарной записи и добавления возвращает io.BufferedWriter, и в режиме чтения/записи возвращает io.BufferedRandom. Когда буферизация отключена, данные текут, подкласс io.RawIOBase, io.FileIO возвращается.

Смотри также модули обработчиков файла, такие как fileinput, io (где open() объявлена), os, os.path, tempfile и shutil.

Изменено в версии 3.3:

Был добавлен параметр opener.
Был добавлен режим 'x'.
Раньше возбуждалось IOError, это теперь псевдоним OSError.
Теперь возбуждается FileExistsError, если открываемый файл в режиме эксклюзивного создания ('x') уже существует.
Изменено в версии 3.4:

Файл теперь ненаследственный.
Устаревший, начиная с версии 3.4, будет удален в версии 4.0: Режим 'U'.

Изменено в версии 3.5:

Если системный вызов прерывается и обработчик сигнала не возбуждает исключения, функция теперь повторяет системный вызов вместо возбуждения исключения InterruptedError (см. PEP 475 для обоснования).
Был добавлен обработчик ошибки 'namereplace'.
Изменено в версии 3.6:

Добавлена поддержка для принятия объектов, реализующих os.PathLike (docs.python.org/3/library/os.html#os.PathLike).
В Windows открытие консольного буфера может вернуть подкласс io.RawIOBase, отличный от io.FileIO.
ord(c)

Дается строка, представляющая один символ Unicode, возвращается целое число, представляющее код Unicode того символа. Например, ord('a') возвращает целое число 97, а ord('€') (знак евро) возвращает 8364. Эта функция обратна chr().

pow(x, y[, z])

Возвращает x в степени y; если z присутствует, возвращает x в степени y, по модулю z (вычисление более эффективно, чем pow(x, y) % z). Двухаргументная форма pow(x, y) - это эквивалент использования оператора степени: x**y.

Аргументы должны иметь числовые типы. Со смешанными типами операндов применяются правила принуждение для бинарных арифметических операторов. Для операндов int результат имеет такой же тип, как операнды (после принуждения), если второй аргумент не является отрицательным; в этом случае все аргументы конвертируются в float, и результат float предоставляется. Например, 10**2 возвращает 100, но 10**-2 возвращает 0.01. Если второй аргумент отрицательный, третий аргумент должен быть опущен. Если z представлен, x и y должны быть целочисленными типами, и y должен быть неотрицательным.

print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)

Выводит объекты в текстовый поток file, разделяются sep и завершаются end. sep, end и file если представлены, должны быть даны как аргументы ключевого слова.

Все аргументы, которые не являются ключевыми словами, конвертируются в строки, также как это делает str(), и записываются в поток, разделяясь set и оканчиваясь end. Оба set и end должны быть строками; они также могут быть None, который обозначает использовать значения по умолчанию. Если нет переданных объектов, print() просто выведет end.

Аргумент file должен быть объектом с методом write(string); если он не представлен или является None, sys.stdout будет использоваться. Так как печатные аргументы преобразуются в текстовые строки, print() не может быть использован файловыми объектами в бинарном режиме. Вместо этого для них используется file.write(...).

Будет ли вывод буферизирован - это обычно определяется file, но если аргуемент flush есть истина, поток принудительно размывается.

Изменено в версии 3.3: Добавлен аргумент-ключевое слово flush.

class property(fget=None, fset=None, fdel=None, doc=None)

Возвращает свойство атрибута.

fget - это функция для получения значения атрибута. fset - функция для установления значения атрибута. fdel - это функция для удаления значения атрибута. И doc создает строку документации для атрибута.

Обычно используется для определения управляемого атрибута х:

class C:
    def __init__(self):
        self._x = None
 
    def getx(self):
        return self._x
 
    def setx(self, value):
        self._x = value
 
    def delx(self):
        del self._x
 
    x = property(getx, setx, delx, "I'm the 'x' property.")
Если c экземпляр C, c.x будет вызывать getter, c.x = value будет вызывать setter и del c.x - deleter.

Если задано, doc будет строкой документации свойства атрибута. Иначе свойство скопирует строку документации fget (если она существует). Это делает возможным легко создать свойства только для чтения, используя property() как decorator (docs.python.org/3/glossary.html#term-decorator).

class Parrot:
    def __init__(self):
        self._voltage = 100000
 
    @property
    def voltage(self):
        """Get the current voltage."""
        return self._voltage
Декоратор @property превращает метод voltage() в "getter" для атрибута только для чтения с таким же именем, и это устанавливает строку документации для voltage в “Get the current voltage.”

Свойство объекта имеет методы getter, setter и deleter, используемые как декораторы, которые создают копию свойства с соответствующей функцией метода доступа, которая устанавливает декорируемую функцию. Это лучше объясняется на примере:

class C:
    def __init__(self):
        self._x = None
 
    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x
 
    @x.setter
    def x(self, value):
        self._x = value
 
    @x.deleter
    def x(self):
        del self._x
Этот код точный эквивалент первого примера. Будет верно дать дополнительным функциям то же имя как оригинальное свойство (x в этом случае).

Возвращенное свойство объекта также имеет атрибуты fget, fset и fdel, соответствующие аргументам конструктора.

Изменено в версии 3.5: Строки документации свойств объекта теперь записываемые.

range(stop)
range(start, stop[, step])

range (docs.python.org/3/library/stdtypes.html#range) скорее не функция, а на самом деле тип неизменяемой последовательности, как документировано в Диапазоны и Типы последовательностей — list, tuple, range.

repr(object)

Возвращает строку, содержащую печатную версию объекта. Для многих типов эта функция делает попытку вернуть строку, которая бы дала объект с таким же значением, когда передается eval() (docs.python.org/3/library/functions.html#eval), иначе представление - это строка, заключенная в угловые скобки, которые содержат имя типа объекта вместе с дополнительной информацией, часто включающей имя и адрес объекта. Класс может контролировать, что эта функция возвращает для ее экземпляров, путем определения метода __repr__() (docs.python.org/3/reference/datamodel.html#object.__repr__).

reversed(seq)

Возвращает перевернутый iterator (docs.python.org/3/glossary.html#term-iterator). seq должен быть объектом, у которого есть метод __reversed__(), или поддерживать протокол последовательности (методы __len__() и __getitem__() с целочисленным аргументом, начинающимся с 0).

round(number[, ndigits])

Возвращает number, округленное до ndigits цифр после десятичной точки. Если ndigits опущен или None, то возвращает ближайшее целое к его вводу.

Для встроенных типов, поддерживающих round(), значения округляются к ближайшему кратному 10 в степени минус ndigits; если кратные одинаково близки, округление производится в сторону выравнивающего выбора (так, например, оба round(0.5) и round(-0.5) есть 0, а round(1.5) есть 2). Любое целое значение допустимо для ndigits (положительное, ноль или отрицательное). Возвращаемое значение есть целое, если вызывается с одним аргументом, иначе такого же типа как number.

Для общего Python-объекта number, round(number, ndigits) делегирует к number.__round__(ndigits).

Примечание: Поведение round() для вещественных чисел может быть неожиданным: например, round(2.675, 2) дает 2.67 вместо ожидаемого 2.68. Это не баг: это результат факта, что самые большие десятичные дроби не могут быть представлены точно как вещественные числа. Смотрите Арифметика чисел с плавающей точкой: проблемы и ограничения для дополнительной информации.

class set([iterable])

Возвращает новый объект set, опционально с элементами, взятыми из itarable. set - это встроенный класс. Смотрите set и Типы множеств — set, frozenset для информации об этом классе.

Для других контейнеров смотрите встроенные классы frozenset, list, tuple и dict, а также модуль collections (docs.python.org/3/library/collections.html#module-collections).

setattr(object, name, value)

Это эквивалент getattr(). Аргументы являются объектом, строкой и произвольным значением. Строка может иметь название существующего атрибута или нового атрибута. Функция присваивает значение атрибуту, при условии, что объект это позволяет. Например, setattr(x, 'foobar', 123) эквивалентно x.foobar = 123.

class slice(stop)
class slice(start, stop[, step])

Возвращает объект slice (docs.python.org/3/glossary.html#term-slice), представленный множеством индексов, определенных range(start, stop, step). Аргументы start и step по умолчанию None.
У объектов среза (slice) есть только для чтения данные атрибутов start, stop и step, которые просто возвращают значения аргументов (или их по-умолчанию). Они не имеют никакой другой явной функциональности; однако они используются Numerical Python и другими сторонними расширениями. Объекты срезов также генерируются, когда используется расширенный синтаксис индексирования. Например: a[start:stop:step] или a[start:stop, i]. Смотрите itertools.islice() (docs.python.org/3/library/itertools.html#itertools.islice) для альтернативной версии, которая возвращает итератор.

sorted(iterable, *, key=None, reverse=False)

Возвращает новый отсортированный список из элементов в iterable.

Имеет два необязательных аргумента, которые должны быть быть определены как аргументы c ключевым словом.

key определяет функцию одного аргумента, которая используется для извлечения ключа сравнения из каждого элемента списка: key=str.lower. По умолчанию значение None (непосредственное сравнение элементов).

reverse есть булево значение. Если установлено в True, значит элементы списка сортируются, как если каждое сравнение было от обратного.

Используйте functools.cmp_to_key() (docs.python.org/3/library/functools.html#functools.cmp_to_key) для преобразования функции cmp старого стиля в функцию key.

Встроенная функция sorted() гарантировано будет стабильной. Сортировка стабильна, если на гарантирует не изменение относительного порядка элементов, которые считаются равными - это полезно для сортировки в несколько проходов (например, сортировка по отделам, затем по заработной плате).

Примеры сортировки и краткий учебник по сортировке смотри в Sorting HowTo (docs.python.org/3/howto/sorting.html#sortinghowto).

staticmethod(function)

Возвращает статический метод для function.

Статический метод не получает неявный первый аргумент. Чтобы объявить статический метод, используйте эту идиому:

class C:
    @staticmethod
    def f(arg1, arg2, ...): ...
Форма @staticmethod - это функция decorator (docs.python.org/3/glossary.html#term-decorator) - смотри описание определений функций в Function definitions (docs.python.org/3/reference/compound_stmts.html#function) для подробностей.

Она может быть вызвана либо на класс (как C.f()), либо на экземпляр (как C().f()). Экземпляр игнорируется за исключением для его класса.

Статические методы в Python похожи на те, что в Java или C++. Также смотрите classmethod() как вариант, который является полезным для создания альтернативных конструкторов класса.

Для получения более подробной информации о статических методах, обращайтесь к документации по иерархии стандартных типов в The standard type hierarchy (docs.python.org/3/reference/datamodel.html#types).

class str(object='')
class str(object=b'', encoding='utf-8', errors='strict')

Возвращает str версию object. Смотри str() для деталей.

str - это встроенный строковый class (docs.python.org/3/glossary.html#term-class). Для получения общей информации о строках смотрите Тип текстовой последовательности — str.

sum(iterable[, start])

Суммирует от start и элементы iterable слева направо и возвращает сумму. По умолчанию start равен 0. Элементы iterable обычно числа, и значению start не позволено быть строкой.

В некоторых случаях есть хорошая альтернатива для sum(). Предпочтительный, быстрый способ объединить последовательность строк - это вызов ''.join(sequence). Чтобы добавить значения с плавающей точкой с расширенной точностью, смотри math.fsum() (docs.python.org/3/library/math.html#math.fsum). Для объединения ряда итераций рассмотрите использование itertools.chain() (docs.python.org/3/library/itertools.html#itertools.chain).

super([type[, object-or-type]])

Возвращает объект прокси, который делегирует метод, вызывающий родительский или сестринский класс для type. Это полезно для доступа к унаследованным методам, которые были переопределены в классе. Порядок поиска такой же как при использовании getattr() за исключением того, что сам type пропускается.

Атрибут __mro__ type перечисляет разрешения метода порядка поиска, используя оба: getattr() и super(). Атрибут является динамическим и может измениться, когда обновляется иерархия наследования.

Если второй аргумент опущен, объект супер возвращается несвязанным. Если второй аргумент является объектом, isinstance(obj, type) должен быть правдой. Если второй аргумент является типом, issubclass(type2, type) должен быть правдой (это полезно для класс-методов).

Есть два типичных варианта использования для super. В иерархии классов с одиночным наследованием super можно использовать для обращения к родительским классам, не называя их явно, что делает код более сопровождаемым. Такое использование близко тому, которое используется для super в других языках программирования.

Второй вариант использования - поддержка совместного множественного наследования в динамичной среде выполнения. Этот вариант использования уникален для Python и отсутствует в статически компилируемых языках или языках, которые поддерживают только одиночное наследование. Это дает возможность реализовывать "ромбические диаграммы", где несколько базовых классов реализуют один и тот же метод. Хорошая разработка диктует, что этот метод имеет одну и ту же сигнатуру вызова в каждом случае (потому что порядок вызовов определяется во время выполнения, потому что тот порядок адаптируется к изменениям в иерархии классов, и потому что тот порядок может включать сестринские классы, которые неизвестны до времени выполнения).

Для обоих случаев использования, вызов типичного суперкласса выглядит так:

class C(B):
    def method(self, arg):
        super().method(arg)    # Делает тоже самое как:
                               # super(C, self).method(arg)
Заметьте, что super() реализуется как часть процесса связывания для явного точечного атрибута поиска как super().__getitem__(name). Это делается так путем реализации его собственного метода __getattribut__() для поиска классов в предсказуемом порядке, который поддерживает совместное множественное наследование. Соответственно, super() не определен для неявных поисков с использованием выражений или операторов, таких как super()[name].

Также заметьте, что помимо формы нулевого аргумента, super() не ограничивается для использования внутри методов. Двух-аргументная форма определяет аргументы точно и делает соответствующие ссылки. Форма нулевого аргумента работает только внутри определения класса, как компилятор заполняет необходимые детали для правильного извлечения определяемого класса, также как доступность текущего экземпляра для обычных методов.

Для практических предложений, как разрабатывать совместные классы, использующие super(), смотри guide to using super() (rhettinger.wordpress.com/2011/05/26/super-considered-super/)

tuple([iterable])

Скорее чем быть функцией, tuple в действительности тип неизменяемой последовательности, как описано в Кортежи и Типы последовательностей — list, tuple, range.

class type(object)
class type(name, bases, dict)

С одним аргументом возвращает тип object. Возвращаемое значение является типом объекта и как правило тем же объектом как возвращаемый от object.__class__.

Для проверки типа объекта рекомендуется встроенная функция isinstance(), т. к. они принимает во внимание подклассы.

С тремя аргументами возвращает новый объект типа. Это по-сути динамическая форма оператора class (docs.python.org/3/reference/compound_stmts.html#class). Строка name является именем класса и становится атрибутом __name__; кортеж bases перечисляет базовые классы и становится атрибутом __bases__; словарь dict является пространством имен, содержащим определения для тела класса, и становится атрибутом __dict__. Например, следующие два выражения создают объекты идентичного типа:

>>> class X:
...     a = 1
...
>>> X = type('X', (object,), dict(a=1))
Смотри также Объекты типов.

Изменено в версии 3.6: Подклассы type, которые не переопределяют type.__new__, могут больше не использовать одноаргументную форму, чтобы получить тип объекта

vars([object])

Возвращает атрибут __dict__ для модуля, класса, экземпляра или любого другого объекта с атрибутом __dict__.

Такие объекты как модули и экземпляры имеют обновляемый атрибут __dict__; однако другие объекты могут иметь ограничения на запись для их атрибута __dict__ (например, классы используют types.MappingProxyType (docs.python.org/3/library/types.html#types.MappingProxyType) для предотвращения обновлений словаря).

Без аргумента vars() действует как locals(). Заметьте, словарь locals полезен только для чтения, т. к. обновления словаря locals игнорируются.

zip(*iterables)

Создает итератор, который агрегирует элементы от каждого из iterables.

Возвращает итератор кортежей, где i-й кортеж содержит i-й элемент каждого из аргументов последовательностей или iterables. Итератор останавливается, когда самая короткая итерация исчерпывается. Если в качестве аргумента только одна итерация, то возвращает итератор одноэлементных кортежей. Без аргументов возвращает пустой итератор. Эквивалентно следующему:

def zip(*iterables):
    # zip('ABCD', 'xy') --> Ax By
    sentinel = object()
    iterators = [iter(it) for it in iterables]
    while iterators:
        result = []
        for it in iterators:
            elem = next(it, sentinel)
            if elem is sentinel:
                return
            result.append(elem)
        yield tuple(result)
Порядок оценки слева на право для iterables гарантируется. Это делает возможной идиому для кластеризации серий данных в группы n-длины с помощью zip(*[iter(s)]*n).

zip() следует использовать только с входящими неравной длины, если вам не важны концы, неучтенные значения из более длинных iterables. Если эти значения важны, используйте вместо этого itertools.zip_longest() (docs.python.org/3/library/itertools.html#itertools.zip_longest).

zip() в соединении с оператором * может быть использован для распаковки списка:

>>> x = [1, 2, 3]
>>> y = [4, 5, 6]
>>> zipped = zip(x, y)
>>> list(zipped)
[(1, 4), (2, 5), (3, 6)]
>>> x2, y2 = zip(*zip(x, y))
>>> x == list(x2) and y == list(y2)
True
__import__(name, globals=None, locals=None, fromlist=(), level=0)

Замечание: Это продвинутая функция, которая не нужна в повседневном программировании на Python, в отличие от importlib.import_module() (docs.python.org/3/library/importlib.html#importlib.import_module).

Эта функция вызывается оператором import (docs.python.org/3/reference/simple_stmts.html#import). Это может быть заменено (путем импорта модуля builtings (docs.python.org/3/library/builtins.html#module-builtins) и назначения builtins.__import__) для изменения семантики оператора import, но делать так настоятельно не рекомендуется, поскольку это, как правило, проще при использовании импортируемых hooks (см. PEP 302 (www.python.org/dev/peps/pep-0302)) для достижения тех же целей, и это не вызывает проблем с кодом, который предполагает реализацию импорта по умолчанию в использовании. Прямое использование __import__() также не приветствуется в пользу importlib.import_module().

Функция импортирует модуль name, потенциально используя заданные globals и locals для определения, как интерпретировать имя в контексте пакета. fromlist задает имена объектов или подмодулей, которые должны быть импортированы из модуля, заданного как name. Стандартная реализация не использует ее аргумент locals вообще, и использует ее globals только для определения пакета контекста оператора import.

level определяет использовать ли абсолютный или относительный импорт. 0 (по умолчанию) обозначает выполнение только абсолютных импортов. Положительное значение для level указывает количество родительских каталогов для поиска по отношению к директории модуля вызываемого __import__() (для подробностей см. PEP 328 (python.org/dev/peps/pep-0328)).

Когда переменная name является видом package.module, обычно возвращается верхнеуровневый пакет (имя до первой точки), не модуль с именем name. Однако, когда задан не пустой аргумент fromlist, возвращается модуль названный как name.

Например, выражение import spam дает результат в байткоде, напоминающем следующий код:

spam = __import__('spam', globals(), locals(), [], 0)
Выражение import spam.ham дает результат этого вызова:

spam = __import__('spam.ham', globals(), locals(), [], 0)
Обратите внимание, как здесь __import__() возвращает модуль верхнего уровня, потому что это объект, который связан с именем оператора import.

С другой стороны, выражение от spam.ham import eggs, sausage as saus дает подобный результат:

_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)
eggs = _temp.eggs
saus = _temp.sausage
Здесь от __import__() возвращается модуль spam.ham. Из этого объекта имена в импорте извлекаются и присваиваются их соответствующим именам.

Если вы просто хотите импортировать модуль (возможно в пакете) по имени, используйте importlib.import_module() (docs.python.org/3/library/importlib.html#importlib.import_module).

Изменено в версии 3.3: Отрицательные значения для level больше не поддерживаются (они изменяются на значение по умолчанию 0).

Примечания

[1] Обратите внимание, что парсер принимает только конец Unix-стиля конвенции строки. Если вы читаете код из файла, убедитесь, что используете режим преобразования новой строки для преобразования Windows, или Mac-стиля новой строки.

3. Встроенные константы
Лишь небольшое число констант обитает в строенном пространстве имен. Это:

False

Значение "ложь" типа bool. Недопустимо присваивание к False, что возбуждает SyntaxError (docs.python.org/3/library/exceptions.html#SyntaxError).

True

Значение "истина" типа bool. Присвоение к True невозможно и вызывает SyntaxError.

None

Единственное значение типа NoneType. None часто используется для представления отсутствия значения, как когда аргументы по-умолчанию не передаются в функцию. Присвоение к None невозможно и вызывает SyntaxError.

NotImplemented

Специальное значение, которое должно быть возвращено специальными бинарными методами (например, __eq__(), __lt__(), __add__(), __rsub__() и т. д.), чтобы показать, что операция не реализована в отношении другого типа; может быть возвращено внутренними специальными бинарными методами (например, __imul__(), __iand__() и др.) для той же цели. Ее истинное значение есть true.

Замечание: Когда двоичный (или внутренний) метод возвращает NotImplemented, интерпретатор будет пытаться отразить операцию на другом типе (или каком-то другом запасном решении, зависящем от оператора). Если все попытки возвращают NotImplemented, интерпретатор возбудит соответствующее исключение. Неверно возвращенное NotImplemented будет результатом в сообщении о вводящей в заблуждение ошибки или значение NotImplemented возвращается в код Python.
См. примеры в Implementing the arithmetic operations (docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations).

Замечание: NotImplementedError и NotImplemented не взаимозаменяемы, даже если у них похожие имена и цели. См. NotImplementedError для детальной информации об его использовании.

Ellipsis

То же самое, что .... Специальное значение используется в основном с расширенным синтаксисом срезов для определенных пользователем контейнерных типов данных.

__debug__

Эта константа есть true, если Python не был запущен с опцией -0 (docs.python.org/3/using/cmdline.html#cmdoption-O). См. также оператор assert (docs.python.org/3/reference/simple_stmts.html#assert).

Замечание: Имена None, False, True и __debug__ не могут быть переназначены (назначение им, даже в качестве имен атрибутов, возбуждает SyntaxError), так они могут считаться константами "true".

3.1. Константы, добавленные модулем site
Модуль site (docs.python.org/3/library/site.html#module-site) (который автоматически импортируется во время запуска за исключением случаев, когда передается опция командной строки -S) добавляет несколько констант во встроенное пространство имен. Они полезны для оболочки интерактивного интерпретатора и их не следует использовать в программах.

quit(code=None)
exit(code=None)

Объекты, которые при выводе печатают сообщение подобное "Use quit() or Ctrl-D (i.e. EOF) to exit" ("Используйте quit() или Ctrl-D (т. е. EOF - конец файла) для выхода" - прим. пер.) и, когда вызываются, вызывают SystemExit с указанным кодом выхода.

copyright
license
credits

Объекты , которые, когда выводятся, печатают сообщение подобное "Type license() to see the full license text" ("Введите license(), чтобы увидеть полный текст лицензии" - прим. пер.) и, когда вызываются, отображают соответствующий текст в манере пейджера (один экран за раз).

4. Встроенные типы
4.1. Проверка истинности
4.2. Булевы операции - and, or, not
4.3. Сравнения
4.4. Числовые типы - int, float, complex
4.5. Типы итераторов
4.6. Типы последовательностей - list, tuple, range
4.7. Тип текстовой последовательности - str
4.8. Типы двоичных последовательностей - bytes, bytearray, memoryview
4.9. Типы множеств - set, frozenset
4.10. Типы отображений - dict
4.11. Типы контекстного менеджера
4.12. Другие встроенные типы
4.13. Специальные атрибуты
Следующие разделы описывают стандартные типы, которые встроены в интерпретатор.

Основными встроенными типами являются числовые, последовательности, отображения, классы, экземпляры и исключения.

Некоторые классы коллекций изменяемые. Методы, которые добавляют, вычитают или переставляют их члены на месте и не возвращают конкретный элемент, сами никогда не возвращают экземпляр коллекции, но возвращают None.

Некоторые операции поддерживаются несколькими типами объектов; в частности, практически все объекты могут сравниваться, проверены на значение true и конвертированы в строку (с помощью функции repr() или слегка отличной от нее str()). Последняя функция неявно используется, когда объект выводится функцией print().

4.1. Проверка истинности
Любой объект может быть проверен на значение истинны, для использования в условиях if или while или как операнд булевых операций ниже.

По-умолчанию, объект считается true до тех пор, пока его класс не определяет, что метод __bool__() возвращает False или метод __len__() возвращает ноль, когда вызывается с объектом. [1] Здесь большинство встроенных объектов, рассматриваемых как ложь:

константы, определенные быть ложью: None и False.
ноль любого числового типа: 0, 0.0, 0j, Decimal(0), Fraction(0,1)
пустые последовательности и коллекции: '', (), [], {}, set(), range(0)
Операции и встроенные функции с результатом булевого типа всегда возвращают 0 или False для лжи и 1 или True для правды, если не указано иное. (Важное исключение: булевы операции or или and всегда возвращают один из их операндов.)

4.2. Булевы операции - and, or, not
Здесь булевы операции, упорядоченные по восходящему приоритету:

Операция	Результат	Замечание
x or y	если x ложь, то y, иначе x	(1)
x and y	если x ложь, то x, иначе y	(2)
not x	если x ложь, то True, иначе False	(3)
Замечания:

Это оператор "короткого замыкания", так что он оценивает второй аргумент, если первый является ложью.
Это также оператор "короткого замыкания", который оценивает второй аргумент, если первый является правдой.
У not приоритет ниже, чем у небулевских операторов, так что not a == b интерпретируется как not (a == b), и a == not b является синтаксической ошибкой.
4.3. Сравнения
В Python существует восемь операций сравнения. Они имеют одинаковый приоритет (который выше, чем у булевских операций). Сравнения могут произвольно соединяться; например, x < y <= z есть эквивалент для x < y and y <= z, за исключением того, что y оценивается только однажды (но в обоих случаях z не оценивается вообще, когда было обнаружено, что x < y есть ложь).

Эта таблица резюмирует операции сравнения:

Операция	Значение
<	строго меньше чем
<=	меньше чем или равно
>	строго больше чем
>=	больше чем или равно
==	равно
!=	не равно
is	идентичность объектов
is not	отрицание идентичности объектов
Объекты разных типов, кроме различных числовых типов, никогда не равны при сравнении. Кроме того, некоторые (например, функции-объекты) поддерживают только вырожденные нотации сравнения, когда два любых объекта этого типа не равны. Операторы <, <=, > и >= возбудят исключение TypeError при сравнении комплексных чисел с другими встроенными числовыми типами, когда объекты являются различными типами, которые не могут быть сравнены или, в других случаях, где нет определенного упорядочивания.

Неидентичные экземпляры класса обычно сравниваются как неравные, если только класс не определяет метод __eq__() (docs.python.org/3/reference/datamodel.html#object.__eq__).

Экземпляры класса не могут быть упорядочены по отношению к другим экземплярам того же класса или других типов объектов, но до тех пор, пока класс не определяет достаточно методов __lt__(), __le__(), __gt__() и __ge__() (в большинстве случаев достаточно __lt__() и __eq__(), если вам требуется обычное значение операторов сравнения).

Поведение операторов is и is not не может быть настроено; также они могут быть применены к двум любым объектам и никогда не возбуждают исключение.

Еще две операции с одинаковым синтаксическим приоритетом, in и not in, поддерживаются только типами последовательностей (ниже).

4.4. Числовые типы - int, float, complex
Есть три различных числовых типа: integers, floating point number и complex number (целые числа, числа с плавающей точкой и комплексные числа - прим. пер.). В дополнение, логический тип данных является подтипом целых чисел. Целые числа имеют неограниченную точность. Числа с плавающей точкой обычно реализованы с помощью double в C; информация о точности и внутреннем представлении дробных чисел для машины, на которой ваша программа запускается, доступна в sys.float_info (docs.python.org/3/library/sys.html#sys.float_info). У комплексных чисел есть реальная и мнимая части, каждая из которых является вещественным числом. Чтобы извлечь эти части из комплексного числа z, используйте z.real и z.imag. (Стандартная библиотека включает дополнительные числовые типы, fractions (docs.python.org/3/library/fractions.html#module-fractions), которая хранит рациональные числа, и decimal (docs.python.org/3/library/decimal.html#module-decimal), которая хранит числа с плавающей точкой с точностью определенной пользователем.)

Числа создаются числовыми литералами или как результат встроенных функций и операторов. Просто целочисленные литералы (включая шестнадцатеричные, восьмеричные и двоичные числа) производят целое число. Числовые литералы, включающие десятичную точку или знак экспоненты, производят число с плавающей точкой. Добавление 'j' или 'J' к числовому литералу производит мнимое число (комплексное число с нулевой реальной частью), которые вы можете сложить с целым числом или дробным и получите комплексное число с реальной и мнимыми частями.

Python полностью поддерживает смешанную арифметику: когда бинарный арифметический оператор имеет операнды различных числовых типов, операнд с более "узким" типом расширяется до уровня другого, где целые числа уже, чем дробные, которые уже, чем комплексные. При сравнении чисел разных типов используется то же правило. [2] Конструкторы int(), float() и complex() могут быть использованы для создания чисел конкретных типов.

Все числовые типы (за исключением комплексных) поддерживают следующие операции, отсортированные по восходящему приоритету (все числовые операции имеют более высокий приоритет, чем операции сравнения):

Операция	Результат	Замечание	Полная документация
x + y	сумма x и y	 	 
x - y	разность x и y	 	 
x * y	произведение x и y	 	 
x / y	частное x и y	 	 
x // y	целочисленное деление	(1)	 
x % y	остаток от x / y	(2)	 
-x	отрицание x	 	 
+x	x остается без изменений	 	 
abs(x)	абсолютное значение или величина x	 	abs()
int(x)	x конвертируется в целое число	(3)(6)	int()
float(x)	x конвертируется в дробное число	(4)(6)	float()
complex(re, im)	комплексное число с реальной частью re, мнимой частью im. im по-умолчанию 0.	(6)	complex()
c.conjugate()	сопряжение комплексного числа c	 	 
divmod(x, y)	пара (x // y, x % y)	(2)	divmod()
pow(x, y)	x в степени y	(5)	pow()
x ** y	x в степени y	(5)	 
Замечания:

Получающееся в результате значение есть целое число, хотя тип результата не обязательно int. Результат всегда округляется в сторону минус бесконечности: 1//2 есть 0, (-1)//2 есть -1, 1//(-2) есть -1, и (-1)//(-2) есть 0.
Не для комплексных чисел. Вместо этого конвертируйте в float, используя abs(), если это необходимо.
Преобразование из дробного к целому может быть через округление или усечение как в C; см. функции math.floor() (docs.python.org/3/library/math.html#math.floor) и math.ceil() (docs.python.org/3/library/math.html#math.ceil) для точно определенной конверсии.
float также принимает строки "nan" и "inf" опциональным префиксом "+" или "-" для Not a Number (NaN) и положительной и отрицательной бесконечности.
Python определяет, что pow(0, 0) и 0 ** 0 должно быть 1, как обычно для языков программирования.
Принимаемые числовые литералы включают числа от 0 до 9 или любой эквивалент Unicode (кодовые указатели со свойством Nd).
См. полный список кодовых указателей со свойством Nd на unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt
Все типы numbers.Real (docs.python.org/3/library/numbers.html#numbers.Real) (int и float) также включают следующие операции:

Операция	Результат
math.trunc(x)	x усекается до Integral
round(x[, n])	x округляется до n цифр, округление до половины. Если n опущено, то по-умолчанию до 0.
math.floor(x)	наибольший Integral <= x
math.ceil(x)	наименьший Integral >= x
О дополнительных числовых операциях см. модули math (docs.python.org/3/library/math.html#module-math) и cmath (docs.python.org/3/library/cmath.html#module-cmath).

4.4.1. Побитовые операции с целыми типами
Побитовые, или поразрядные, операции имеют смысл только для целых чисел. Отрицательные числа рассматриваются как их 2 дополнительное значение (при этом предполагается, что имеется достаточное количество бит, таким образом во время операции не происходит переполнения).

У всех бинарных побитовых операций приоритеты ниже, чем числовые операции, и выше, чем у сравнений; унарная операция ~ имеет такой же приоритет, как другие унарные числовые операции (+ и -).

Это список побитовых операций, отсортированный по возрастанию приоритета:

Операция	Результат	Замечание
x | y	побитовое или для x и y	 
x ^ y	побитовое исключающее или для x и y	 
x & y	побитовое и для x и y	 
x << n	x сдвигается влево на n бит	(1)(2)
x >> n	x сдвигается вправо на n бит	(1)(3)
~x	биты x инвертируются	 
Замечания:

Отрицательный сдвиг (-n) не допускается и является причиной возбуждения ValueError.
Сдвиг влево на n бит эквивалентно умножению на pow(2, n) без проверки переполнения.
Сдвиг вправо на n бит эквивалентно делению на pow(2, n) без проверки переполнения.
4.4.2. Дополнительные методы для целых типов
Тип int реализует numbers.Integral (docs.python.org/3/library/numbers.html#numbers.Integral) abstract base class (docs.python.org/3/glossary.html#term-abstract-base-class). В дополнение он предоставляет еще несколько методов:

int.bit_length()

Возвращает количество бит, необходимых для представления целого в двоичном виде, исключая знак и лидирующий ноль:

>>> n = -37
>>> bin(n)
'-0b100101'
>>> n.bit_length()
6
Более точно, если x не ноль, то x.bit_length() - это уникальное положительное число k, такое что 2**(k-1) <= abs(x) < 2**k. Равносильно, когда abs(x) достаточно мала, чтобы иметь корректно округленный логарифм, то k = 1 + int(log(abs(x), 2)). Если x - ноль, то x.bit_length() возвращает 0.

Эквивалентно следующему:

def bit_length(self):
    s = bin(self)       # двоичное представление:  bin(-37) --> '-0b100101'
    s = s.lstrip('-0b') # удаление впереди стоящих нуля и знака минус
    return len(s)       # len('100101') --> 6
Новое в версии 3.1.

int.to_bytes(length, byteorder, *, signed=False)

Возвращает массив байтов, представляющих целое.

>>> (1024).to_bytes(2, byteorder='big')
b'\x04\x00'
>>> (1024).to_bytes(10, byteorder='big')
b'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'
>>> (-1024).to_bytes(10, byteorder='big', signed=True)
b'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'
>>> x = 1000
>>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little')
b'\xe8\x03'
Целое представляется, используя length (длину) байтов. Возбуждается OverflowError, если целое не представимо в заданном числе байтов.

Аргумент byteorder определяет порядок байтов, используемый для представления целого. Если byteorder есть "big", самый старший байт находится в начале массива байтов. Если byteorder есть "little", самый старший байт находится в конце массива байтов. Чтобы запросить собственный порядок байтов данной системы, используйте sys.byteorder (docs.python.org/3/library/sys.html#sys.byteorder) в качестве значения порядка байтов.

Аргумент signed определяет, используется ли дополнение до двух для представления целого. Если signed есть False и задано отрицательное число, возбуждается OverflowError. Значение по-умолчанию для signed есть False.

Новое в версии 3.2.

classmethod int.from_bytes(bytes, byteorder, *, signed=False)

Возвращает целое, представленное заданным массивом байтов.

>>> int.from_bytes(b'\x00\x10', byteorder='big')
16
>>> int.from_bytes(b'\x00\x10', byteorder='little')
4096
>>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=True)
-1024
>>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=False)
64512
>>> int.from_bytes([255, 0, 0], byteorder='big')
16711680
Аргумент bytes должен быть либо bytes-like object (docs.python.org/3/glossary.html#term-bytes-like-object), либо производящей байты итерацией.

Аргумент byteorder определяет порядок байтов, используемых для представления целого. Если byteorder есть "big", самый старший значащий байт есть начало массива байтов. Если byteorder есть "little", самый старший байт есть конец массива байтов. Чтобы запросить собственный порядок байтов данной системы, используйте sys.byteorder (docs.python.org/3/library/sys.html#sys.byteorder) в качестве значения порядка байтов.

Аргумент signed указывает, используется ли дополнение до двух для представления целого.

Новое в версии 3.2.

4.4.3. Дополнительные методы для вещественных чисел
Вещественный (float) тип реализует number.Real (docs.python.org/3/library/numbers.html#numbers.Real) abstract base class (docs.python.org/3/glossary.html#term-abstract-base-class). Тип float также включает следующие дополнительные методы.

float.as_integer_ratio()

Возвращает пару целых чисел, чье соотношение точно равно исходному вещественному и с положительным знаменателем. Возбуждает OverflowError для бесконечностей и ValueError для NaN'ов.

float.is_integer()

Возвращает True, если экземпляр float является ограниченным целым значением, и False, если наоборот:

>>> (-2.0).is_integer()
True
>>> (3.2).is_integer()
False
Оба метода поддерживают преобразование в и из шестнадцатеричных строк. Пока вещественные числа в Python сохраняются внутри как двоичные числа, преобразование float в или из десятичной строки обычно предполагает небольшую ошибку округления. В противоположность этому, шестнадцатеричные строки позволяют точно представить и указать дробные числа. Это может быть полезно при отладке и работе с числами.

float.hex()

Возвращает представление дробного числа в виде шестнадцатеричной строки. Для ограниченны дробных чисел это представление будет всегда включать лидирующие 0x и завершающий p и показатель степени (экспоненты).

classmethod float.fromhex(s)

Классовый метод для возврата float, представленного шестнадцатеричной строкой s. Строка s может включать лидирующие и завершающие пробелы.

Заметьте, что float.hex() является методом-экземпляром, а float.fromhex() - методом-классом.

Шестнадцатеричные строки принимают такие формы:

[sign] ['0x'] integer ['.' fraction] ['p' exponent]
где необязательный sign может быть либо +, либо -, integer и fraction являются строками шестнадцатеричных цифр, и exponent - десятичное целое с опциональным лидирующим знаком. Этот синтаксис похож на синтаксис указанный в секции 6.4.4.2 стандарта C99, и также на синтаксис, используемый в Java, начиная с 1.5. В частности, вывод float.hex() как шестнадцатеричный вещественный литерал в коде C или Java, и шестнадцатеричные строки, производимые форматом символа %a языка C или Double.toHexString языка Java, принимаются float.fromhex().

Заметьте, что экспонента записывается в десятичной системе счисления скорее, чем в шестнадцатеричной, и что это дает степень 2, по которой умножается коэффициент. Например, шестнадцатеричная строку 0x3.a7p10 представляет дробное число (3 + 10./16 + 7./16**2) * 2.0**10, или 3740.0:

>>> float.fromhex('0x3.a7p10')
3740.0
Применение к 3740.0 обратного превращения дает другую шестнадцатеричную строку, представляющую это же число:

>>> float.hex(3740.0)
'0x1.d380000000000p+11'
4.4.4. Хэширование числовых типов
Для чисел x и y, возможно разных типов, существует требование, чтобы hash(x) == hash(y) всякий раз, когда x == y (для выяснения деталей см. документацию по методу __hash__() (docs.python.org/3/reference/datamodel.html#object.__hash__)). Для простоты реализации и эффективности во множестве числовых типов (включая int, float, decimal.Decimal и fractions.Fraction) у Python hash для числовых типов базируется на единственной математической функции, которая определена для любого рационального числа, и таким образом применяется ко всем экземплярам int и fractions.Fraction, также ко всем конечным экземплярам float и decimal.Decimal. Фактически, эта функция дается сокращением по модулю P для фиксированного простого P. Значение P делается доступным для Python как атрибут modulus из sys.hash_info.

Детали реализации CPython: В настоящее время используемое простое есть P = 2**31 - 1 на машинах с 32-битным C longs и P = 2**61 - 1 на машинах с 64-битным C longs.

Здесь правила в деталях:

Если x = m / n есть неотрицательно рациональное число и n не делится на P, определяет hash(x) как m * invmod(n, P) % P, где invmod(n, P) дает обратное n по модулю P.
Если x = m / n есть неотрицательно рациональное число и n делится на P (но m - нет), то n не имеет обратного по модулю P и правило выше не применяется; в этом случае определяет hash(x) быть константным значением sys.hash_info.inf.
Если x = m / n есть отрицательное рациональное число, определяет hash(x) как -hash(-x). Если получившийся в результате hash есть -1, заменяет его на -2.
Конкретное значение sys.hash_info.inf, -sys.hash_info.info и sys.hash_info.nan используются как hash-значения для положительной бесконечности или nan'ов (соответственно). (Все хэшируемые nan'ы имеют одинаковое hash-значение.)
Для комплексного числа z, хэш-значения реальной и мнимой частей комбинируется вычислением hash(z.real) + sys.hash_info.imag * hash(z.imag), сокращенное по модулю 2**sys.hash_info.width так, что оно лежит в range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Опять же, если результат -1, то заменяется на -2.
Чтобы прояснить правила выше, вот несколько примеров кода Python, эквивалентных встроенному хэшу, для вычисления хэша рациональных чисел, float или complex:

import sys, math

def hash_fraction(m, n):
    """Вычисляет hash рационального числа m / n.

    Предполагает, что m и n - целые числа, с положительным n.
    Эквивалентно hash(fractions.Fraction(m, n)).

    """
    P = sys.hash_info.modulus
    # Удаляет общие множители P.  (Нет необходимости, если m и n уже взаимно просты.)
    while m % P == n % P == 0:
        m, n = m // P, n // P

    if n % P == 0:
        hash_value = sys.hash_info.inf
    else:
        # Маленькая теорема Ферма: pow(n, P-1, P) есть 1, так что
        # pow(n, P-2, P) дает обратно n по модулю P.
        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P
    if m < 0:
        hash_value = -hash_value
    if hash_value == -1:
        hash_value = -2
    return hash_value

def hash_float(x):
    """Вычисляет hash вещественного x."""

    if math.isnan(x):
        return sys.hash_info.nan
    elif math.isinf(x):
        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf
    else:
        return hash_fraction(*x.as_integer_ratio())

def hash_complex(z):
    """Вычисляет hash комплексного числа z."""

    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)
    # делает предписанное сокращение по модулю 2**sys.hash_info.width
    M = 2**(sys.hash_info.width - 1)
    hash_value = (hash_value & (M - 1)) - (hash_value & M)
    if hash_value == -1:
        hash_value = -2
    return hash_value
4.5. Типы итераторов
Python поддерживает концепцию итераций над контейнерами. Это реализовано с помощью двух определенных методов; они используются, чтобы пользовательские классы поддерживали итерацию. Последовательности, описанные ниже более детально, всегда поддерживают итерационные методы.

Для контейнерных объектов необходимо определить один метод для обеспечения поддержки итерации:

container.__iter__()

Возвращает объект-итератор. Объект требуется для поддержки протокола итератора, описанного ниже. Если контейнер поддерживает различные типы итерации, могут быть предоставлены дополнительные методы, чтобы специально запросить итераторы для этих типов итераций. (Примером объекта, поддерживающего множественные формы итераций, могла бы быть структура дерева, которая поддерживает как "первый в ширину", так и "первый в глубину" обход.) Этот метод соответствует слоту структурного типа для объектов Python tp_iter (docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_iter) в API Python/C.

Итераторные объекты сами по себе требуются для поддержки следующих двух методов, которые вместе формируют протокол итератора:

iterator.__iter__()

Возвращает сам объект итератора. Это требуется, чтобы позволить как контейнерам, так и итераторам быть использованными операторами for и in. Этот метод соответствует слоту структурного типа для объектов Python tp_iter в API Python/C.

iterator.__next__()

Возвращает следующий элемент из контейнера. Если дальнейших элементов нет, возбуждает исключение StopIteration (docs.python.org/3/library/exceptions.html#StopIteration). Этот метод соответствует слоту структурного типа для объектов Python tp_iternext (docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_iternext) в API Python/C.

Python определяет несколько объектов-итераторов для поддержки итерации над обычными и специфическими типами последовательностей, словарей и над другими более специализированными формами. Конкретным типам не важна находящаяся по ту сторону реализация протокола итератора.

Однажды возбудив StopIteration, метод итерации __next__() должен продолжать делать так в последующие вызовы. Реализации, которые не подчиняются этому свойству, считаются нарушенными.

4.5.1. Типы генераторов
Генераторы Python предоставляют удобный способ реализовать протокол итератора. Если метод __iter__() контейнерного объекта реализован как генератор, он автоматически вернет объект итератора (технически, объект генератора), который поддерживает методы __iter__() и __next()__. Дополнительная информация о генераторах может быть найдена в the documentation for the yield expression (docs.python.org/3/reference/expressions.html#yieldexpr).

4.6. Типы последовательностей - list, tuple, range
Есть три основных типа последовательностей: списки, кортежи и объекты диапазонов. Дополнительные типы последовательностей разрабатываются для обработки двоичных данных и текстовых строк, описанных в предназначенных разделах.

4.6.1. Общие операции последовательностей
Операции в следующей таблице поддерживаются большинством типов последовательностей, как изменяемых, так и неизменяемых. collections.abc.Sequence (docs.python.org/3/library/collections.abc.html#collections.abc.Sequence) ABC предоставляется для упрощения корректной реализации этих операций над пользовательскими типами последовательностей.

Эта таблица перечисляет операции последовательностей, отсортированные по восходящему приоритету. В таблице s и t есть последовательности одинакового типа, n, i, j и k - целые и x - произвольный объект, который соответствует любому типу и значению, на которое наложено ограничение s.

Операции in и not in имеют те же приоритеты, что и операции сравнения. Операции + (конкатенация) и * (повторение) имеют тот же приоритет, что и соответствующие числовые операции. [3]

Операция	Результат	Замечание
x in s	True, если какой-либо элемент s равен x, иначе False	(1)
x not in s	False, если какой-либо элемент s равен x, иначе True	(1)
s + t	объединение s и t	(6)(7)
s * n или n * s	эквивалентно добавлению s к самому себе n раз	(2)(7)
s[i]	i-ный элемент s, начало 0	(3)
s[i:j]	срез из s от i до j	(3)(4)
s[i:j:k]	срез из s от i до j с шагом k	(3)(5)
len(s)	длина s	 
min(s)	наименьший элемент из s	 
max(s)	наибольший элемент из s	 
s.index(x[, i[, j]])	индекс первого вхождения x в s (или после индекса i и перед индексом j)	(8)
s.count(x)	общее количество вхождений x в s	 
Последовательности одинакового типа также поддерживают сравнение. В частности, кортежи и списки сравнимы лексикографически путем сравнения соответствующих элементов. Это означает что, чтобы сравнение дало равенство, все элементы должны быть попарно равны, и две последовательности должны быть одного и того же типа и одинаковой длины. (Для более полной детализации см. Comparisons (docs.python.org/3/reference/expressions.html#comparisons) в справке по языку).

Замечания:

В то время как операции in или not in используются только для простой проверки на вхождение в общем случае, некоторые специализированные последовательности (такие как str, bytes и bytearray) также используют их для проверки подпоследовательности:
>>> "gg" in "eggs"
True
Значения n меньшие, чем 0, обращаются в 0 (который производит пустую последовательность того же типа, что и s). Заметьте, что элементы в последовательности s не копируются; на них ссылаются множество раз. Это часто озадачивает новых программистов Python; рассмотрите:
>>> lists = [[]] * 3
>>> lists
[[], [], []]
>>> lists[0].append(3)
>>> lists
[[3], [3], [3]]
Так получилось, потому что [[]] - одноэлементный список, включающий пустой список, так что все три элемента от [[]] * 3 ссылаются на этот единственный пустой список. Изменение любого элемента в lists изменяет этот единственный список. Вы можете создать список различных списков таким способом:
>>> lists = [[] for i in range(3)]
>>> lists[0].append(3)
>>> lists[1].append(5)
>>> lists[2].append(7)
>>> lists
[[3], [5], [7]]
Дальнейшее объяснение доступно в записи FAQ "Как мне создать многомерный список?" (docs.python.org/3/faq/programming.html#faq-multidimensional-list).
Если i и j отрицательны, то индекс относится к концу последовательности s: len(s) + i или len(s) + j заменены. Но заметьте, что -0 остается 0.
Срез из s от i до j определяется как последовательность элементов с индексом k таким, что i <= k < j. Если i или j больше, чем len(s), используется len(s). Если i опущено или None, используется 0. Если j опущен или None, используется len(s). Если i больше или равно j, срез пустой.
Срез из s от i до j с шагом k определен как последовательность элементов с индексом x = i + n*k таким, что 0 <= n < (j-i)/k. Другими словами, индексами являются i, i+k, i+2*k, i+3*k и т. д., остановленные при достижении j (но никогда не включающие j). При положительном k, i и j сокращаются до len(s), если они больше. При отрицательном k, i и j сокращаются к len(s) - 1, если они больше. Если i или j опущены или None, они становятся значениями "end" (конец которого зависит от знака k). Заметьте, k не может быть нулем. Если k есть None, то рассматривается как 1.
Конкатенация неизменяемых последовательностей всегда возвращает новый объект. Это означает, что наращивание последовательности путем повторяемой конкатенации будет стоить квадрату времени выполнения в общей длине последовательности. Чтобы получить линейную стоимость времени выполнения, вы должны переключиться на одну из альтернатив ниже:
если соединяются объекты str, вы можете построить список и использовать str.join() в конце или еще записать в экземпляр io.StringIO и вернуть его объект при завершении
если соединяются объекты bytes, вы можете также использовать bytes.join() или io.BytesIO, или вы можете сделать in-place конкатенацию с объектом bytearray. Объекты bytearray изменяемы и имеют эффективный механизм превышения
если конкатенируются объекты tuple, вместо них расширьте до list
для других типов изучите соответствующую документацию классов
Некоторые типы последовательностей (такие как range) поддерживают только последовательности элементов, которые следуют конкретным шаблонам и, следовательно, не поддерживают конкатенацию и повторение последовательностей.
index возбуждает ValueError, когда x не найден в s. Когда поддерживается, то дополнительные аргументы метода index позволяют эффективно искать подпоследовательности в последовательности. Передача дополнительных аргументов приблизительно эквивалентно использованию s[i:j].index(x), только без копирования каких-либо данных и с возвращаемым индексом, который скорее относится к началу последовательности, чем к началу среза.
4.6.2. Неизменяемые типы последовательностей
Единственная операция, которую обычно реализуют неизменяемые типы последовательностей, которая также не реализована изменяемыми типами последовательностей, - это поддержка встроенного hash().

Эта поддержка позволяет неизменяемым последовательностям, таким как экземпляры tuple, быть использованными в качестве ключей dict и сохраненными в экземплярах set или frozenset.

Попытка хешировать неизменяемую последовательность, которая содержит нехэшируемые значения даст в результате TypeError (https://docs.python.org/3/library/exceptions.html#TypeError).

4.6.3. Изменяемые типы последовательностей
Операции в следующей таблицы определены для изменяемых типов последовательностей. collections.abc.MutableSequence (docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence) ABC предоставляется для упрощения корректной реализации этих операций над пользовательскими типами последовательностей.

В таблице s - экземпляр изменяемого типа последовательности, t - итерируемый объект и x - произвольный объект, который соответствует любому типу и значению, ограниченному s (например, bytearray принимает только целые числа, которые соответствуют ограничению значения 0 <= x <= 255).

Операции	Результат	Замечания
s[i] = x	элемент i из s заменяется на x	 
s[i:j] = t	срез из s от i до j заменяется содержимым итерации t	 
del s[i:j]	то же самое, что s[i:j] = []	 
s[i:j:k] = t	элементы из s[i:j:k] заменяются теми же из t	(1)
del s[i:j:k]	удаляет элементы s[i:j:k] из списка	 
s.append(x)	добавляет x в конец последовательности (то же самое, что s[len(s):len(s)] = [x])	 
s.clear()	удаляет все элементы из s (то же, что del s[:])	(5)
s.copy()	создает поверхностную копию s (так же как s[:])	(5)
s.extend(t) или s += t	расширяет s содержимым t (в большинстве случаев то же самое, что s[len(s):len(s)] = t)	 
s *= n	обновляет s его содержимым, повторенным n раз	(6)
s.insert(i, x)	вставляет x в s по индексу, заданному i (то же что s[i:i] = [x])	 
s.pop([i])	возвращает элемент i, а также удаляет его из s	(2)
s.remove(x)	удаляет первый элемент из s, где s[i] == x	(3)
s.reverse()	реверс элементов s на месте	(4)
Замечания:

t должен иметь ту же длину, что и срез, который он заменяет.
Опциональный аргумент i по-умолчанию устанавливается в -1, так что по-умолчанию удаляется и возвращается последний элемент.
remove возбуждает ValueError (docs.python.org/3/library/exceptions.html#ValueError), если x не найден в s.
Метод reverse() изменяет последовательность на месте для экономии пространства, когда переворачивает большие последовательности. Чтобы напомнить пользователям, что он действует по побочному эффекту, он не возвращает перевернутую последовательность.
clear() и copy() включены для связности с интерфейсами изменяемых контейнеров, которые не поддерживают операции взятия среза (такими как dict и set).
Новое в версии 3.3: методы clear() и copy().
Значение n есть целое или объект, реализующий __index__() (docs.python.org/3/reference/datamodel.html#object.__index__). Ноль и отрицательное значение n очищают последовательность. Элементы в последовательности не копируются; на них ссылаются множество раз, как объяснено для s * n в Общих операциях последовательностей.
4.6.4. Списки
Списки являются изменяемыми последовательностями, обычно используемыми для хранения однородных элементов (где точная степень подобия будет варьировать в зависимости от приложения).

class list([iterable])

Списки могут быть сконструированы несколькими способами:

Используя пару квадратных скобок для обозначения пустого списка: []
Используя квадратные скобки, разделяя элементы запятыми: [a], [a, b, c]
Используя списковый охват: [x for x in iterable]
Используя конструктор типа: list() или list(iterable)
Конструктор строит список, чьи элементы такие же и в таком же порядке, как элементы итерации. iterable может быть либо последовательностью, контейнером, который поддерживает итерацию, либо итераторным объектом. Если iterable уже список, делается и возвращается копия, похоже на iterable[:]. Например, list('abc') возвращает ['a', 'b', 'c'], а list( (1, 2, 3) ) возвращает [1, 2, 3]. Если заданных аргументов нет, конструктор создает новый пустой список, [].

Многие другие операции также производят списки, включая встроенную sorted() (docs.python.org/3/library/functions.html#sorted).

Списки реализуют все операции: общие и для изменяемых последовательностей.

sort(*, key=None, reverse=False)

Этот метод сортирует список на месте, используя только сравнения < между элементами. Исключения не подавляются - если какие-нибудь операции сравнения терпят неудачу, вся операция сортировки будет неудачной (и список вероятно будет оставлен в частично измененном состоянии).

sort() принимает только два аргумента, которые могут быть переданы только по ключевому слову (keyword-only arguments (docs.python.org/3/glossary.html#keyword-only-parameter)):

key указывает функцию одного аргумента, которая используется для извлечения ключа сравнения из каждого элемента списка (например, key=str.lower). Соответствующий ключ для каждого элемента в списке вычисляется однажды и затем используется для всего сортировочного процесса. По-умолчанию значение None обозначает, что элементы списка сортируются прямо без вычисления отдельного значения ключа.

Доступна утилита function.cmp_to_key() (docs.python.org/3/library/functools.html#functools.cmp_to_key) для конвертации функции cmp в стиле 2.x в функцию key.

reverse - логическое значение. True, когда элементы списка сортируются, как если бы каждое сравнение было обратным.

Этот метод изменяет последовательность на месте для экономии пространства при сортировки большой последовательности. Чтобы напомнить пользователям, что она действует по побочному эффекту, она не возвращает отсортированную последовательность (используйте sorted(), чтобы явно запросить новый экземпляр отсортированного списка).

Гарантируется, что метод sort() останется стабильным. Сортировка стабильна, если она гарантирует отсутствие изменения отношения порядка элементов, которые при сравнении равны - это полезно для сортировки в несколько проходов (например, сортировать по отделам, затем по зарплате).

Детали реализации CPython: В то время, пока список сортируется, эффект попытки изменить или даже проверить список не определен. C-реализация Python заставляет список проявляться пустым на протяжении этого времени, и возбуждает ValueError, если может обнаружить, что список был изменен во время сортировки.

4.6.5. Кортежи
Кортежи - неизменяемые последовательности, обычно используемые для хранения коллекций неоднородных данных (таких как 2-кортежи, производимые встроенной enumerate()). Кортежи также используются в случаях, когда необходимы неизменяемые последовательности однородных данных (таких, которые позволено хранить в экземплярах set и dict).

class tuple([iterable])

Кортежи могут быть сконструированы несколькими способами:

Используя пару круглых скобок для обозначения пустого кортежа: ()
Используя завершающую запятую для кортежа с одним элементом: a, или (a,)
Разделяя элементы запятыми: a, b, c или (a, b, c)
Используя встроенный tuple(): tuple() или tuple(iterable)
Конструктор строит кортеж, чьи элементы такие же и в том же порядке, что и элементы iterable. iterable может быть либо последовательностью, поддерживающим итерацию контейнером, либо объектом-итератором. Если iterable уже кортеж, то возвращается неизмененным. Например, tuple('abc') возвращает ('a', 'b', 'c'), а tuple( [1, 2, 3] ) возвращает (1, 2, 3). Если аргументы не заданы, конструктор создает новый пустой кортеж, ().

Заметьте, что фактически кортеж создает запятая, а не скобки. Скобки необязательны за исключением случая пустого кортежа или, когда они необходимы для избежания синтаксической двусмысленности. Например, f(a, b, c) - функция, вызываемая с тремя аргументами, в то время как f((a, b, c)) есть функция, вызываемая с единственным аргументом - кортежем из 3-х элементов.

Кортежи реализуют все общие операции последовательностей.

Для гетерогенных коллекций данных, в которых доступ по имени яснее, чем доступ по индексу, collections.namedtuple() (docs.python.org/3/library/collections.html#collections.namedtuple) может быть более подходящим выбором, чем простой объект кортежа.

4.6.6. Диапазоны (ряды)
Тип range представляет собой неизменяемую последовательность чисел и обычно используется для прохода конкретного числа раз в циклах for (docs.python.org/3/reference/compound_stmts.html#for).

class range(stop)
class range(start, stop[, step])

Аргументы в конструкторе диапазона должны быть целыми числами (либо встроенного int, либо любой объект, который реализует специальный метод __index__). Если аргумент step опущен, то приравнивается по-умолчанию к 1. Если аргумент start опущен, то по-умолчанию 0. Если step равен нулю, возбуждается ValueError (docs.python.org/3/library/exceptions.html#ValueError).

Для положительного step содержимое диапазона r определяется формулой r[i] = start + step*i, где i >= 0 и r[i] < stop.

Для отрицательного step содержимое диапазона r все еще определяется по формуле r[i] = start + step*i, но ограничениями являются i >= 0 и r[i] > stop.

Объект диапазона будет пустым, если r[0] не встречает ограничения значения. Диапазоны осуществляют поддержку отрицательных индексов, но они интерпретируются как индексирование с конца последовательности, определенной положительными индексами.

Ряды, содержащие абсолютные значения больше, чем sys.maxsize (docs.python.org/3/library/sys.html#sys.maxsize) допустимы, но некоторые возможности (такие как len()) могут возбуждать OverflowError (docs.python.org/3/library/exceptions.html#OverflowError).

Примеры рядов:

>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> list(range(0, 30, 5))
[0, 5, 10, 15, 20, 25]
>>> list(range(0, 10, 3))
[0, 3, 6, 9]
>>> list(range(0, -10, -1))
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
>>> list(range(0))
[]
>>> list(range(1, 0))
[]
Диапазоны реализуют все общие операции последовательностей, за исключением конкатенации и повторения (в виду того, что объекты range могут только представлять последовательности, которые следуют строгому шаблону, а повторение и конкатенация обычно нарушают этот шаблон).

start

Значение параметра start (или 0, если параметр не предоставлен)

stop

Значение параметра stop

step

Значение параметра step (или 1, если параметр не предоставлен)

Преимуществом типа range над регулярными list и tuple является то, что объект range будет всегда занимать одинаковое (маленькое) количество памяти, независимо от размера диапазона, который он представляет (так как он хранит только значения start, stop и step, вычисляющие индивидуальные значения и подряды при необходимости).

Объекты range реализуют ABC collections.abc.Sequence (docs.python.org/3/library/collections.abc.html#collections.abc.Sequence), и предоставляют такие возможности, как проверки на содержание, поиск элемента по индексу, взятие среза и поддержка отрицательных индексов (см. Типы последовательностей - list, tuple, range):

>>> r = range(0, 20, 2)
>>> r
range(0, 20, 2)
>>> 11 in r
False
>>> 10 in r
True
>>> r.index(10)
5
>>> r[5]
10
>>> r[:5]
range(0, 10, 2)
>>> r[-1]
18
Проверка объектов range на равенство с помощью == и != сравнивает их как последовательности. То есть два объекта range считаются равными, если представляют одинаковую последовательность значений. (Отметьте, что два объекта-диапазона, которые сравнимо равны, могут иметь различные атрибуты start, stop и step, например, range(0) == range(2, 1, 3) или range(0, 3, 2) == range(0, 4, 2).)

Изменено в версии 3.2: Реализована последовательность ABC. Поддерживается взятие среза и отрицательные индексы. Проверяются объекты int на членство в постоянном времени, а не итерация по всем элементам.

Изменено в версии 3.3: Определено '==' и '!=' для сравнения объектов range, основанное на последовательности определенных в них значений (вместо сравнения, основанного на идентичности объекта).

Новое в версии 3.3: Атрибуты start, stop и step.

См. также:

linspace recipe (code.activestate.com/recipes/579000/) показывает, как реализовать ленивую версию диапазона, который подходит для приложений с числами с плавающей точкой.

4.7. Тип текстовой последовательности - str
В Python текстовые данные обрабатываются с помощью объектов str, или string. Строки являются неизменяемыми последовательностями кодовых указателей Unicode. Строковые литералы записываются разными способами:

Одиночные кавычки: 'allows embedded "double" quotes'
Двойные кавычки: "allows embedded 'single' quotes"
Тройные кавычки: '''Три одиночные кавычки''', """Три двойные кавычки"""
Строки в тройных кавычках могут продолжаться на несколько строк - все связанные пробелы будут включены в строковый литерал.

Строковые литералы, которые является частью одного выражения и имеет пробелы только между собой, будут неявно конвертированы в один строковый литерал. То есть ("spam " "eggs") == "spam eggs".

Дополнительно см. String and Bytes literals (docs.python.org/3/reference/lexical_analysis.html#strings) о различных формах строкового литерала, включая поддерживаемые escape-последовательности и префикс r ("raw" - сырой), который отключает обработку большинства эскейп-последовательностей.

Строки также могут быть созданы из других объектов с помощью конструктора str (docs.python.org/3/library/stdtypes.html#str).

Поскольку нет отдельного типа "символ", индексация строк создает строки с длинной 1. То есть для непустой строки s, s[0] == s[0:1].

Также не существует изменяемого строкового типа, но str.join() или io.StringIO (docs.python.org/3/library/io.html#io.StringIO) могут быть использованы для эффективной конструкции строк из нескольких фрагментов.

Изменения в версии 3.3: Для обратной совместимости с версиями Python 2, префикс u еще раз разрешен для строковых литералов. Он не оказывает эффект на значение строкового литерала и не может быть скомбинирован с префиксом r.

class str(object=")
class str(object=b", encoding='utf-8', errors='strict')

Возвращает строковую версию объекта. Если object не предоставлен, возвращает пустую строку. В других случаях поведение str() зависти от того, заданы ли encoding или errors следующим образом.

Если ни encoding, ни errors не заданы, str(object) возвращает object.__str__() (docs.python.org/3/reference/datamodel.html#object.__str__), который является "неформальной" или хорошо печатаемым строковым представлением object. Для строковых объектов это есть сама строка. Если object не имеет метода __str__(), то str() возвращается к возврату repr(object).

Если по крайней мере один из encoding или errors задан, объекту следует быть bytes-like object (docs.python.org/3/glossary.html#term-bytes-like-object) (напр., bytes или bytearray). В этом случае, если object есть объект bytes (или bytearray), то str(bytes, encoding, errors) эквивалентно bytes.decode(encoding, errors). В других случаях, байтовые объекты, лежащие в основе буферного объекта, доставляются перед вызовом bytes.decode(). См. Типы бинарных последовательностей - bytes, bytearray, memoryview и Buffer Protocol (docs.python.org/3/c-api/buffer.html#bufferobjects) для информации о буферных объектах.

Передача объекта bytes в str() без аргументов encoding или errors подпадает под первый случай под первый случай возврата неформального строкового представления (см. также опцию командной строки Python -b (docs.python.org/3/using/cmdline.html#cmdoption-b)). Например:

>>> str(b'Zoot!')
"b'Zoot!'"
Для большей информации по классу str и его методам, см. Тип текстовой последовательности - str и раздел ниже Строковые методы. Для вывода отформатированных строк, см. Отформатированные строковые литералы и раздел Синтаксис формата строки. Дополнительно, см. раздел Text Processing Services (docs.python.org/3/library/text.html#stringservices).

4.7.1. Строковые методы
Строки реализуют все общие операции последовательностей, наряду с дополнительными методами, описанными ниже.

Строки также поддерживают два стиля строкового форматирования, один из которых обеспечивает большую степень гибкости и настраиваемости (см. str.format(), Format String Syntax и Custom String Formatting), а другой основывается на Си-стиле printf, который обрабатывает более узкий диапазон типов и немного сложнее для корректного использования, но часто быстрее для классов, которые могут быть обработаны (printf-стиль форматирования строки).

Раздел Text Processing Services (docs.python.org/3/library/text.html#textservices) стандартной библиотеки описывает ряд других модулей, которые предоставляют различные тексто-зависимые утилиты (включая поддержку регулярных выражений в модуле re (docs.python.org/3/library/re.html#module-re)).

str.capitalize()

Возвращает копию строки, у которой ее первый символ написан в верхнем регистре, а остальные в нижнем.

str.casefold()

Возвращает casefolded копию строки. Такие строки могут быть использованы для регистронезависимого сопоставления.

Casefolding похоже на приведение к нижнему регистру, но более агрессивно, потому что предназначен для удаления всех случаев различий в строке. Например, например немецкая буква в нижнем регистре 'ß' эквивалентна "ss". Поскольку она уже в нижнем регистре, lower() ничего бы не сделало с 'ß'; casefold() конвертирует ее в "ss".

Casefolding-алгоритм описан в разделе 3.13 в Unicode Standard.

Новое в версии 3.3.

str.center(width[, fillchar])

Возвращает str, отцентрированную в строке длинной width. Набивка выполняется с помощью указанного fillchar (по умолчанию пробел ASCII). Возвращается исходная строка, если width меньше или равна len(s).

str.count(sub[, start[, end]])

Возвращает количество неперекрывающихся вхождений подстроки sub в диапазоне [start, end]. Опциональные аргументы start и end интерпретируются в нотации среза.

str.encode(encoding="utf-8", errors="strict")

Возвращает закодированную версию строки как объект байтов. По умолчанию кодировкой является 'utf-8'. Может быть задана errors для установки другой схемы обработки ошибок. По умолчанию errors равно 'strict', обозначающее, что ошибки кодировки возбуждают UnicodeError (docs.python.org/3/library/exceptions.html#UnicodeError). Другие возможные значения - 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' и любые другие имена, зарегистрированные посредством codecs.register_error() (docs.python.org/3/library/codecs.html#codecs.register_error), см. раздел Error Handlers (docs.python.org/3/library/codecs.html#error-handlers). Список возможных кодировок, см. раздел Standard Encodings (docs.python.org/3/library/codecs.html#standard-encodings).

Изменено в версии 3.1: Добавлена поддержка для аргументов по ключевому слову.

str.endswith(suffix[, start[, end]])

Возвращает True, если строка заканчивается на указанный suffix, иначе возвращает False. suffix также может быть кортежем суффиксов для поиска. С опциональным start проверка начинается с этой позиции. С опциональным end, останавливает сравнение на этой позиции.

str.expandtabs(tabsize=8)

Возвращает копию строки, где все символы табуляции заменены одним или более пробелами, зависящими от текущего столбца и заданного размера табуляции. Позиции табуляции имеют все символы tabsize (по умолчанию 8, задаваемые позиции табуляции в столбцах 0, 8, 16 и т. д.). Для расширения строки текущий столбец устанавливается в ноль и строка проверяется символ за символом. Если символ является табуляцией (\t), один или более символов пробела вставляются в результат до тех пор, пока текущий столбец не равен следующей позиции табуляции. (Сам символ табуляции не копируется.) Если символ является новой строкой (\n) или возвратом (\r), он копируется, а текущий столбец сбрасывается в ноль. Любые другие символы копируются без изменений, и текущий столбец увеличивается на единицу, независимо от того, как символ отображается при печати.

>>> '01\t012\t0123\t01234'.expandtabs()
'01      012     0123    01234'
>>> '01\t012\t0123\t01234'.expandtabs(4)
'01  012 0123    01234'
str.find(sub[, start[, end]])

Возвращает самый нижний индекс в строке, где найдена подстрока sub в срезе s[start:end]. Опциональные аргументы start и end интерпретируются в нотации среза. Возвращает -1, если sub не найден.

Замечание: Методы find() следует использовать только, если вам надо знать позицию sub. Для проверки является ли sub подстрокой или нет, используйте оператор in (docs.python.org/3/reference/expressions.html#in):

>>> 'Py' in 'Python'
True
str.format(*args, **kwargs)

Выполняет операцию форматирования строки. Строка, для которой вызывается этот метод, может содержать литеральный текст или поля замещения, отделенные фигурными скобками {}. Каждое поле замещения содержит либо числовой индекс позиционного аргумента, либо имя аргумента с ключевым словом. Возвращает копию строки, где каждое поле замещения заменено на строковое значение соответствующего аргумента.

>>> "The sum of 1 + 2 is {0}".format(1+2)
'The sum of 1 + 2 is 3'
См. Format String Syntax (docs.python.org/3/library/string.html#formatstrings) для описания различных опций форматирования, которые могут быть указаны в форматировании строк.

str.format_map(mapping)

Подобно str.format(**mapping), за исключением того, что используется прямо и не копируется в dict. Это полезно, если, например, mapping является подклассом словаря:

>>> class Default(dict):
...     def __missing__(self, key):
...         return key
...
>>> '{name} was born in {country}'.format_map(Default(name='Guido'))
'Guido was born in country'
Новое в версии 3.2.

str.index(sub[, start[, end]])

Подобно find(), но возбуждает ValueError (docs.python.org/3/library/exceptions.html#ValueError), когда подстрока не найдена.

str.isalnum()

Возвращает истину, если все символы в строке есть буквенно-цифровые, и есть по крайней мере один символ, ложь в иных случаях. Символ c является буквенно-цифровым, если один из следующих возвращает True: c.isalpha(), c.isdecimal(), c.isdigit() или c.isnumeric().

str.isalpha()

Возвращает истину, если все символы в строке являются алфавитными и есть по крайней мере один символ, ложь в других случаях. Алфавитные символы - это те символы, которые определены в базе данных символов Unicode как "буква", т. е. те, у которых общее свойство категории является одна из "Lm", "Lt", Lu", "Ll" или "Lo". Заметьте, что это отличается от свойства "Алфавитный", определенное в Unicode Standard.

str.isdecimal()

Возвращает истину, если все символы в строке являются символами десятичных чисел, и есть как минимум один символ, иначе - ложь. Цифры включают десятичные символы и цифры, которые требуют специальной обработки, такие как цифры надстрочного знака совместимости. Это покрывает цифры, которые не могут быть использованы для формирования чисел с основанием 10, такие как числа Kharosthi. Формально, цифра есть символ, имеющий значение свойства Numeric_Type=Digit или Numeric_Type=Decimal.

str.isidentifier()

Возвращает истину, если строка есть действующий идентификатор, соответствующий языковому определению, раздел Identifiers and keywords (docs.python.org/3/reference/lexical_analysis.html#identifiers).

Используйте keyword.iskeyword() для проверки на зарезервированные идентификаторы, такие как def и class.

str.islower()

Возвращает истину, если все заключенные в строке символы [4] находятся в нижнем регистре и есть по крайней мере один символ, ложь в других случаях.

str.isnumeric()

Возвращает истину, если все символы в строке являются числовыми символами, и есть как минимум один символ, иначе ложь. Числовые символы включают символы цифр и все символы, которые имеют свойство числового значения Unicode, например, U+2155, VULGAR FRACTION ONE FIFTH. Формально числовые символы есть те, которые имеют значение свойства Numeric_Type=Digit, Numeric_Type=Decimal или Numeric_Type=Numeric.

str.ispringtable()

Возвращает истину, если все символы в строке печатаемые, или строка пуста, иначе - ложь. Непечатаемые символы - это те, которые определены в базе данных символов Unicode как "Другие" или "Разделитель", за исключением пробела ASCII (0x20), который считается печатаемым. (Заметьте, что печатаемые символы в этом контексте есть те, которым не следует быть избежавшими, когда для строки вызывается repr(). Это не имеет отношения к обработке строк, написанных к sys.stdout или sys.strdirr.)

str.isspase()

Возвращает истину при условии, что строка содержит только пробелы, и есть хотя бы один символ, в других случаях возвращает ложь. Символы пробела - это те символы, которые определены в базе данных символов Unicode как "Другие" или "Разделитель" и имеющие двунаправленное свойство, являющееся одним из "WS", "B" или "S".

str.istitle()

Возвращает истину, если строка является строкой заголовка, и содержит хотя бы один символ, например, за символами в верхнем регистре могут следовать только символы не в верхнем регистре, а символы в нижнем регистре только после первых. Иначе возвращает ложь.

str.isupper()

Возвращает истину, если все символы [4] в строке в верхнем регистре, и есть как минимум один символ, ложь иначе.

str.join(iterable)

Возвращает строку, которая является конкатенацией строк из iterable. Возбуждается TypeError (docs.python.org/3/library/exceptions.html#TypeError), если есть любое нестроковое значение в iterable, включая объекты bytes. Разделителем между элементами является строка, к которой данный метод применяется.

str.ljust(width[, fillchar])

Возвращает строку, выровненную по левому краю в строке длинной width. Заполнение выполняется с помощью указанного fillchar (по умолчанию это пробел ASCII). Возвращается исходная строка, если width меньше или равна len(s).

str.lower()

Возвращает копию строки со всеми включенными символами [4], конвертированными в нижний регистр.

Используемый алгоритм привода к нижнему регистру описан в разделе 3.13 Unicode Standard.

str.lstrip([chars])

Возвращает копию строки с удаленными лидирующими символами. Аргумент chsrs есть строка, указывающая набор символов, которые должны быть удалены. Если опущен или None, аргумент chars по умолчанию удаляет пробелы. Аргумент char не является префиксом; скорее все комбинации его значений удаляются:

>>> '   spacious   '.lstrip()
'spacious   '
>>> 'www.example.com'.lstrip('cmowz.')
'example.com'
static str.maketrans(x[, y[, z]])

Это статический метод возвращает таблицу перевода, используемую для str.translate().

Если имеется только один аргумент, это должен быть словарь, сопоставляющий порядковые номера Юникода (целые числа) или символы (строки длинной 1) с порядковыми номерами Юникода, строки (произвольной длины) или None. Ключи символов будут затем конвертированы в порядковые номера.

Если имеется два аргумента, они должны быть строками равной длины, и в результирующем словаре каждый символ в x должен быть сопоставлен с символом в той же позиции в y. Если три аргумента, это должна быть строка, чьи символы будут сопоставлены с None в результате.

str.partition(sep)

Разделение строки по первому случаю sep и возврат кортежа из 3-х элементов, содержащего часть до сепаратора, сам разделитель, и часть после него. Если сепаратор не найден, возвращает также 3-х элементный кортеж, содержащий саму строку, за которой следуют две пустые строки.

str.replace(old, new[, count])

Возвращает копию строки, где все случаи подстроки old заменены на new. Если опциональный аргумент count задан, заменяется только это количество первых вхождений.

str.rfind(sub[, start[, end]])

Возвращает самый верхний индекс в строке, в которой найдена подстрока sub, таким образом, что sub содержится в s[start:end]. Опциональные аргументы start и end интерпретируются в нотации среза. В случае неудачи возвращает -1.

str.rindex(sub[, start[, end]])

Подобно rfind(), но возбуждает ValueError (docs.python.org/3/library/exceptions.html#ValueError), когда подстрока sub не найдена.

str.rjust(width[, fillchar])

Возвращает строку, выравненную по правому краю с строке длиной width. Заполнение выполняется указанным fillchar (по умолчанию это пробел ASCII). Возвращается исходная строка, если width меньше чем или равен len(s).

str.rpartition(sep)

Разделяет строку по последнему вхождению sep и возвращает 3-х членный кортеж, включающий часть до сепаратора, сам сепаратор и часть после него. Если разделитель не найден, возвращается 3-кортеж, содержащий две пустые строки, за которыми следует сама строка.

str.rsplit(sep=None, maxsplit=-1)

Возвращает список слов из строки, используя sep как разделитель строки. Если задан maxsplit, наибольшее количество maxsplit разделений выполняется, тех что справа. Если sep не указан или None, разделителем является любая пробельная строка. Кроме того, что выполняет разделение справа, rsplit() ведет себя как split(), который в деталях описан ниже.

str.rstrip([chars])

Возвращает копию строки с удаленными завершающими символами. Аргумент chars является строкой, указывающей набор символов к удалению. Если опущен или None, аргумент chars по умолчанию означает удаление пробелов. Аргумент chars не является суффиксом; скорее все комбинации его значений удаляются:

>>> '   spacious   '.rstrip()
'   spacious'
>>> 'mississippi'.rstrip('ipz')
'mississ'
str.split(sep=None, maxsplit=-1)

Возвращает список слов строки, используя sep в качестве ее разделителя. Если задан maxsplit, выполняется наибольшее количество разделений maxsplit (таким образом, список будет содержать наибольшее maxsplit+1 элементов). Если maxsplit не указан или -1, то нет ограничений на количество разделений (все возможные разделения выполняются).

Если задан sep, последовательные разделители не группируются вместе и считаются разделенными пустыми строками (например, '1,,2'.split(',') возвращает ['1', '', '2']). Аргумент sep может содержать не один символ (например, '1<>2<>3'.split('<>') возвращает ['1', '2', '3']).

Например:

>>> '1,2,3'.split(',')
['1', '2', '3']
>>> '1,2,3'.split(',', maxsplit=1)
['1', '2,3']
>>> '1,2,,3,'.split(',')
['1', '2', '', '3', '']
Если sep не указан или равен None, применяется другой алгоритм разделения: последовательные пробелы рассматриваются как один разделитель, и результат не будет содержать пустые строки в начале или конце, если строка имеет впереди и сзади стоящие пробелы. Отсюда следует, что разделение с сепаратором None пустой строки или содержащей просто пробел возвращает [].

Например:

>>> '1 2 3'.split()
['1', '2', '3']
>>> '1 2 3'.split(maxsplit=1)
['1', '2 3']
>>> '   1   2   3   '.split()
['1', '2', '3']
str.splitlines([keepends])

Возвращает список линий в строке, разделенных границами линий. Разделители линий не включаются в результирующий список, если keepends не задан как истина.

Этот метод разделяет по следующим границам линий. В частности, границы - это расширенный набор universal newlines (docs.python.org/3/glossary.html#term-universal-newlines).

Представление	Описание
\n	Создает линию
\r	Возврат каретки
\r\n	Возврат каретки и создание линии
\v или \x0b	Табуляция линии
\f или \x0c	Form Feed
\x1c	Разделитель файла
\x1d	Групповой разделитель
\x1e	Разделитель записи
\x85	Следующая линия (C1 Control Code)
\u2028	Разделитель линии
\u2029	Разделитель параграфа
Изменено в версии 3.2: \v и \f добавлены в список границ линий.

Например:

>>> 'ab c\n\nde fg\rkl\r\n'.splitlines()
['ab c', '', 'de fg', 'kl']
>>> 'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)
['ab c\n', '\n', 'de fg\r', 'kl\r\n']
В отличие от split(), когда задан разделитель строки sep, этот метод возвращает пустой список для пустой строки, и разрыв завершающей линии не приводит к дополнительной линии:

>>> "".splitlines()
[]
>>> "One line\n".splitlines()
['One line']
Для сравнения, split('\n') дает:

>>> ''.split('\n')
['']
>>> 'Two lines\n'.split('\n')
['Two lines', '']
str.startswith(prefix[, start[, end]])

Возвращает True, если строка начинается с prefix, в других случаях возвращает False. Также prefix может быть кортежем префиксов для подыскивания. С опциональным start, проверка строки начинается с этой позиции. С опциональным end, сравнение строки останавливается у этой позиции.

str.strip([chars])

Возвращает копию строки с удаленными лидирующими и заканчивающими символами. Аргумент chars есть строка, указывающая набор символов к удалению. Если опущена или None, аргумент chars по умолчанию обозначает удаление пробелов. Аргумент chars не префикс или суффикс; скорее удаляются все комбинации его значений:

>>> '   spacious   '.strip()
'spacious'
>>> 'www.example.com'.strip('cmowz.')
'example'
Внешние лидирующие и заканчивающие значения аргумента chars удаляются из строки. Символы удаляются с переднего конца до тех пор, пока не достигнут строковый символ, который не включен в набор символов chars. Похожие действия имеют место с заднего конца. Например:

>>> comment_string = '#....... Section 3.2.1 Issue #32 .......'
>>> comment_string.strip('.#! ')
'Section 3.2.1 Issue #32'
str.swapcase()

Возвращает копию строки, в которой символы в верхнем регистре конвертированы в нижний и наоборот. Заметьте, что не обязательно истина, что s.swapcase().swapcase() == s.

str.title()

Возвращает заголовочную версию строки, где слова начинаются с символа в верхнем регистре, а оставшиеся символы находятся в нижнем.

Например:

>>> 'Hello world'.title()
'Hello World'
Алгоритм использует простое независимое от языка определение слова как группы последовательных букв. Определение работает во многих контекстах, но это означает, что сокращения и притяжательные формы слов разделяются, что может быть не желательным результатом:

>>> "they're bill's friends from the UK".title()
"They'Re Bill'S Friends From The Uk"
Обходной путь для апострофов может быть сконструирован, используя регулярные выражения:

>>> import re
>>> def titlecase(s):
...     return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
...                   lambda mo: mo.group(0)[0].upper() +
...                              mo.group(0)[1:].lower(),
...                   s)
...
>>> titlecase("they're bill's friends.")
"They're Bill's Friends."
str.translate(table)

Возвращает копию строки, в которой каждый символ был сопоставлен согласно заданной таблице перевода. Таблица должна быть объектом, который реализует индексирование посредством __getitem__() (docs.python.org/3/reference/datamodel.html#object.__getitem__), обычно mapping или sequence. При индексировании порядком Unicode (целые числа), табличный объект может выполнять любое из следующего: возвращать порядковый номер Юникода или строку, сопоставляя символ одному или более другим символам; возвращать None, удаляя символ из возвращаемой строки; или возбуждать исключение LookupError (docs.python.org/3/library/exceptions.html#LookupError), сопоставляя символ самому себе.

Вы можете использовать str.maketrans() для создания карты перевода из символ-к-символу отображений в различных форматах.

См. также модуль codecs (docs.python.org/3/library/codecs.html#module-codecs) для более гибкого подхода для настройки отображений символов.

str.upper()

Возвращает копию строке, в которой все символы, которые могут быть в разных регистрах, [4] конвертированы в верхний. Заметьте, что str.upper().isupper() может быть False, если s содержит символы, которые не могут быть в разных регистрах, или если категория Unicode результирующих символа(ов) не является "Lu" (Letter - буква, uppercase - заглавная), но например "Lt" (Letter, titlecase - заголовочная).

Используемый алгоритм приведения к верхнему регистру описан в разделе 3.13 стандарта Юникода.

str.zfill(width)

Возвращает копию строки, заполненную слева цифрами '0' ASCII, чтобы сделать ее длиной width. Лидирующий знаковый префикс ('+'/'-') обрабатывается вставкой заполнения после знака символа скорее, чем перед ним. Возвращается исходная строка, если width меньше чем или равна len(s).

Например: 

>>> "42".zfill(5)
'00042'
>>> "-42".zfill(5)
'-0042'
4.7.2. printf-стиль форматирования строки
Замечание: Описанные здесь операции форматирования показывают разнообразие особенностей, которые ведут к ряду обычных ошибок (таких как неудача при корректном отображении кортежей и словарей). Использование более новых интерфейсов formatted string literals (docs.python.org/3/reference/lexical_analysis.html#f-strings) или str.format() помогает избежать этих ошибок. Эти альтернативы также предоставляют более мощные, гибкие и масштабируемые подходы для форматирования текста.

У строковых объектов есть одна уникальная встроенная операция: оператор % (модуль, остаток от деления). Он также известен как строковый оператор форматирования и вставки. Учитывая, что format % value (где format есть строка), % изменяемые спецификации в format заменяются на ноль или более элементов в value. Эффект похож на использование sprintf() в языке C.

Если format требует одиночный аргумент, values может быть одиночным некортежным объектом. [5] В других случаях values должно быть кортежем с точным количеством элементов, указанных форматной строкой, или одиночным объектом отображения (например, словарем).

Преобразование спецификатора содержит два или более символа и имеет следующие компоненты, которые должны происходить в этом порядке:

Символ '%', который отмечает начало спецификатора.
Ключ отображения (опционально), состоящий из заключенной в скобки последовательности символов (например, (somename)).
Преобразование флагов (опционально), которое влияет на результат некоторых типов конверсий.
Минимальная ширина поля (опционально). Если указано как '*' (звездочка), фактическая ширина считывается из следующего элемента кортежа в value, и объект для конвертации приходит после минимальной ширины поля и опциональной точности.
Точность (опционально), задана как '.' (точка), за которой следует точность. Если указана как '*' (звездочка), фактическая точность читается из следующего элемента кортежа в values, и значение для конвертирования приходит после точности.
Модификатор длины (опционально).
Тип конверсии.
Когда правый аргумент является словарем (или другим типом отображения), то форматы в строке должны включать заключенные в скобки ключ отображения в этом словаре, вставленный сразу после символа '%'. Ключ соответствия выбирает значение, которое должно быть отформатировано из сопоставления. Например:

>>> print('%(language)s has %(number)03d quote types.' %
...       {'language': "Python", "number": 2})
Python has 002 quote types.
В этом случае спецификаторы * не могут встречаться в формате (поскольку они требуют последовательный список параметров).

Символами флагов преобразования являются:

Флаг	Значение
'#'	Преобразование значения будет использовать "альтернативную форму" (которая определена ниже).
'0'	Преобразование будет заполнено нулями для числовых значений.
'-'	Преобразуемое значение будет выравнено слева (переопределяет '0' конверсию, если обе заданы).
' '	(пробел) Пустоте следует быть слева до положительного числа (или пустой строки), производимого знаковым преобразованием.
'+'	Символ знака ('+' или '-') будет предшествовать конверсии (переопределяет флаг "пробел").
Может быть представлен модификатор длины (h, l, или L), но проигнорирован, т. к. он не необходим для Python, так что, напр., %ld идентичен %d.

Типами преобразований являются:

Преобразование	Значение	Замечание
'd'	Десятичное целое со знаком.	 
'i'	Десятичное целое со знаком.	 
'o'	Восьмеричное значение со знаком.	(1)
'u'	Устаревший тип - идентичен 'd'.	(6)
'x'	Знаковый шестнадцатеричный (нижний регистр).	(2)
'X'	Знаковый шестнадцатеричный (верхний регистр).	(2)
'e'	Формат вещественного числа с экспонентой (нижний регистр).	(3)
'E'	Формат вещественного числа с экспонентой (верхний регистр).	(3)
'f'	Десятичный формат вещественного числа.	(3)
'F'	Десятичный формат вещественного числа.	(3)
'g'	Формат вещественного числа. Используется экспоненциальный формат в нижнем регистре, если экспонента меньше, чем -4, или не меньше, чем точность, в других случаях - десятичный формат.	(4)
'G'	Формат вещественного числа. Используется экспоненциальный формат в верхнем регистре, если экспонента меньше, чем -4, или не меньше, чем точность, в других случаях - десятичный формат.	(4)
'c'	Одиночный символ (принимает целое или строку из одного символа).	 
'r'	Строка (конвертирует любой объект Python'а, используя repr()).	(5)
's'	Строка (конвертирует любой объект Python'а, используя str()).	(5)
'a'	Строка (конвертирует любой объект Python'а, используя ascii()).	(5)
'%'	Аргумент не преобразуется, в результате дает символ '%'.	 
Замечания:

Альтернативная форма вызывает впереди стоящий восьмеричный спецификатора ('0o'), который вставляется перед первой цифрой.
Альтернативная форма вызывает ведущий '0x' или '0X' (зависящий от того, был ли использован формат 'x' или 'X'), который вставляется перед первой цифрой.
Альтернативная форма приводит к тому, что результат всегда содержит десятичную точку, даже если нет последующих цифр.
Точность определяет число цифр после десятичной точки и по умолчанию 6.
Альтернативная форма приводит к тому, что результат всегда содержит десятичную точку, а нули в конце не удаляются, как это было бы в других случаях.
Точность определяет количество значащих цифр перед и после десятичной точки и по умолчанию равно 6.
Если точность равна N, вывод усекается до N символов.
См. PEP 237 (python.org/dev/peps/pep-0237).
Поскольку строки Python имеют очевидную длину, преобразования %s не предполагают, что '0' это конец строки.

Изменено в версии 3.1.: %f преобразования для чисел, чье абсолютное значение выше 1e50, являются не длиннее заменяемого преобразованием %g.

4.8. Типы бинарных последовательностей - bytes, bytearray, memoryview
Основные встроенные типы для управления двоичными данными - bytes и bytearray. Они поддерживаются memoryview, который использует buffer protocol (docs.python.org/3/c-api/buffer.html#bufferobjects) для доступа к памяти других двоичных объектов без необходимости создания копии.

Модуль array (docs.python.org/3/library/array.html#module-array) поддерживает эффективное хранение основных типов данных, таких как 32-битные целые числа и IEEE754 двойной точности вещественные значения.

4.8.1. Объекты Bytes
Объекты bytes - это неизменяемые последовательности одиночных байтов. Поскольку многие основные бинарные протоколы основаны на текстовой кодировке ASCII, объекты bytes предлагают несколько методов, которые являются валидными только тогда, когда работают с данными, совместимыми с ASCII, и тесно связаны со строковыми объектами множеством других способов.

class bytes([source[, encoding[, errors]]])

Во-первых, синтаксис байтовых литералов в основном такой же, как у строковых, за исключением того, что добавляется префикс b:

Одиночные кавычки: b'still allows embedded "double" quotes'
Двойные кавычки: b"still allows embedded 'single' quotes"
Тройные кавычки: b'''3 single quotes''', b"""3 double quotes"""
В байтовых литералах разрешены только символы ASCII (безотносительно объявленной кодировки исходного кода). Любые двоичные значения выше 127 должно быть введено в байтовые литералы с использованием соответствующей escape-последовательности.

Как и в строковых литералах, в байтовых также может использоваться префикс r для отключение обработки эскейп-последовательностей. См. String and Bytes literals (docs.python.org/3/reference/lexical_analysis.html#strings) для более подробной информации о различных формах байтовых литералов, включая поддерживаемые эскейп-последовательности.

В то время как байтовые литералы и представления базируются на тексте ASCII, байтовые объекты в действительности ведут себя как неизменяемые последовательности целых чисел, где каждое значение в последовательности ограничено так, что 0 <= x < 256 (попытки нарушить это ограничение будут инициировать ValueError (docs.python.org/3/library/exceptions.html#ValueError)). Это сделано умышленно, чтобы подчеркнуть, что, в то время как многие двоичные форматы включают основанные на ASCII элементы и могут быть успешно управляемыми некоторыми текст-ориентированными алгоритмами, это не основной случай для произвольных бинарных данных (применение в слепую алгоритмов обработки текстов к форматам двоичных данных, которые не совместимы с ASCII, будет обычно приводить к порче данных).

В дополнение к литеральным формам, байтовые объекты можно создать рядом других способов:

Заполненные нулями байтовые объекты указанной длины: bytes(10)
Из итерации целых чисел: bytes(range(20))
Копирование существующих бинарных данных через буферный протокол: bytes(obj)
Также см. встроенный bytes.

Поскольку 2 шестнадцатеричные цифры точно соответствуют одному байту, шестнадцатеричные числа - обычно используемый формат для описания двоичных данных. Соответственно, байтовый тип имеет дополнительный метод класса для чтения данных в этом формате:

classmethod fromhex(string)

Этот метод класса bytes возвращает объект байтов, декодируя переданный строковый объект. Строка должна включать две шестнадцатеричные цифры на байт с пробелом ASCII, который игнорируется.

>>> bytes.fromhex('2Ef0 F1f2  ')
b'.\xf0\xf1\xf2'
Существует функция обратного преобразования объекта байтов в его шестнадцатеричное представление.

hex()

Возвращает строковый объект, включающий две шестнадцатеричные цифры для каждого байта в экземпляре.

>>> b'\xf0\xf1\xf2'.hex()
'f0f1f2'
Новое в версии 3.5.

Поскольку объекты байтов являются последовательностями целых чисел (похоже на кортеж), для байтового объекта b, b[0] будет целым числом, будет объектом байтов длинной 1. (Что контрастирует с текстовой строкой, где как индексирование, так и взятие среза приведут к строке длинной 1.)

Представление объектов байтов использует литеральный формат (b'...'), так как зачастую это более пригодно, чем, напр., bytes([46, 46, 46]). Вы всегда можете преобразовать объект байтов в список целых чисел, используя list(b).

Замечание: Для пользователей Python 2.x: В версиях Python 2.x были разрешены различные неявные преобразования между 8-битными строками (ближайшая вещь 2.x предлагает встроенный двоичный тип данных) и строками Unicode. Это был обходной путь обратной совместимости для учета того факта, что Python изначально поддерживал только 8-битный текст, а текст Unicode был добавлен позже. В Python 3.x эти неявные конверсии исчезли - превращения между 8-битными двоичными данными и текстом Unicode должны быть явными, а объекты байтов и строк всегда при сравнении неравны.

4.8.2. Объекты Bytearray
Объекты bytearray являются изменяемыми двойниками объектов bytes.

class bytearray([source[, encoding[, errors]]])

Для объектов bytearray нет соответствующего литерального синтаксиса, вместо этого они всегда создаются вызовом конструктора:

Создание пустого экземпляра: bytearray()
Создание заполненного нулями экземпляра заданной длинны: bytearray(10)
Из итерации целых чисел: bytearray(range(20))
Копированием существующих бинарных данных через буферный протокол: bytearray(b'Hi!')
Так как объекты bytearray() изменяемые, они поддерживают операции изменяемых последовательностей дополнительно к общим операциям bytes и bytearray, описанным в Операции Bytes и Bytearray.

См. также встроенный bytearray.

Поскольку 2 шестнадцатеричные цифры точно соответствуют одному байту, такие цифры являются обычно используемым форматом для описания двоичных данных. Соответственно, тип bytearray имеет дополнительный класс методов для чтения данных в этом формате:

classmethod fromhex(string)

Классовый метод bytearray возвращает объект bytearray, декодирующий заданный строковый объект. Строка должна содержать две шестнадцатеричные цифры на байт с пробелом ASCII, который игнорируется.

>>> bytearray.fromhex('2Ef0 F1f2  ')
bytearray(b'.\xf0\xf1\xf2')
Существует обратная функция преобразования для превращения объекта bytearray в его шестнадцатеричное представление.

hex()

Возвращает строковый объект, содержащий две шестнадцатеричные цифры для каждого байта в экземпляре.

>>> bytearray(b'\xf0\xf1\xf2').hex()
'f0f1f2'
Новое в версии 3.5.

Поскольку объекты bytearray являются последовательностями целых чисел (похожих на список), для объекта bytearray b, b[0] будет целым числом, в то время как b[0:1] будет объектом bytearray длинной 1. (Это контрастирует с текстовыми строками, в которых как индексирование, так и взятие среза произведет строку длинной 1.)

Представление объектов bytearray использует байтовый литеральный формат (bytearray(b'...')), поскольку это часто более полезно, чем, напр., bytearray([46, 46, 46]). Вы всегда можете конвертировать объект bytearray в список целых чисел, используя list(b).

4.8.3. Операции Bytes и Bytearray
Объекты bytes и bytearray поддерживают общие операции последовательностей. Они совместимы не только с операндами того же типа, но и с любым байт-подобным объектом (docs.python.org/3/glossary.html#term-bytes-like-object). В следствие этой гибкости, они могут быть смешаны в операциях, и это не вызовет ошибки. Однако возвращаемый тип может зависеть от порядка операндов.

Замечание: Методы для объектов bytes и bytearray не принимают строки в качестве аргументов, также как методы для строк не принимают bytes как свои аргументы. Например, вы должны писать:

a = "abc"
b = a.replace("a", "f")
и

a = b"abc"
b = a.replace(b"a", b"f")
Некоторые операции bytes и bytearray предполагают использование совместимых с ASCII двоичных форматов, и поэтому следует избегать работы с случайными двоичными данными. Эти ограничения описываются ниже.

Замечание: Использование таких основанных на ASCII операций для управления двоичными данными, которые не хранятся в ASCII формате, может привести к порче данных.

Следующие методы, применяемые для объектов bytes и bytearray могут быть использованы с произвольными двоичными данными.

bytes.count(sub[, start[, end]])
bytearray.count(sub[, start[, end]])

Возвращает количество неперекрывающихся подпоследовательностей sub в диапазоне [start, end]. Опциональные аргументы start и end интерпретируются в нотации среза.

Искомая подпоследовательность может быть любым байт-подобным объектом (docs.python.org/3/glossary.html#term-bytes-like-object) или целым в диапазоне от 0 до 255.

Изменено в версии 3.3: Также в качестве подпоследовательностей принимаются целые числа в диапазоне от 0 до 255.

bytes.decode(encoding="utf-8", errors="strict")
bytearray.decode(encoding="utf-8", errors="strict")

Возвращает строку, которая декодируется из заданного bytes. По умолчанию кодировкой является 'utf-8'. Могут быть заданы errors для установки другой схемы обработки ошибок. По умолчанию для errors установлено 'strict', обозначающее, что ошибки кодировки возбуждают UnicodeError (docs.python.org/3/library/exceptions.html#UnicodeError). Другими возможными значениями являются 'ignore', 'replace' и любые другие имена, зарегистрированные через codecs.register_error() (docs.python.org/3/library/codecs.html#codecs.register_error), см. раздел Error Handlers (docs.python.org/3/library/codecs.html#codecs.register_error). Чтобы узнать список возможных кодировок, см. раздел Стандартные кодировки (docs.python.org/3/library/codecs.html#standard-encodings).

Замечание: Передача аргумента encoding на str позволяет декодировать любой байтоподобный объект (docs.python.org/3/glossary.html#term-bytes-like-object) напрямую, без необходимости создания временного объекта bytes или bytearray.

Изменено в версии 3.1: Добавлена поддержка для аргументов по ключевым словам.

bytes.endswith(suffix[, start[, end]])
bytearray.endswith(suffix[, start[, end]])

Возвращает True, если двоичные данные заканчиваются на указанный suffix, в других случаях возвращает False. suffix также может быть кортежем суффиксов для поиска. С опциональным start проверка начинается с этой позиции. С опциональным end, сравнение останавливается в этой позиции. 

Суффикс(ы) для поиска может быть любым байтподобным объектом.

bytes.find(sub[, start[, end]])
bytearray.find(sub[, start[, end]])

Возвращает самый нижний индекс в данных, где найдена подпоследовательность sub, так что sub содержится в срезе s[start:end]. Опциональные аргументы start и end интерпретируются в нотации среза. Возвращает -1, если sub не найдена.

Подпоследовательность для поиска может быть любым байтподобным объектом или целым числом в диапазоне от 0 до 255.

Замечание: Метод find() следует использовать, только если вам необходимо знать позицию sub. Для проверки является ли sub подстрокой или нет, используйте оператор in (docs.python.org/3/reference/expressions.html#in):

>>> b'Py' in b'Python'
True
Изменено в версии 3.3: Также принимает целые числа в диапазоне от 0 до 255 в качестве подпоследовательности.

bytes.index(sub[, start[, end]])
bytearray.index(sub[, start[, end]])

Подобно find(), но возбуждает ValueError (docs.python.org/3/library/exceptions.html#ValueError), когда подпоследовательность не найдена.

Подпоследовательность для поиска может быть любым байтподобным объектом или целым числом в диапазоне от 0 до 255.

Изменено в версии 3.3: Также принимает целые числа в диапазоне от 0 до 255 в качестве подпоследовательности.

bytes.join(iterable)
bytearray.join(iterable)

Возвращает объект bytes или bytearray, который представляет собой соединение двоичных данных последовательностей в iterable. Будет возбуждено TypeError (docs.python.org/3/library/exceptions.html#TypeError), если есть любое значение в iterable, которое не является байтподобным объектом, включая объекты str. Разделителем между элементами является содержимое байтов или объект bytearray, предоставляющий этот метод.

static bytes.maketrans(from, to)
static bytesarray.maketrans(from, to)

Данный статический метод возвращает таблицу перевода, удобную для bytes.translante(), который будет сопоставлять каждый символ в from символу в той же позиции в to; оба from и to должны быть байт-подобными объектами (docs.python.org/3/glossary.html#term-bytes-like-object) и иметь одинаковую длину.

Новое в версии 3.1.

bytes.partition(sep)
bytesarray.partition(sep)

Разделяет последовательность по первому вхождению sep и возвращает 3-кортеж, содержащий часть до разделителя, сам сепаратор, и часть после него. Если разделитель не найден, возвращает 3-кортеж, содержащий копию исходной последовательности, за которой следуют два пусты объекта bytes или bytearray.

Сепаратор для поиска может быть любым байт-подобным объектом.

bytes.replace(old, new[, count])
bytesarray.replace(old, new[, count])

Возвращает копию последовательности, в которой все случаи подпоследовательности old заменены на new. Если необязательных аргумент count задан, только первые count случаев заменяется.

Подпоследовательности для поиска и замены могут быть любыми байт-подобными объектами.

Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

bytes.rfind(sub[, start[, end]])
bytesarray.rfind(seb[, start[, end]])

Возвращает наибольший индекс в последовательности, где найдена подпоследовательность sub, такая что sub содержится в s[start:end]. Опциональные аргументы start и end понимаются в нотации среза. Возвращает -1 в случае неудачи.

Подпоследовательность для поиска может быть любым байт-подобным объектом или целым числом в диапазоне от 0 до 255.

Изменено в версии 3.3: Также стал принимать числа от 0 до 255 в качестве подпоследовательности.

bytes.rindex(sub[, start[, end]])
bytesarray.rindex(seb[, start[, end]])

Подобен rfind(), но возбуждает ValueError (docs.python.org/3/library/exceptions.html#ValueError), когда подпоследовательность sub не найдена.

Подпоследовательность для поиска может быть любым байт-подобным объектом или целым числом в диапазоне от 0 до 255.

Изменено в версии 3.3: Также стал принимать числа от 0 до 255 в качестве подпоследовательности.

bytes.rpartition(sep)
bytesarray.rpartition(sep)

Разделяет последовательность по последнему вхождению sep и возвращает 3-кортеж, содержащий часть до разделителя, сам сепаратор, и часть после него. Если разделитель не найден, возвращает 3-кортеж, содержащий копию исходной последовательности, за которой следуют два пусты объекта bytes или bytearray.

Сепаратор для поиска может быть любым байт-подобным объектом.

bytes.startswith(prefix[, start[, end]])
bytesarray.startswith(prefix[, start[, end]])

Возвращает True, если двоичные данные начинаются с указанного prefix, иначе возвращает False. prefix может быть кортежем префиксов для поиска. С опциональным аргументом start, проверка начинается с указанной позиции. С аргументом end, останавливает сравнение в той позиции.

Префикс(ы) для поиска могут быть любым байт-подобным объектом.

bytes.translate(table, delete=b'')
bytearray.translate(table, delete=b'')

Возвращает копию объекта bytes или bytearray, где все байты, встречающиеся в опциональном аргументе delete удалены, а оставшиеся байты сопоставлены через заданную таблицу перевода, которая должна быть байтовым объектом длинной 256.

Вы можете использовать метод bytes.maketrans() для создания таблицы перевода.

Установите аргумент table в None для перевода, который только удалит символы:

>>> b'read this short text'.translate(None, b'aeiou')
b'rd ths shrt txt'
Изменено в версии 3.6: delete теперь поддерживается как аргумент с ключевым словом.

Следующие методы объектов bytes и bytearray имеют поведение по умолчанию, которое предполагает использование ASCII совместимых двоичных форматов, но все еще могут быть использованы с произвольными двоичными данными путем передачи соответствующего аргумента. Заметьте, что все методы bytearray в этом разделе не действую на месте, а вместо этого создают новый объект.

bytes.center(width[, fillbyte])
bytearray.center(width[, fillbyte])

Возвращает копию объекта, отцентрированного в последовательности длинной width. Заполнение выполняется, используя указанный fillbyte (по умолчанию это пробел ASCII). Для объектов bytes возвращается исходная последовательность, если width меньше чем или равен len(s).

Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

bytes.ljust(width[, fillbyte])
bytearray.ljust(width[, fillbyte])

Возвращает копию объекта, выравненную по левому краю в последовательности длиной width. Заполнение выполняется с помощью указанного fillbyte (по умолчанию это пробел ASCII). Для объектов bytes возвращается исходная последовательность, если width меньше чем или равен len(s).

Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

bytes.lstrip([chars])
bytearray.lstrip([chars])

Возвращает копию последовательности, у которой удалены лидирующие байты, которые указаны. Аргумент chars - это двоичная последовательность, указывающая набор байтовых значений для удаления - имя ссылается на тот факт, что этот метод обычно используется с символами ASCII. Если опущен или None, аргумент chars по умолчанию удаляет пробелы ASCII. Аргумент chars не префикс; скорее, скорее удаляются все комбинации его значений:

>>> b'   spacious   '.lstrip()
b'spacious   '
>>> b'www.example.com'.lstrip(b'cmowz.')
b'example.com'
Двоичная последовательность байтовых значений для удаления может быть любым байт-подобным объектом.

Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

bytes.rjust(width[, fillbyte])
bytearray.rjust(width[, fillbyte])

Возвращает копию объекта, выравненную по правому краю в последовательности длиной width. Заполнение выполняется с помощью указанного fillbyte (по умолчанию это пробел ASCII). Для объектов bytes возвращается исходная последовательность, если width меньше чем или равен len(s).

Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

bytes.rsplit(sep=None, maxsplit=-1)
bytearray.rsplit(sep=None, maxsplit=-1)

Разделяет бинарную последовательность на подпоследовательности такого же типа, используя sep как разделитель строки. Если задан maxsplit, выполняется наибольшее разделений maxsplit, самых правых из них. Если sep не указан или None, любая последовательность, состоящая только из пробелов ASCII, является сепаратором. За исключением разделения справа, rsplit() ведет себя подобно split(), которая описана в деталях ниже.

bytes.rstrip([chars])
bytearray.rstrip([chars])

Возвращает копию последовательности, у которой удалены конечные байты, которые указаны. Аргумент chars - это двоичная последовательность, указывающая набор байтовых значений для удаления - имя ссылается на тот факт, что этот метод обычно используется с символами ASCII. Если опущен или None, аргумент chars по умолчанию удаляет пробелы ASCII. Аргумент chars не суффикс; скорее, скорее удаляются все комбинации его значений:

>>> b'   spacious   '.rstrip()
b'   spacious'
>>> b'mississippi'.rstrip(b'ipz')
b'mississ'
Двоичная последовательность байтовых значений для удаления может быть любым байт-подобным объектом.

Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

bytes.split(sep=None, maxsplit=-1)
bytearray.split(sep=None, maxsplit=-1)

Разделяет бинарную последовательность на подпоследовательности такого же типа, используя sep как разделитель строки. Если задан maxsplit и не отрицателен, выполняется наибольшее разделений maxsplit (таким образом, у списка будет самое большое maxsplit+1 элементов). Если maxsplit не указан или -1, то нет ограничений на количество разделений (все возможные будут сделаны).

Если задан sep, последовательные разделители не группируются вместе и считаются разделенными пустой подпоследовательностью (например, b'1,,2,.split(b',') возвращает [b'1', b'', b'2']). Аргумент sep может содержать многобайтовую последовательность (например, b'1<>2<>3'.split(b'<>') возвращает [b'1', b'2', b'3']). Разделение пустой последовательности с указанным сепаратором возвращает [b''] или [bytearray(b'')] в зависимости от типа разделяемого объекта. Аргумент sep может быть любым байт-подобным объектом.

Например:

>>> b'1,2,3'.split(b',')
[b'1', b'2', b'3']
>>> b'1,2,3'.split(b',', maxsplit=1)
[b'1', b'2,3']
>>> b'1,2,,3,'.split(b',')
[b'1', b'2', b'', b'3', b'']
Если sep не указан или равен None, применяется другой алгоритм разделения: пробеги последовательных пробелов ASCII рассматриваются как один разделитель, и результат не будет содержать пустых строк в начале и конце, если последовательность начиналась и заканчивалась пробелами. Следовательно, разделение пустой последовательности или последовательности, содержащей исключительно ASCII пробелы, без указанного сепаратора возвращает [].

Например:

>>> b'1 2 3'.split()
[b'1', b'2', b'3']
>>> b'1 2 3'.split(maxsplit=1)
[b'1', b'2 3']
>>> b'   1   2   3   '.split()
[b'1', b'2', b'3']
bytes.strip([chars])
bytearray.strip([chars])

Возвращает копию последовательности, у которой удалены впереди стоящие и конечные байты, которые указаны. Аргумент chars - это двоичная последовательность, указывающая набор байтовых значений для удаления - имя ссылается на тот факт, что этот метод обычно используется с символами ASCII. Если опущен или None, аргумент chars по умолчанию удаляет пробелы ASCII. Аргумент chars не суффикс; скорее, скорее удаляются все комбинации его значений:

>>> b'   spacious   '.strip()
b'spacious'
>>> b'www.example.com'.strip(b'cmowz.')
b'example'
Двоичная последовательность байтовых значений для удаления может быть любым байт-подобным объектом.

Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

Следующие методы для объектов bytes и bytearray предполагают использование совместимых с ASCII двоичных форматов и не должны применяться к случайным двоичным данным. Заметьте, что все методы bytearray в этом разделе не действуют на месте, вместо этого создают новый объект. 

bytes.capitalize()
bytearray.capitalize()

Возвращает копию последовательности, в которой каждый байт интерпретирован как символ ASCII, и первый байт капитализирован (написан с большой буквы), остальные - в нижнем регистре. Не-ASCII байты передаются без изменений.

Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

bytes.expandtabs(tabsize=8)
bytearray.expandtabs(tabsize=8)

Возвращает копию последовательности, где все символы табуляции ASCII заменены одним или более пробелами ASCII, в зависимости от текущего столбца и заданного размера табуляции. Позиции табуляции происходят каждый tabsize байтов (по умолчанию 8, передавая позицию табуляции к столбцам 0, 8, 16 и т. д.). Чтобы расширить последовательность, текущий столбец устанавливается в ноль и последовательность проверяется байт за байтом. Если байт является символом табуляции ASCII (b'\t'), один или более символов пробела вставляются в результат до тех пор, пока текущий столбец не станет равным следующей позиции табуляции. (Символ tab сам не копируется.) Если текущий байт является новой строкой ASCII (b'\n') или кареткой возврата (b'\r'), он копируется, и текущий столбец сбрасывается в ноль. Любое другое байтовое значение копируется без изменений и текущий столбец увеличивается на единицу независимо от того, как значение байта представляется при печати:

>>> b'01\t012\t0123\t01234'.expandtabs()
b'01      012     0123    01234'
>>> b'01\t012\t0123\t01234'.expandtabs(4)
b'01  012 0123    01234'
Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

bytes.isalnum()
bytearray.isalnum()

Возвращает истину, если все байты в последовательности являются алфавитными символами ASCII или десятичными цифрами ASCII и последовательность не пустая, в других случаях - ложь. Алфавитными символами ASCII являются те байтовые значения в последовательности b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'. Десятичными цифрами ASCII являются те байтовые значения в последовательности b'0123456789'.

Например:

>>> b'ABCabc1'.isalnum()
True
>>> b'ABC abc1'.isalnum()
False
bytes.isalpha()
bytearray.isalpha()

Возвращает истину, если все байты в последовательности являются алфавитными символами ASCII и последовательность не пустая, в других случаях - ложь. Алфавитными символами ASCII являются те байтовые значения в последовательности b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.

Например:

>>> b'ABCabc'.isalpha()
True
>>> b'ABCabc1'.isalpha()
False
bytes.isdigit()
bytearray.isdigit()

Возвращает истину, если все байты в последовательности являются десятичными цифрами ASCII и последовательность не пустая, в других случаях - ложь. Десятичными цифрами ASCII являются те байтовые значения в последовательности b'0123456789'.

Например:

>>> b'1234'.isdigit()
True
>>> b'1.23'.isdigit()
False
bytes.islower()
bytearray.islower()

Возвращает истину, если по крайней мере один символ ASCII в нижнем регистре есть в последовательности и нет символов ASCII в верхнем регистре, иначе - ложь.

Например:

>>> b'hello world'.islower()
True
>>> b'Hello world'.islower()
False
ASCII-символы нижнего регистра - это те, чьи байтовые значения в последовательности b'abcdefghijklmnopqrstuvwxyz'. ASCII-символы верхнего регистра - это те, чьи байтовые значения в последовательности b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. 

bytes.isspace()
bytearray.isspace()

Возвращает истину, если все байты в последовательности являются пустотами ASCII, и последовательность не пуста, иначе - ложь. Символами-пустотами являются байтовые значения в последовательности b' \t\n\r\x0b\f' (пробел, табуляция, новая строка, возврат каретки, вертикальная табуляция, форма подачи).

bytes.istitle()
bytearray.istitle()

Возвращает истину, если последовательность является заголовочной ASCII и не пуста, иначе - ложь. См. bytes.title() для более детальной информации определения "titlecase". 

Например:

>>> b'Hello World'.istitle()
True
>>> b'Hello world'.istitle()
False
bytes.isupper()
bytearray.isupper()

Возвращает истину, если есть хотя бы один символ ASCII в верхнем регистре и нет в нижнем, иначе - ложь.

Например:

>>> b'HELLO WORLD'.isupper()
True
>>> b'Hello world'.isupper()
False
ASCII-символы в нижнем регистре есть те, чьи байтовые значения в последовательности b'abcdefghijklmnopqrstuvwxyz'. В верхнем регистре - b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.

bytes.lower()
bytearray.lower()

Возвращает копию последовательности, в которой все символы ASCII в верхнем регистре преобразованы в их эквивалент в нижнем.

Например:

>>> b'Hello World'.lower()
b'hello world'
Символы ASCII в нижнем регистре те, чьи байтовые значения в последовательности b'abcdefghijklmnopqrstuvwxyz'. Символы ASCII в верхнем регистре являются теми, чьи байтовые значения в последовательности b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. 

Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

bytes.splitlines(keepends=False)
bytearray.splitlines(keepends=False)

Возвращает список линий в двоичной последовательности, разделенной границами линий ASCII. Для разделения строк этот метод использует подход universal newlines (docs.python.org/3/glossary.html#term-universal-newlines). Разрывы линий не включаются в результирующий список, пока не задан и является истиной keepends.

Например:

>>> b'ab c\n\nde fg\rkl\r\n'.splitlines()
[b'ab c', b'', b'de fg', b'kl']
>>> b'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)
[b'ab c\n', b'\n', b'de fg\r', b'kl\r\n']
В отличие от split(), когда задана строка-разделитель sep, этот метод возвращает пустой список для пустой строки, и завершающий разрыв строки не становится результатом в дополнительной линии:

>>> b"".split(b'\n'), b"Two lines\n".split(b'\n')
([b''], [b'Two lines', b''])
>>> b"".splitlines(), b"One line\n".splitlines()
([], [b'One line'])
bytes.swapcase()
bytearray.swapcase()

Возвращает копию строки, в которой все символы ASCII в верхнем регистре преобразованы в их соответствующий эквивалент в нижнем, и наоборот.

Например:

>>> b'Hello World'.swapcase()
b'hELLO wORLD'
Символы ASCII в нижнем регистре те, чьи байтовые значения в последовательности b'abcdefghijklmnopqrstuvwxyz'. Символы ASCII в верхнем регистре являются теми, чьи байтовые значения в последовательности b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. 

В отличие от str.swapcase() для бинарной версии всегда выполняется случай bin.swapcase().swapcase() == bin. Случаи преобразования являются симметричными в ASCII, хотя то не есть общая истина для произвольных точек кодов Unicode.

Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано. 

bytes.title()
bytearray.title()

Возвращает заголовочную версию двоичной последовательности, в которой слова начинаются с символа ASCII в верхнем регистре, а остальные символы - в нижнем. Безрегистровые байтовые значения остаются немодифицированными.

Например:

>>> b'Hello world'.title()
b'Hello World'
Символы ASCII в нижнем регистре те, чьи байтовые значения в последовательности b'abcdefghijklmnopqrstuvwxyz'. Символы ASCII в верхнем регистре являются теми, чьи байтовые значения в последовательности b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. 

Алгоритм использует простое независимое от языка определение слова как группы последовательных букв. Это определение работает во многих контекстах, но это значит, что апострофы в сокращениях и притяжательной форме слов являются границами, что может не быть желаемым результатом:

>>> b"they're bill's friends from the UK".title()
b"They'Re Bill'S Friends From The Uk"
Обходной путь для апострофов может быть создан путем использования регулярных выражений:

>>> import re
>>> def titlecase(s):
...     return re.sub(rb"[A-Za-z]+('[A-Za-z]+)?",
...                   lambda mo: mo.group(0)[0:1].upper() +
...                              mo.group(0)[1:].lower(),
...                   s)
...
>>> titlecase(b"they're bill's friends.")
b"They're Bill's Friends."
Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

bytes.upper()
bytearray.upper()

Возвращает копию последовательности, в которой все символы ASCII в нижнем регистре преобразованы в их соответствующий эквивалент в верхнем.

Например:

>>> b'Hello World'.upper()
b'HELLO WORLD'
Символы ASCII в нижнем регистре те, чьи байтовые значения в последовательности b'abcdefghijklmnopqrstuvwxyz'. Символы ASCII в верхнем регистре являются теми, чьи байтовые значения в последовательности b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. 

Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

bytes.zfill(width)
bytearray.zfill(width)

Возвращает копию последовательности, заполненную слева b'0' цифрами ASCII, чтобы сделать последовательность длинной width. Лидирующий знак префикса (b'+'/b'-') обрабатывается путем вставки заполнения скорее после символа знака, чем до него. Для объектов bytes, возвращается исходная последовательность, если width меньше чем или равна len(seq).

Например:

>>> b"42".zfill(5)
b'00042'
>>> b"-42".zfill(5)
b'-0042'
Замечание: bytearray версия этого метода не действует на месте - она всегда создает новый объект, даже если никаких изменений не было сделано.

4.8.4. Форматирование байтов в стиле printf
Замечание: Описанные здесь операции форматирования показывают разнообразие особенностей, которые приводят к ряду распространенных ошибок (таких как отказ корректного отображения кортежей и словарей). Если значение для печати может быть кортежем или словарем, оберните его в кортеж.

Объекты байтов (bytes/bytearray) имеют одну уникальную встроенную операцию: оператор % (модуль). Он также известен как оператор форматирования или вставки байтов. Заданный format % values (где format - это объект байтов), спецификации преобразования % в format заменяются на ноль или больше элементов в values. Эффект подобен использованию sprintf() в языке C.

Если format требует одиночный аргумент, value может быть одиночным некортежным элементом. [5] В других случаях value должен быть кортежем с точным количеством элементов, указанных форматным объектом байтов, или одиночным отображающимся объектом (например, словарем).

Спецификатор преобразования включает два или больше символов и имеет следующие компоненты, которые должны появляться в этом порядке:

Символ '%', который обозначает начало спецификатора.
Ключ отображения (необязательный), включающий последовательность символов в скобках (например, (somename)).
Флаги преобразования (опциональные), которые влияют на результат некоторых типов конверсии.
Минимальная ширина поля (опционально). Если указана как '*' (звездочка), фактическая ширина считывается из следующего элемента кортежа в values, и объект для преобразования приходит после минимальной ширины поля и точность не обязательна.
Точность (необязательно), заданная как '.' (точка), за которой следует точность. Если указана как '*' (звездочка), фактическая ширина считывается из следующего элемента кортежа в values, и объект для преобразования приходит после точности.
Длина модификатора (опционально).
Тип преобразования.
Когда правый аргумент является словарем (или другим типом отображения), то форматы в байтовых объектах должны включать заключенный в скобки ключ отображения в том словаре, вставленный сразу после символа %. Ключ отображения выбирает значение из отображения, которое должно быть отформатировано. Например:

>>> print(b'%(language)s has %(number)03d quote types.' %
...       {b'language': b"Python", b"number": 2})
b'Python has 002 quote types.'
В данном случае спецификаторы * могут отсутствовать в формате (поскольку они требуются к списку последовательных параметров).

Флаговыми символами преобразования являются:

Флаг	Значение
'#'	Преобразование значения будет использовать "альтернативную форму" (которая определена ниже).
'0'	Преобразование будет заполнено нулями для числовых значений.
'-'	Конвертируемое значение выравнивается по левому краю (переопределяет преобразование '0', если заданы оба).
' '	(пробел) Пропуску следует быть слева до положительного числа (или пустой строки), создаваемого преобразованием со знаком.
'+'	Символ знака ('+' или '-') будет предшествовать преобразованию (переопределяет флаг "пробел").
Может быть представлен модификатор длины (h, l, или L), но проигнорирован, так как в Python в этом нет необходимости - так, напр., %ld идентичен %d.

Типами преобразования являются:

Преобразование	Значение	Замечания
'd'	Знаковое целое десятичное число.	 
'i'	Знаковое целое десятичное число.	 
'o'	Знаковое восьмеричное значение.	(1)
'u'	Устаревший тип - идентичен 'd'.	(8)
'x'	Знаковое шестнадцатеричное (нижний регистр).	(2)
'X'	Знаковое шестнадцатеричное (верхний регистр).	(2)
'e'	Экспоненциальный формат числа с плавающей точкой (нижний регистр).	(3)
'E'	Экспоненциальный формат числа с плавающей точкой (верхний регистр).	(3)
'f'	Десятичный формат числа с плавающей точкой.	(3)
'F'	Десятичный формат числа с плавающей точкой.	(3)
'g'	Формат числа с плавающей точкой. Использует нижнерегистровый экспоненциальный формат, если показатель меньше чем -4 или не меньше чем точность, в других случаях - десятичный формат. 	(4)
'G'	Формат числа с плавающей точкой. Использует верхнерегистровый экспоненциальный формат, если показатель меньше чем -4 или не меньше чем точность, в других случаях - десятичный формат. 	(4)
'c'	Одиночный байт (принимает целые или объекты из одного байта).	 
'b'	Байты (любой объект, который следует buffer protocol (docs.python.org/3/c-api/buffer.html#bufferobjects) или имеет __bytes__() (docs.python.org/3/reference/datamodel.html#object.__bytes__)).	(5)
's'	's' есть псевдоним для 'b' и его следует использовать только для кодовой основы Python2/3.	(6)
'a'	Байты (конвертирует любой объект Python, используя repr(obj).encode('ascii', 'backslashreplace')).	(5)
'r'	'r' есть псевдоним для 'a' и его следует использовать только для кодовой основы Python2/3.	(7)
'%'	Аргумент не преобразован, в итоге получается символ % в результате.	 
Замечания:

Альтернативная форма приводит к лидирующему восьмеричному спецификатору ('0o'), который вставляется перед первой цифрой.
Альтернативная форма приводит к лидирующим '0x' или '0X' (в зависимости от того, используется ли формат 'x' или 'X'), который вставляется перед первой цифрой.
Альтернативная форма приводит к результату, который всегда содержит десятичную точку, даже если за ней нет цифр.
Точность определяет число цифр после десятичной точки и по умолчанию приравнивается к 6.
Альтернативная форма приводит к результату, который всегда содержит десятичную точку, и завершающие нули не удаляются, как бы это было в других случаях.
Точность определяется числом значащих цифр перед и после десятичной точки и по умолчанию равно 6.
Если точность есть N, вывод усекается до N символов.
b'%s' является устаревшим, но не будет удален в версиях 3.x.
b'%r' является устаревшим, но не будет удален в версиях 3.x.
См. Pep 237 (www.python.org/dev/peps/pep-0237).
Замечание: bytearray версия этого метода не действует на месте - она всегда производит новый объект, даже если никаких изменений не было сделано. 

См. также: PEP 461 (www.python.org/dev/peps/pep-0461). 

Новое в версии 3.5.

4.8.5. Просмотры памяти
Объекты memoryview позволяют коду получить доступ к внутренним данным объекта, который поддерживает buffer protocol (docs.python.org/3/c-api/buffer.html#bufferobjects) без копирования.

class memoryview(obj)

Создает memoryview, который ссылается на obj. obj должен поддерживать буферный протокол. Встроенные объекты, поддерживающие такой протокол, включают bytes и bytearray.

У memoryview есть понятие элемента, который представляет собой элементарную единицу памяти, обрабатываемую исходным объектом obj. 

Для многих простых типов, таких как bytes и bytearray, элемент - это одиночный байт, но другие типы, такие как array.array (docs.python.org/3/library/array.html#array.array), могут иметь большие элементы.

len(view) равен длине tolist. Если view.ndim = 0, длина равна 1. Если view.ndim = 1, длина равна числу элементов во view. Для более высоких размеров длина равна длине вложенного спискового представления view. Атрибут itemsize даст вам число байтов в одиночном элементе. 

Memoryview поддерживает взятие среза и индексирование для отображения своих данных. Одномерный срез даст в результате подвью:

>>> v = memoryview(b'abcefg')
>>> v[1]
98
>>> v[-1]
103
>>> v[1:4]
<memory at 0x7f3ddc9f4350>
>>> bytes(v[1:4])
b'bce'
Если format является одним из нативных спецификаторов формата из модуля struct (docs.python.org/3/library/struct.html#module-struct), индексирование с помощью целого числа или кортежа целых чисел поддерживается также и возвращает одиночный элемент корректного типа. Одномерные memoryviews могут быть индексированы с помощью целого числа или кортежа из одного числа. Многомерные memoryviews могут быть индексированы с помощью кортежей точных целых ndim, где ndim есть количество измерений. Нуль-мерные memoryviews могут быть индексированы пустым кортежем.

Здесь примеры с небайтными форматами:

>>> import array
>>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])
>>> m = memoryview(a)
>>> m[0]
-11111111
>>> m[-1]
44444444
>>> m[::2].tolist()
[-11111111, -33333333]
Если лежащий в основе объект доступен для записи, memoryview поддерживает назначение одномерного среза. Изменение размера не разрешено:

>>> data = bytearray(b'abcefg')
>>> v = memoryview(data)
>>> v.readonly
False
>>> v[0] = ord(b'z')
>>> data
bytearray(b'zbcefg')
>>> v[1:4] = b'123'
>>> data
bytearray(b'z123fg')
>>> v[2:3] = b'spam'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: memoryview assignment: lvalue and rvalue have different structures
>>> v[2:6] = b'spam'
>>> data
bytearray(b'z1spam')
Одномерные memoryviews хэшируемых типов с форматами 'B', 'b' или 'c' также являются хэшируемыми. Хэш определяется как hash(m) == hash(m.tobytes()):

>>> v = memoryview(b'abcefg')
>>> hash(v) == hash(b'abcefg')
True
>>> hash(v[2:4]) == hash(b'ce')
True
>>> hash(v[::-2]) == hash(b'abcefg'[::-2])
True
Изменено в версии 3.3: Из одномерных memoryview можно теперь брать срез. Одномерные memoryviews с форматами 'B', 'b' или 'c' являются теперь хэшируемыми. 

Изменено в версии 3.4: Теперь memoryview регистрируется автоматически с помощью collections.abc.Sequence (docs.python.org/3/library/collections.abc.html#collections.abc.Sequence).

Изменено в версии 3.5: memoryviews могут теперь быть индексированы кортежем целых чисел.

memoryviews имеет несколько методов:

__eq__(exporter)

memoryview и поставщик PEP 3118 (www.python.org/dev/peps/pep-3118) являются равными, если их формы эквивалентны и если все соответствующие значения равны, когда коды соответствующих форматов операндов интерпретируются с помощь синтаксиса struct (docs.python.org/3/library/struct.html#module-struct).

Для подмножества строк формата struct, поддерживаемых в настоящее время tolist, v и w являются равными, если v.tolist() == w.tolist():

>>> import array
>>> a = array.array('I', [1, 2, 3, 4, 5])
>>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])
>>> c = array.array('b', [5, 3, 1])
>>> x = memoryview(a)
>>> y = memoryview(b)
>>> x == a == y == b
True
>>> x.tolist() == a.tolist() == y.tolist() == b.tolist()
True
>>> z = y[::-2]
>>> z == c
True
>>> z.tolist() == c.tolist()
True
Если какой-либо формат строки не поддерживается модулем struct, то объекты всегда будут сравниваться как неравные (даже если формат строк и буферное содержимое идентичны):

>>> from ctypes import BigEndianStructure, c_long
>>> class BEPoint(BigEndianStructure):
...     _fields_ = [("x", c_long), ("y", c_long)]
...
>>> point = BEPoint(100, 200)
>>> a = memoryview(point)
>>> b = memoryview(point)
>>> a == point
False
>>> a == b
False
Отметьте что, как и с числами с плавающей точкой, v is w не подразумевает v == w для объектов memoryview.

Изменено в версии 3.3: Предыдущие версии сравнивали строки памяти, игнорируя формат элементов и логическую структуру массива.

tobytes()

Возвращает данные в буфере как байтовую строку. Эквивалентно вызову конструктора bytes для memoryview.

>>> m = memoryview(b"abc")
>>> m.tobytes()
b'abc'
>>> bytes(m)
b'abc'
Для независимых массивов результат равен выравненному списковому представлению со всеми элементами, конвертированными в байты. tobytes() поддерживает все форматы строк, включая те, что не в синтаксисе модуля struct (docs.python.org/3/library/struct.html#module-struct).

hex()

Возвращает строковый объект, включающий по две шестнадцатеричные цифры для каждого байта в буфере.

>>> m = memoryview(b"abc")
>>> m.hex()
'616263'
Новое в версии 3.5.

tolist()

Возвращает данные в буфере как список элементов.

>>> memoryview(b'abc').tolist()
[97, 98, 99]
>>> import array
>>> a = array.array('d', [1.1, 2.2, 3.3])
>>> m = memoryview(a)
>>> m.tolist()
[1.1, 2.2, 3.3]
Изменено в версии 3.3: tolist() теперь поддерживает все одиночные символы нативных форматов в синтаксисе модуля struct (docs.python.org/3/library/struct.html#module-struct), также как многомерные представления.

release()

Освобождает лежащий в основе буфер, выставленный объектом memoryview. Многие объекты предпринимают специальные действия, когда на них проводится просмотр (например, bytearray временно запрещает изменение размера); поэтому вызов release() удобно для удаление этих ограничений (и освобождения любых висящих ресурсов) так быстро, как возможно.

После того как данный метод был вызван, любая дальнейшая операция над view возбуждает ValueError (за исключением самого release(), который может быть вызван множество раз):

>>> m = memoryview(b'abc')
>>> m.release()
>>> m[0]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: operation forbidden on released memoryview object
Протокол контекстного управления может быть использован для подобных эффектов, используя оператор with:

>>> with memoryview(b'abc') as m:
...     m[0]
...
97
>>> m[0]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: operation forbidden on released memoryview object
Новое в версии 3.2.

cast(format[, shape])

Перебрасывает memoryview в новый формат или форму. shape по умолчанию [byte_length//new_itemsize], обозначает, что результирующий view будет одномерным. Значение результата - это новый memoryview, но сам буфер не копируется. Поддерживаемыми бросками являются 1D -> C-contiguous (docs.python.org/3/glossary.html#term-contiguous) и C-contiguous -> 1D.

Формат назначения сокращается к нативному формату одиночного элемента в синтаксисе struct (docs.python.org/3/library/struct.html#module-struct). Один из форматов должен быть байтовым ('B', 'b' или 'c'). Длина байта результата должна быть такой же как оригинальная длина.

Переброс 1D/long к 1D/unsigned байтам:

>>> import array
>>> a = array.array('l', [1,2,3])
>>> x = memoryview(a)
>>> x.format
'l'
>>> x.itemsize
8
>>> len(x)
3
>>> x.nbytes
24
>>> y = x.cast('B')
>>> y.format
'B'
>>> y.itemsize
1
>>> len(y)
24
>>> y.nbytes
24
Переброс 1D/unsigned байтов к 1D/long:

>>> b = bytearray(b'zyz')
>>> x = memoryview(b)
>>> x[0] = b'a'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: memoryview: invalid value for format "B"
>>> y = x.cast('c')
>>> y[0] = b'a'
>>> b
bytearray(b'ayz')
Переброс 1D/bytes к 3D/ints к 1D/signed char (символ):

>>> import struct
>>> buf = struct.pack("i"*12, *list(range(12)))
>>> x = memoryview(buf)
>>> y = x.cast('i', shape=[2,2,3])
>>> y.tolist()
[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
>>> y.format
'i'
>>> y.itemsize
4
>>> len(y)
2
>>> y.nbytes
48
>>> z = y.cast('b')
>>> z.format
'b'
>>> z.itemsize
1
>>> len(z)
48
>>> z.nbytes
48
Переброс 1D/unsigned char к 2D/unsigned long:

>>> buf = struct.pack("L"*6, *list(range(6)))
>>> x = memoryview(buf)
>>> y = x.cast('L', shape=[2,3])
>>> len(y)
2
>>> y.nbytes
48
>>> y.tolist()
[[0, 1, 2], [3, 4, 5]]
Новое в версии 3.3.

Изменено в версии 3.5: Формат источника уже больше не ограничивается, когда перебрасывается к байтовому view.

Также есть несколько атрибутов, доступных только для чтения:

obj

Лежащий в основе меморивью объект:

>>> b  = bytearray(b'xyz')
>>> m = memoryview(b)
>>> m.obj is b
True
Новое в версии 3.3.

nbytes

nbytes == product(shape) * itemsize == len(m.tobytes()). Это количество пространства в байтах, которые массив бы использовал в связанном представлении. Это не обязательно равно len(m):

>>> import array
>>> a = array.array('i', [1,2,3,4,5])
>>> m = memoryview(a)
>>> len(m)
5
>>> m.nbytes
20
>>> y = m[::2]
>>> len(y)
3
>>> y.nbytes
12
>>> len(y.tobytes())
12
Многомерные массивы:

>>> import struct
>>> buf = struct.pack("d"*12, *[1.5*x for x in range(12)])
>>> x = memoryview(buf)
>>> y = x.cast('d', shape=[3,4])
>>> y.tolist()
[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]
>>> len(y)
3
>>> y.nbytes
96
Новое в версии 3.3.

readonly

Логическое, указывающее является ли память только для чтения.

format

Строка, содержащая формат (в стиле модуля struct (docs.python.org/3/library/struct.html#module-struct)) для каждого элемента в view. memoryview может быть создан из поставщиков произвольного формата строк, но некоторые методы (напр., tolist()) ограничиваются к нативным форматам одиночного элемента.

Изменено в версии 3.3: формат 'B' теперь обрабатывается согласно синтаксису модуля struct. Это значит, что memoryview(b'abc')[0] = b'abc'[0] == 97.

itemsize

Размер в байтах каждого элемента меморивью:

>>> import array, struct
>>> m = memoryview(array.array('H', [32000, 32001, 32002]))
>>> m.itemsize
2
>>> m[0]
32000
>>> struct.calcsize('H') == m.itemsize
True
ndim

Целое, указывающее, как много разрешений многомерного массива представляет память.

shape

Кортеж целых длины ndim, задающий форму памяти как N-мерный массив.

Изменено в версии 3.3: Пустой кортеж вместо None, когда ndim = 0.

strides

Кортеж целых чисел длинной ndim, задающий размер в байтах для доступа каждого элемента к каждой величине массива.

Изменено в версии 3.3: Пустой кортеж вместо None, когда ndim = 0.

suboffsets

Внутренне используемый для массивов в PIL-стиле. Значение является только информационным.

c_contiguous

Логическое, указывающее является ли память C-contiguous (docs.python.org/3/glossary.html#term-contiguous).

Новое в версии 3.3.

f_contiguous

Логическое, указывающее является ли память Fortran contiguous (docs.python.org/3/glossary.html#term-contiguous).

Новое в версии 3.3.

contiguous

Логическое, указывающее является ли память contiguous (docs.python.org/3/glossary.html#term-contiguous).

Новое в версии 3.3.

4.9. Типы множеств - set, frozenset
Объект set (множество) является неупорядоченной коллекцией отдельных хэшируемых (docs.python.org/3/glossary.html#term-hashable) объектов. Обычное использование включает проверку членства, удаление повторов из последовательности и вычисление математических операций таких как пересечение, объединение, разность и симметричная разница. (Для других контейнеров см. встроенные классы dict, list и tuple, а также модуль collections (docs.python.org/3/library/collections.html#module-collections).)

Как и другие коллекции множества поддерживают x in set, len(set) и for x in set. Будучи неупорядоченными коллекциями, множества не регистрируют позицию элемента или порядок вставки. Таким образом, множества не поддерживают индексирование, взятие среза или другое подобное последовательностям поведение.

В настоящее время есть два встроенных типа множеств, set и frozenset. Тип set изменяем - содержимое может быть изменено с помощью методов подобных add() и remove(). Поскольку оно изменяемо, то не имеет хэш-значения и не может быть использовано ни в качестве словарного ключа, ни как элемент другого множества. Тип frozenset неизменяемый и хэшируемый - его содержимое не может быть изменено после его создания; поэтому он может использоваться в качестве ключа словаря или как элемент другого множества.

Непустое множество (не frozenset) может быть создано размещением разделенного запятыми списка элементов в фигурных скобках, например: {'jack', 'sjoerd'}, в дополнение к конструктору set. 

Конструкторы для обоих классов работают одинаково:

class set([iterable])
class frozenset([iterable])

Возвращает новый объект set или frozenset, чьи элементы берутся из iterable. Элементы множества должны быть хэшируемыми. Для представления множеств из множеств, внутренние множества должны быть объектами frozenset. Если iterable не указан, возвращается новое пустое множество.

Экземпляры set и frozenset предоставляют следующие операции:

len(s)

Возвращает количество элементов в множестве s (мощность s).

x in s

Проверяет x на членство в s.

x not in s

Проверяет x на нечленство в s.

isdisjoint(other)

Возвращает True, если множество не имеет общих элементов с other. Множества являются непересекающимися, если и только если их пересечение есть пустое множество.

issubset(other)
set <= other

Проверяет, есть ли каждый элемент множества в other.

set < other

Проверяет, является ли множество правильным подмножеством для other, т. е. set <= other and set != other.

issuperset(other)
set >= other

Проверяет, есть ли каждый элемент из other в set.

set > other

Проверяет, является ли множество правильным супермножеством для other, т. е. set >= other and set != other.

union(*others)
set | other | ...

Возвращает новое множество с элементами из самого множества и всех others.

intersection(*others)
set & other & ...

Возвращает новое множество с общими элементами самого множества и всех других.

difference(*others)
set - other -  ...

Возвращает новое множество с элементами в самом множестве, которых нет в других.

symmetric_difference(other)
set ^ other

Возвращает новое множество с элементами, которые есть либо в самом множестве или в other, но не в обоих.

copy()

Возвращает новое множество с поверхностной копией s.

Заметьте, неоператорные версии методов union(), intersection(), difference(), symmetric_difference(), issubset() и issuperset() примут любую итерацию в качестве аргумента. В противоположность их основанный на операторе двойник требует, чтобы их аргументы были множествами. Это исключает предрасположенные к ошибкам конструкции подобные set('abc') & 'cbs' в пользу наиболее читаемых set('abc').intersection('cbs').

Оба set и frozenset поддерживают сравнение множества со множеством. Два множества равны, если и только если каждый элемент каждого множества содержится в другом (каждое есть подмножество другого). Множество меньше, чем другое множество, если и только если первое множество есть правильное подмножество второго множества (является подмножеством, но не равно). Множество больше, чем другое множество, если и только если первое множество есть правильное супермножество для второго множества (является супермножеством, но не равно).

Экземпляры set сравнимы с экземплярами frozenset, основанными на их членах. Например, set('abc') == frozenset('abc') возвращает True и также делает set('abc') in set([frozenset('abc')]).

Сравнение подмножества и равенства не обобщается на общую функцию упорядочения. Например, любые два непустых непересекающихся множества не равны и не подмножества друг друга, так что все следующее возвращает False: a<b , a==b или a>b.

Поскольку множества определяют только частичное упорядочивание (отношение подмножеств), вывод метода list.sort() не определен для списков множеств.

Элементы множества, подобные ключам словаря, должны быть хэшируемыми (docs.python.org/3/glossary.html#term-hashable). 

Двоичные операции, которые смешивают экземпляры set с frozenset возвращают тип первого операнда. Например: frozenset('ab') | set('bc') возвращает экземпляр frozenset.

Ниже перечисляются операции, доступные для set, но которые не применяются к неизменяемым экземплярам frozenset:

update(*others)
set |= other | ...

Обновляет множество, добавляя элементы из всех других.

intersection_update(*others)
set &= other & ...

Обновляет множество, сохраняя только элементы, найденные в нем и всех других.

difference_update(*others)
set -= other | ...

Обновляет множество, удаляя элементы, найденные в других.

symmetric_difference_update(other)
set ^= other

Обновляет множество, сохраняя элементы, найденные в любом множестве, но не в обоих.

add(elem)

Добавляет элемент elem во множество.

remove(elem)

Удаляет элемент elem из множества. Возбуждает KeyError (docs.python.org/3/library/exceptions.html#KeyError), если elem не содержится в множестве.

discard(elem)

Удаляет элемент elem из множества, если он присутствует.

pop()

Удаляет и возвращает произвольный элемент из множества. Возбуждает KeyError в случае пустого множества.

clear()

Удаляет из множества все элементы.

Заметьте, неоператорная версия методов update(), intersection_update(), difference_update() и symmetric_difference_update() примет любую итерацию как аргумент.

Также, аргумент elem в методах __contains__(), remove() и discard() может быть множеством. Для поддержки поиска эквивалентного frozenet, создается временный из elem.

4.10. Типы отображений - dict
Объекты отображений (docs.python.org/3/glossary.html#term-mapping) отображают хэшируемые (docs.python.org/3/glossary.html#term-hashable) значения на произвольные объекты. Отображения - изменяемые объекты. В настоящее время есть только один стандартный тип отображения - словарь. (По другим контейнерам см. встроенные классы list, set и tuple, а также модуль collections (docs.python.org/3/library/collections.html#module-collections).)

Ключи словарей - почти произвольные значения. Значения, которые не являются хэшируемыми, такие как значения, содержащие списки, словари или другие изменяемые типы (которые сравниваются скорее по значению, чем по объектной идентичности) не могут быть использованы в качестве ключей. Используемые для ключей числовые типы подчиняются обычным правилам для числовых сравнений: если два числа сравнимо равны (как 1 и 1.0), то они могут быть использованы взаимозаменяемо, чтобы указать на одну и ту же запись словаря. (Однако заметьте, что, поскольку компьютеры хранят числа с плавающей точкой как приближения, обычно неблагоразумно использовать их как ключи словарей.)

Словари могут быть созданы размещением разделенного запятыми списка пар key: value внутри фигурных скобок, например: {'jack': 4098, 'sjoerd': 4127} или {4098: 'jack', 4127: 'sjoerd'} или конструктором dict.

class dict(**kwarg)
class dict(mapping, **kwarg)
class dict(iterable, **kwarg)

Возвращает пустой словарь, инициализированный из опционального позиционного аргумента и возможно пустым набором аргументов с ключевым словом.

Если позиционный аргумент не задан, создается пустой словарь. Если позиционный аргумент задан, и это объект отображения, словарь создается с такими же парами ключ-значение как объект отображения. В других случаях, позиционный аргумент должен быть итерируемым (docs.python.org/3/glossary.html#term-iterable) объектом. Каждый элемент в итерации сам должен быть итерацией с точно двумя объектами. Первый объект каждого элемента становится ключом в новом словаре, а второй объект - соответствующим значением. Если ключ случается больше одного раза, последнее значение для ключа становится соответствующим значением в новом словаре.

Если аргументы с ключевыми словами заданы, они и их значения добавляются в словарь, создаваемый из позиционных аргументов. Если добавляемый ключ уже присутствует, значение из аргумента с ключевым словом заменяет значение из позиционного аргумента.

Чтобы проиллюстрировать, все следующие примеры возвращают одинаковый словарь {"one": 1, "two": 2, "three": 3}:

>>> a = dict(one=1, two=2, three=3)
>>> b = {'one': 1, 'two': 2, 'three': 3}
>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
>>> d = dict([('two', 2), ('one', 1), ('three', 3)])
>>> e = dict({'three': 3, 'one': 1, 'two': 2})
>>> a == b == c == d == e
True
Предоставление аргументов с ключевым словом как в первом примере работает только для ключей, которые являются допустимыми идентификаторами Python. В остальных случаях могут быть использованы любые валидные ключи.

Существуют операции, поддерживаемые словарями (а следовательно также должны поддерживаться пользовательскими типами отображений):

len(d)

Возвращает количество элементов в словаре d.

d[key]

Возвращает элемент d с ключом key. Возбуждает KeyError (docs.python.org/3/library/exceptions.html#KeyError), если key отсутствует в отображении.

Если подкласс словаря определяет метод __missing__() (docs.python.org/3/reference/datamodel.html#object.__missing__) и key не представлен, операция d[key] вызывает тот метод с ключом key в качестве аргумента. Других методов или операций, запускающих __missing__() нет. Если __missing__() не определен, возбуждается KeyError. __missing__() должен быть методом; он не может быть экземпляром переменной:

>>> class Counter(dict):
...     def __missing__(self, key):
...         return 0
>>> c = Counter()
>>> c['red']
0
>>> c['red'] += 1
>>> c['red']
1
Пример выше показывает часть реализации collections.Counter (docs.python.org/3/library/collections.html#collections.Counter). Другой метод __missing__ используется collections.defaultdict (docs.python.org/3/library/collections.html#collections.defaultdict).

d[key] = value

Устанавливает d[key] в value.

del d[key]

Удаляет d[key] из d. Возбуждает KeyError, если key отсутствует в отображении.

key in d

Возвращает True, если d имеет ключ key, иначе False.

key not in d

Эквивалентно not key in d.

iter(d)

Возвращает итератор по ключам словаря. Это сокращение для iter(d.keys()).

clear()

Удаляет все элементы из словаря.

copy()

Возвращает поверхностную копию словаря.

classmethod fromkeys(seq[, value])

Создает новый словарь с ключами из seq и значения устанавливает в value.

get(key[, default])

Возвращает значение для key, если key есть в словаре, иначе default. Если default не задан, то он по умолчанию None, так что этот метод никогда не возбуждает KeyError.

items()

Возвращает новый вид элементов словаря (пар (key, value)). См. Объекты просмотра словаря.

keys()

Возвращает новый вью ключей словаря. См. Объекты просмотра словаря.

pop(key[, default])

Если key есть в словаре, удаляет его и возвращает его значение, иначе возвращает default. Если default не задан и key в словаре отсутствует, возбуждает KeyError (docs.python.org/3/library/exceptions.html#KeyError).

popitem()

Удаляет и возвращает произвольную пару (key, value) из словаря.

popitem() полезен для разрушающей итерации по словарю, как часто используемый в ряде алгоритмов. Если словарь пустой, вызов popitem() возбужедает KeyError.

setdefault(key[, default])

Если key есть в словаре, возвращает его значение. Если нет, вставляет key со значением default и возвращает default. default по умолчанию устанавливается в None.

update([other])

Обновляет словарь парами ключ/значение из other, перезаписывая существующие ключи. Возвращает None.

update() принимает либо другой объект словаря, либо итерацию пар ключ/значение (как кортеж или другие итерации длинной два). Если указаны аргументы с ключевым словом, то словарь обновляется этими парами ключ/значение: d.update(red=1, blue=2).

values()

Возвращает новый вью значений словаря. См. Объекты просмотра словаря.

Словари сравнимо равны, если и только если они имеют одинаковые пары (key, value). Порядковые сравнения ('<', '<=', '>=', '>') возбуждают TypeError (docs.python.org/3/library/exceptions.html#TypeError).

См. также: types.MappingProxyType (docs.python.org/3/library/types.html#types.MappingProxyType) может быть использован для создания вида dict только для чтения.

4.10.1. Объекты просмотра словаря
Объекты, возвращаемые dict.keys(), dict.values() и dict.items(), являются view objects. Они предоставляют динамический просмотр по записям словаря, который обозначает, что когда словарь изменяется, вью отображает эти изменения.

Просмотры словаря могут быть проитерированы для получения их данных и поддерживают проверки на членство:

len(dictview)

Возвращает количество записей в словаре.

item(dictview)

Возвращает итератор по ключам, значениям или элементам (представленный как кортеж (key, value)) в словаре.

Итерация по ключам и значениям производится в произвольном порядке, который неслучайный, меняется в зависимости от реализации Python и зависит от истории вставок и удалений в словаре. Если ключи, значения и элементы просмотров итерируются без промежуточных изменений в словаре, порядок элементов будет прямо соответствовать. Это позволяет создавать пары (value, key), используя zip(): pairs = zip(d.values(), d.keys()). Другой способ создать тот же список есть pairs = [(v, k) for (k, v) in d.items()].

Итерация по просмотрам во время добавления или удаления записей в словарь может возбуждать RuntimeError (docs.python.org/3/library/exceptions.html#RuntimeError) или привести к неудаче при итерации по всем записям.

x in dictview

Возвращает True, если x есть в лежащих в основе ключах словаря, его значениях или элементах (в последнем случае, x должен быть кортежем (key, value)).

Просмотры ключей подобны множествам, поскольку их записи являются уникальными и хэшируемыми. Если все значения хэшируемые так, что пары (key, value) уникальны и хэшируемы, то элементы просмотра также подобны множествам. (Просмотры значений не относятся к подобным множествам, т. к. записи обычно не уникальны.) Для просмотров, подобных множествам, доступны все операции, определенные для абстрактного базового класса collections.abc.Set (docs.python.org/3/library/collections.abc.html#collections.abc.Set) (например, ==, < или ^).

Пример использования просмотра словаря:

>>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}
>>> keys = dishes.keys()
>>> values = dishes.values()

>>> # iteration
>>> n = 0
>>> for val in values:
...     n += val
>>> print(n)
504

>>> # keys and values are iterated over in the same order
>>> list(keys)
['eggs', 'bacon', 'sausage', 'spam']
>>> list(values)
[2, 1, 1, 500]

>>> # view objects are dynamic and reflect dict changes
>>> del dishes['eggs']
>>> del dishes['sausage']
>>> list(keys)
['spam', 'bacon']

>>> # set operations
>>> keys & {'eggs', 'bacon', 'salad'}
{'bacon'}
>>> keys ^ {'sausage', 'juice'}
{'juice', 'sausage', 'bacon', 'spam'}
4.11. Типы контекстного менеджера
Оператор with (docs.python.org/3/reference/compound_stmts.html#with) Python'а поддерживает концепцию динамического контекста, определенную контекстным менеджером. Это реализуется с помощью пары методов, которые позволяют определенным пользователем классам определять динамический контекст, который вводится перед тем, как тело заявления выполняется, и завершается, когда заявление заканчивается:

contextmanager.__enter__()

Вводит динамический контекст и возвращает либо этот объект, либо другой объект, связанный с этим контекстом. Возвращаемое этим методом значение связано с идентификатором в пункте as заявления with, использующего данный контекстный менеджер.

Примером контекстного менеджера, который возвращает сам себя, является объект файла (docs.python.org/3/glossary.html#term-file-object). Файловые объекты возвращают себя из __enter__(), чтобы дать возможность open() быть использованной в качестве контекстного выражения в операторе with.

Примером контекстного менеджера, возвращающего связанный объект, является тот, который возвращается от decimal.localcontext() (docs.python.org/3/library/decimal.html#decimal.localcontext). Эти менеджеры устанавливают активный десятичный контекст в копию исходного десятичного контекста, а затем возвращают копию. Это позволяет внести изменения в текущий десятичный контекст в теле оператора with, не затрагивая код вне оператора with.

contextmanager.__exit__(exc_type, exc_val, exc_tb)

Выходит из контекста среды выполнения и возвращает логический флаг, указывающий, должно ли быть подавлено какое-либо исключение. Если исключение произошло, пока выполнялось тело оператора with, аргументы содержат тип этого исключения, значение и информацию трассировки. В других случаях, все три аргумента - None.

Возвращение истинного значения из этого метода будет приводить оператор with к подавлению исключения и продолжению выполнения с оператором сразу следующим за with. В иных случаях исключение продолжает распространяться после того, как этот метод закончит выполнение. Исключения, которые происходят во время выполнения этого метода, будут заменены любым исключением, которое произошло в теле оператора with.

Переданное исключение не должно вызываться снова явно - вместо этого методу следует вернуть ложное значение, указывающее, какой метод успешно завершился и не хочет подавлять возбужденное исключение. Это позволят контекстному управляющему коду легче определить, был ли метод __exit__() действительно неудавшимся.

Python определяет несколько контекстных менеджеров для поддержки легкой синхронизации потоков, своевременного завершения файлов и других объектов и более простой манипуляции над действительным десятичным арифметическим контекстом. Конкретные типы не обрабатываются специально за пределами их реализации протокола управления контекстом. См. модуль contextlib (docs.python.org/3/library/contextlib.html#module-contextlib) для нескольких примеров.

Генераторы (docs.python.org/3/glossary.html#term-generator) и декоратор contextlib.contextmanager (docs.python.org/3/library/contextlib.html#contextlib.contextmanager) Python предоставляют удобный способ реализовать эти протоколы. Если функция генератора декорирована декоратором contextlib.contextmanager, она вернет контекстный менеджер, реализующий необходимые методы __enter__() (docs.python.org/3/reference/datamodel.html#object.__enter__) и __exit__() (docs.python.org/3/reference/datamodel.html#object.__exit__), а не итератор, созданный недекорированной функцией генератора.

Отметим, что нет конкретного слота для любых этих методов в структуре типа для объектов Python в API Python/C. Типы расширений, желающие определить эти методы, должны обеспечивать их как обычный доступный для метода Python. По сравнению с накладными расходами на настройку динамического контекста накладные расходы на поиск одного словаря классов незначительны.

4.12. Другие встроенные типы
Интерпретатор поддерживает несколько других видов объектов. Большинство из них поддерживает только одну или две операции.

4.12.1. Модули
Единственной специальной операцией над модулем является доступ к атрибутам: m.name, где m - модуль, а name получает доступ к имени, определенном в таблице обозначений у m. К атрибутам модуля может выполняться присвоение. (Заметьте, что, строго говоря, заявление import не операция над объектом модуля; import foo не требует объекта модуля, названного foo, для существования, а требует (внешнего) определения для модуля, названного foo, где-нибудь.)

Специальным атрибутом для каждого модуля является __dict__. Это словарь, содержащий таблицу обозначений модуля. Изменение этого словаря в действительности изменит таблицу имен модуля, но прямое назначение атрибутам __dict__ невозможно (вы можете написать m.__dict__['a'] = 1, что определяет m.a быть равным 1, но вы не можете написать m.__dict__= {}. Прямое изменение __dict__ не рекомендуется.

Модули, встроенные в интерпретатор, написаны подобно этому: <module 'sys' (built-in)>. Если загружены из файла, они записаны как <module 'os' from '/usr/local/lib/pthonX.Y/os.pyc'>.

4.12.2. Классы и экземпляры класса
См. Objects, values and types (docs.python.org/3/reference/datamodel.html#objects) и Class definitions (docs.python.org/3/reference/compound_stmts.html#class).

4.12.3. Функции
Объекты функций создаются определениями функций. Единственной операцией над объектом-функцией является ее вызов: func(argument-list).

В действительности существуют две разновидности функциональных объектов: встроенные и определяемые пользователем функции. Обе поддерживают одну и ту же операцию (вызов функции), но реализация различна, отсюда и различные типы объекта.

Для дополнительной информации см. Определения функций (docs.python.org/3/reference/compound_stmts.html#function).

4.12.4. Методы
Методы являются функциями, которые вызываются с помощью атрибутной нотации. Есть две разновидности: встроенные методы (такой как append() для списков) и методы класса экземпляра. Встроенные методы описываются типами, которые их поддерживают.

Если вы получаете доступ к методу (функции, определенной в пространстве имен класса) через экземпляр, вы получаете специальный объект: связанный метод (также называемый методом экземпляра) объекта. При вызове будет добавлен аргумент self к списку аргументов. У связанных методов имеется два только для чтения атрибута: m.__self__ является объектом, над которым метод оперирует, и m.__func__ есть функция, реализующая метод. Вызов m(arg-1, arg-2, ..., arg-n) полностью эквивалентен вызову m.__func__(m.__self__, arg-1, arg-2, ..., arg-n).

Подобно объектам функций, связанные методы объектов поддерживают произвольные атрибуты. Однако, поскольку атрибуты метода в действительности хранятся в лежащем в основе объекте-функции (meth.__func__), установка атрибутов метода на связанные методы отклоняется. Попытка установить атрибуты методу дает в результате возбуждение AttributeError (docs.python.org/3/library/exceptions.html#AttributeError). Для того, чтобы установить атрибуты метода, вам надо явно установить их в лежащий в основе объект-функцию:

>>> class C:
...     def method(self):
...         pass
...
>>> c = C()
>>> c.method.whoami = 'my name is method'  # can't set on the method
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'method' object has no attribute 'whoami'
>>> c.method.__func__.whoami = 'my name is method'
>>> c.method.whoami
'my name is method'
Для подробной информации см. The standard type hierarchy (docs.python.org/3/reference/datamodel.html#types).

4.12.5. Объекты кода
Кодовые объекты используются реализацией для представления "псевдо-скомпилированного" исполняемого кода Python как тела функции. Они отличаются от объектов-функций, так как не содержат ссылку на их глобальную среду выполнения. Кодовые объекты возвращаются встроенной функцией compile() и могут быть извлечены из объектов-функций через их атрибут __code__. См. также модуль code (docs.python.org/3/library/code.html#module-code). 

Объект кода может быть выполнен или оценен путем передачи его (вместо строки с исходным кодом) во встроенную функцию exec() или eval().

См. The standart type hierarchy (docs.python.org/3/reference/datamodel.html#types) для большей информации.

4.12.6. Объекты типов
Объекты типов представляют различные объектные типы. Доступ к типу объекта осуществляется с помощью встроенной функции type(). Специальных операций для типов нет. Стандартный модуль types (docs.python.org/3/library/types.html#module-types) определяет имена для всех стандартных встроенных типов.

Типы выводятся подобно этому: <class 'int'>.

4.12.7. Объект Null
Данный объект возвращается функциями, которые явно не возвращают значение. Он не поддерживает специальных операций. Есть только один объект null, названный None (встроенное имя). type(None)() производит тот же объект.

Выводится как None.

4.12.8. Объект многоточия
Этот объект обычно используется срезами (см. Slicings (docs.python.org/3/reference/expressions.html#slicings)). Не поддерживает специальных операций. Есть только один объект многоточия, названный Ellipsis (встроенное имя). type(Ellipsis)() производит единичный Ellipsis.

Выводится как Ellipsis или ....

4.12.9. Объект NotImplemented
Этот объект возвращается из сравнений и двоичных операций, когда одни запрашиваются для оперирования над типами, которые они не поддерживают. См. Comparisons (docs.python.org/3/reference/expressions.html#comparisons) для большей информации. Существует только один объект NotImplemented. type(NotImplemented)() производит единичный экземпляр.

Записывается как NotImplemented.

4.12.10. Булевы значения
Булевы значения представляют собой два объекта-константы: False и True. Они используются для представления правдивости значения (хотя другие значения также могут рассматриваться как ложь или правда). В числовом контексте (например, когда используется как аргумент для арифметического оператора), они ведут себя как целые числа 0 и 1 соответственно. Встроенная функция bool() (docs.python.org/3/library/functions.html#bool) может быть использована для конвертирования любого значения к Boolean, если значение может быть интерпретировано как правда (см. раздел Проверка правдивости значения выше).

Выводятся как False и True соответственно.

4.12.11. Внутренние объекты
Чтобы получить информацию об этом см. The standard type hierarchy (docs.python.org/3/reference/datamodel.html#types). Здесь описан стек каркасных объектов, объектов трассировки и объектов среза.

4.13. Специальные атрибуты
Реализация добавляет несколько специальных атрибутов только для чтения к нескольким типам объектов, где они являются значимыми. Некоторые из них не выводятся встроенной функцией dir() (docs.python.org/3/library/functions.html#dir).

object.__dict__

Словарь или другой объект отображения, используемый для хранения атрибутов объекта (записываемый).

instance.__class__

Класс, к которому принадлежит класс экземпляра.

class.__bases__

Кортеж базового класса класса объекта.

definition.__name__

Имя класса, функции, метода, дескриптора или экземпляра генератора.

definition.__qualname__

qualified name (docs.python.org/3/glossary.html#term-qualified-name) класса, функции, метода, дескриптора или экземпляра генератора.

Новое в версии 3.3.

class.__mro__

Этот атрибут является кортежем классов, которые рассматриваются, когда разыскиваются базовые классы во время развязки метода.

class.mro()

Этот метод может быть переопределен метаклассом для настройки порядка разрешения метода для его экземпляров. Он вызывается при создании экземпляра класса, и его результат сохраняется в __mro__. 

class.__subclasses__()

Каждый класс хранит список слабых ссылок на его прямой подкласс. Этот метод возвращает список всех, чьи ссылки все еще живы. Например:

>>> int.__subclasses__()
[<class 'bool'>]
Примечания:

[1] Дополнительная информация по этим специальным методам может быть найдена в Справочном руководстве Python (Basic customization (docs.python.org/3/reference/datamodel.html#customization)).

[2] Как следствие список [1, 2] рассматривается равным [1.0, 2.0], и также для кортежей.

[3] Они должны иметь, поскольку парсер не может определить тип операндов.

[4] (1, 2, 3, 4) Символы с регистром - это те, которые в общей категории свойств являются одними из "Lu" (буква, верхний регистр), "Ll" (буква, нижний регистр) или "Lt" (буква, заголовочный).

[5] (1, 2) Для форматирования только кортежа, вам следует предоставить одиночный кортеж, который, единственным элементом которого является форматированный кортеж.