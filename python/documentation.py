1. Разжигая ваш аппетит
Если вы много работаете на компьютерах, в конце концов обнаружите, что есть некоторые задачи, которые вы хотели бы автоматизировать. Так возможно вам хочется выполнить операцию поиска и замены над большим количеством текстовых файлов, или переименовать и переупорядочить группу файлов фотографий со сложным путем к ним. Возможно вы хотели бы написать маленькую пользовательскую базу данных или специализированное GUI-приложение или простую игру.

Если вы профессиональный разработчик программного обеспечения, вам возможно приходится работать с несколькими C/C++/Java библиотеками, но вы находите обычный цикл записи/компиляции/тестирования/перекомпиляции слишком медленным. Возможно вы пишете набор тестов для такой библиотеки и находите написание тестирующего кода утомительной задачей. Или, может быть, вы написали программу, которая может использовать язык расширения, и не хотите разрабатывать и реализовывать целый новый язык для вашего приложения.

Python - просто язык для вас.

Вы могли бы написать скрипт для командной оболочки Unix или пакеты файлов Windows для некоторых подобных задач, но shell-скрипты самое лучшее для перемещения окружающих файлов и изменении текстовых данных, не очень хорошо подходит для GUI-приложений или игр. Вы могли бы написать C/C++/Java программу, но это может занять много времени разработки, чтобы получить даже первый черновой вариант программы. Python проще в использовании, доступен на операционных системах Windows, Mac OS X и Unix и поможет сделать эту работу более быстро.

Python прост в использовании, но это реальный язык программирования, предлагающий намного больше структуры и поддержки для больших программ, чем могут предложить shell-скрипты или пакеты файлов. С другой стороны, Python также предлагает намного больше проверки ошибок, чем C, и, будучи весьма высоко-уровневым языком, он имеет встроенные высоко-уровневые типы данных, такие как гибкие массивы данных и словари. Из-за его более общих типов данных Python применим к гораздо более обширной сфере проблем, чем Awk или даже Perl, однако многое по меньшей мере также легко сделать в Python, как и в тех языках.

Python позволяет разделить вашу программу на модули, которые могут быть повторно использованы в других программах на Python. Он поставляется с большой коллекцией стандартных модулей, которые вы можете использовать в качестве основы ваших программ, или в качестве примеров, чтобы начать обучение программировать на Python. Некоторые из этих модулей предоставляют такие вещи как файловый ввод/вывод, системные вызовы, сокеты и даже интерфейсы инструментария GUI, такого как Tk.

Python - интерпретируемый язык, который может сберечь вам много времени в процессе разработки программы, т. к. нет необходимости в компиляции и компоновке. Интерпретатор может использоваться в интерактивном режиме, который позволяет легко экспериментировать с особенностями языка, писать одноразовые программы или тестировать функции при разработке программ "снизу вверх". Это также удобный настольный калькулятор.

Python позволяет программам быть написанными компактно и читаемо. Программы, написанные на Python, обычно намного короче, чем эквивалентные программы на C, C++ или Java, по нескольким причинам:

высоко-уровневые типы данных позволяют вам выражать комплекс операций в одном высказывании;
группировка высказываний осуществляется отступом, а не скобками начала и конца;
нет необходимости в объявлении переменных или аргументов.
Python расширяем: если вы знаете, как программировать на C, то легко добавите в интерпретатор встроенную функцию или модуль как для выполнения критических операций на максимальной скорости, так и свяжите Python-программу с библиотеками, которые могут быть доступны только в бинарной форме (такие как графические библиотеки конкретного производителя). Когда действительно войдете во вкус, можете связывать интерпретатор Python с приложениями, написанными на C, и использовать его, как язык расширения или команд для того приложения.

Кстати, язык назван в честь шоу BBC “Monty Python’s Flying Circus” ("Летающий цирк Монти Пайтона") и не имеет ничего общего с рептилиями. Создание ссылок на пародии Монти Пайтона в документации не только позволительно, это приветствуется!

Теперь когда вы все взволнованы Python, вы захотите изучить его более детально. Поскольку лучшим способом выучить язык является его использование, учебник приглашает вас поиграть с интерпретатором Python во время чтения.

В следующей главе объясняется принцип использования интерпретатора. Это довольно обыденная информация, но следует опробовать примеры, приведенные ниже.

Остальная часть учебника знакомит с различными особенностями языка Python и системы на примерах, начиная с простых выражений, высказываний и типов данных, через функции и модули, и, наконец, касаясь продвинутых концепций, таких как исключения и пользовательские классы.

2. Использование интерпретатора Python
2.1. Вызов интерпретатора
Интерпретатор Python обычно устанавливается по адресу /usr/local/bin/python3.6 на тех машинах, где это возможно; размещение в /usr/local/bin делает возможным поиску пути вашей командной оболочки Unix запустить его, набрав команду:

python3.6
в оболочке. [1] Поскольку выбор каталога, в котором находится интерпретатор, определяется установкой, то возможны другие места; свяжитесь с вашим местным гуру Python или системным администратором. (Например, /usr/local/python распространенное альтернативное место.)

Как правило, на компьютерах с Windows установка Python производится в C:\Python36, хотя вы можете изменить это в процессе установки. Чтобы добавить эту директорию к вашему пути, вы можете ввести следующую команду в командной строке DOS:

set path=%path%;C:\python36
Ввод символа конца файла (Control-D на Unix, Control-Z на Windows) в строке приглашения заставляет интерпретатор выйти со статусом нулевого выхода. Если это не работает, вы можете выйти из интерпретатора, введя следующую команду: quit().

Особенности строки ввода интерпретатора включают интерактивное редактирование, подстановка истории и завершение кода на системах, которые поддерживают readline (библиотеку, осуществляющую совместное с оболочкой автозавершение - прим. пер.). Вероятно самый быстрый способ увидеть, поддерживается ли редактирование командной строки, это ввести Control-P в первой строке приглашения Python, полученной вами. Если есть звуковой сигнал, то у вас редактируемая командная строка; см. дополнение Редактирование интерактивного ввода и подстановка истории для знакомства с ключами. Если ничего не происходит или если ^P повторяется, то редактирование командной строки недоступно; вы сможете только использовать Backspace для удаления символов из текущей строки.

В некоторой степени интерпретатор работает как оболочка Unix: при вызове со стандартного ввода, подключенного к устройству tty, он читает и выполняет команды интерактивно; при вызове с именем файла в качестве аргумента или с файлом в качестве стандартного ввода, он читает и выполняет скрипт из этого файла.

Второй способ запуска интерпретатора: python -c command [arg] ..., который выполняет оператор(ы) в command, аналогично опции -c (docs.python.org/3/using/cmdline.html#cmdoption-c) командной оболочки. Поскольку выражения Python часто содержат пробелы или другие символы, которые имеют специальное значение для оболочки, то обычно рекомендуется цитировать command целиком в одинарных кавычках.

Некоторые модули Python также полезны как скрипты. Они могут быть вызваны с помощью python -m module [arg] ..., который выполняет код файла module, как если бы вы написали его полное имя в командной строке.

При использовании файла скрипта, иногда полезно иметь возможность запустить скрипт и потом войти в интерактивный режим. Это может быть сделано путем передачи -i (docs.python.org/3/using/cmdline.html#cmdoption-i) перед скриптом.

Все опции командной строки описаны в Command line and environment (docs.python.org/3/using/cmdline.html#using-on-general).

2.1.1. Передача аргумента
Как известно для интерпретатора имя скрипта и дополнительные аргументы впоследствии превращаются в список строк и присваиваются переменной argv модуля sys. Вы можете обращаться к этому списку, выполняя import sys. Длина списка по крайней мере равна одному; когда не передано ни одного скрипта и аргумента, то sys.argv[0] является пустой строкой. Когда имя скрипта передается как '-' (означает стандартный ввод), sys.argv[0] устанавливается в '-'. При использовании -c (docs.python.org/3/using/cmdline.html#cmdoption-c) command, sys.argv[0] устанавливается в '-c'. При использовании -m (docs.python.org/3/using/cmdline.html#cmdoption-m) module, sys.argv[0] устанавливается к полному имени местонахождения модуля. Опции, обнаруженные после -c (docs.python.org/3/using/cmdline.html#cmdoption-c) command или -m (docs.python.org/3/using/cmdline.html#cmdoption-m) module не потребляются обработчиком опций интерпретатора Python, а оставляются в sys.argv для обработки командой или модулем.

2.1.2. Интерактивный режим
Когда команды считываются из tty (терминала - прим. пер.), интерпретатору говорится быть в interactive mode (интерактивном режиме - прим. пер.). В этом режиме он предлагает ввести следующую команды с primary promp (первичного приглашения - прим. пер.), обычно три знака "больше, чем" (>>>); для продолжения строк он подсказывает с secondary prompt (вторичного приглашения - прим. пер.), по умолчанию три точки (...). Интерпретатор выводит приветственное сообщение, начинающееся с его номера версии и уведомления об авторских правах, перед выводом первого приглашения:

$ python3.6
Python 3.6 (default, Sep 16 2015, 09:25:04)
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
Продолжение строк необходимо при вводе многострочной конструкции. В качестве примера посмотрите на это выражение if (docs.python.org/3/reference/compound_stmts.html#if):

>>> the_world_is_flat = True
>>> if the_world_is_flat:
...     print("Be careful not to fall off!")
...
Be careful not to fall off!
Чтобы узнать больше об интерактивном режиме, смотрите Интерактивный режим.

2.2. Интерпретатор и его окружение
2.2.1. Кодировка исходного кода
По умолчанию исходные файлы Python рассматриваются как кодированные в UTF-8. В этой кодировке символы большинства языков мира могут быть использованы одновременно в строковых литералах, идентификаторах и комментариях - хотя стандартная библиотека использует только символы ASCII для идентификаторов, это соглашение, которому должен следовать любой переносимый код. Чтобы отобразить все эти символы должным образом, ваш редактор должен распознавать, что файл в кодировке UTF-8, и он должен использовать шрифт, который поддерживает все символы в файле.

Чтобы объявить кодировку отличную от той, что используется по-умолчанию, первой строкой файла должна быть добавлена специальная строка комментария. Синтаксис такой как следующий:

# -*- coding: encoding -*-
где encoding одна из действующих codecs (docs.python.org/3/library/codecs.html#module-codecs), поддерживаемых Python.

Например, чтобы объявить, что используется кодировка Windows-1252, первая строка в вашем файле исходного кода должна быть:

# -*- coding: cp-1252 -*-
Есть одно исключение из правила первой строки: когда исходный код начинается с UNIX "shebang" line. В этом случае объявление кодировки должно быть добавлено второй строкой файла. Например:

#!/usr/bin/env python3
# -*- coding: cp-1252 -*-
Примечания

[1] В Unix интерпретатор Python 3.x не устанавливается по-умолчанию с исполняемым именем python, так что нет конфликта с одновременно установленным Python 2.x.

Неформальное введение в Python
Использование Python в качестве калькулятора
Числа
Строки
Списки
Первые шаги к программированию
В следующих примерах ввод и вывод различаются присутствием или отсутствием приглашений (>>> (docs.python.org/3/glossary.html#term) и ... (docs.python.org/3/glossary.html#term-1)): чтобы повторить пример, вы должны ввести все после приглашения, когда оно появляется; строки, которые не начинаются с приглашения, являются выводом интерпретатора. Заметьте, что вторичное приглашение на отдельной строке в примере означает, что вы должны ввести пустую строку; это используется для окончания многострочной команды.

Многие из примеров в данном руководстве, даже те, которые вводятся в интерактивном режиме, включают комментарии. Комментарии в Python начинаются с хэш-символа # и продолжаются до конца физической строки. Комментарий может появиться в начале строки или после пробела или кода, но не внутри строкового литерала. Хэш-символ внутри строки - это просто хэш-символ. Так как комментарии являются пояснением кода и не интерпретируются Python, они могут быть опущены при работе с примерами.

Несколько примеров:

# это первый комментарий
spam = 1  # а это второй комментарий
          # ... и теперь третий!
text = "# Это не комментарий, т. к. это находится внутри кавычек."
3.1. Использование Python в качестве калькулятора
Испытаем несколько простых команд Python. Запустите интерпретатор и дождитесь первичного приглашения >>>. (Это не должно занять много времени.)

3.1.1. Числа
Интерпретатор действует как простой калькулятор: вы можете ввести в него выражение, и он выведет результат. Синтаксис выражения простой: операторы +, -, * и / работают также как в большинстве других языках (например, Pascal или C); круглые скобки могут быть использованы для группировки. Например:

>>> 2 + 2
4
>>> 50 - 5*6
20
>>> (50 - 5*6) / 4
5.0
>>> 8 / 5  # деление всегда возвращает число с плавающей точкой
1.6
Целые числа (например, 2, 4, 20) имеют тип int, другие с дробной частью (например, 5.0, 1.6) имеют тип float. Далее в учебнике мы подробнее познакомимся с числовыми типами.

Деление (/) всегда возвращает вещественное число. Чтобы выполнить floor division (docs.python.org/3/glossary.html#term-floor-division) и получить целый результат (отбрасыванием какой-либо дробной части), вы можете использовать оператор //; для вычисления остатка можете использовать %:

>>> 17 / 3  # классическое деление возвращает вещественное число
5.666666666666667
>>>
>>> 17 // 3  # деление нацело отбрасывает дробную часть
5
>>> 17 % 3  # оператор % возвращает остаток от деления
2
>>> 5 * 3 + 2  # результат * делитель + остаток
17
В Python возможно использовать оператор ** для вычисления степени [1]:

>>> 5 ** 2  # 5 в квадрате
25
>>> 2 ** 7  # 2 в степени 7
128
Знак равенства (=) используется для присваивания значения переменной. При этом никакого результата не отображается перед следующим интерактивным приглашением:

>>> width = 20
>>> height = 5 * 9
>>> width * height
900
Если переменная не "определена" (не присвоено значение), попытка использовать ее выдаст вам ошибку:

>>> n  # попытка доступа к неопределенной переменной
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined
Есть полная поддержка для чисел с плавающей точкой; операторы со смешанными типами операндов конвертируют целый операнд в число с плавающей точкой:

>>> 3 * 3.75 / 1.5
7.5
>>> 7.0 / 2
3.5
В интерактивном режиме последнее выведенное выражение присваивается переменной _. Это означает, что когда вы используете Python как настольный калькулятор, то в какой-то степени легче продолжать вычисления, например:

>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
Эту переменную следует рассматривать только как предназначенную для чтения пользователем. Не присваивайте ей значение явно - вы создадите независимую локальную переменную с таким же именем, маскирующую встроенную переменную с ее волшебным поведением.

В дополнение к int и float Python поддерживает другие типы чисел, такие как Decimal (docs.python.org/3/library/decimal.html#decimal.Decimal) и Fraction (docs.python.org/3/library/fractions.html#fractions.Fraction). Python также имеет встроенную поддержку для комплексных чисел и использует суффикс j или J для обозначения мнимой части (например, 3+5j).

3.1.2. Строки
Кроме чисел Python также может манипулировать строками, которые могут быть описаны несколькими способами. Они могут быть заключены в одинарные кавычки ('...') или двойные кавычки ("...") с одинаковым результатом [2]. \ может быть использован для экранирования кавычек:

>>> 'spam eggs'  # одинарные кавычки
'spam eggs'
>>> 'doesn\'t'  # используйте \' для экранирования одиночной кавычки...
"doesn't"
>>> "doesn't"  # ...или вместо этого используйте двойные кавычки
"doesn't"
>>> '"Yes," he said.'
'"Yes," he said.'
>>> "\"Yes,\" he said."
'"Yes," he said.'
>>> '"Isn\'t," she said.'
'"Isn\'t," she said.'
В интерактивном интерпретаторе выводящаяся строка заключена в кавычки и специальные символы экранируются бэкслешами. В то же время это может иногда отличаться от ввода (заключающие кавычки могли измениться), две строки эквивалентны. Строка заключена в двойные кавычки, если она включает одинарные, при этом двойные кавычки отсутствуют, иначе она заключена в одинарные кавычки. Функция print() создает более читабельный вывод, опуская ограждающие кавычки и интерпретируя экранируемые и специальные символы:

>>> '"Isn\'t," she said.'
'"Isn\'t," she said.'
>>> print('"Isn\'t," she said.')
"Isn't," she said.
>>> s = 'First line.\nSecond line.'  # \n означает новую строку
>>> s  # без print(), \n содержится в выводе
'First line.\nSecond line.'
>>> print(s)  # с print(), \n создает новую строку
First line.
Second line.
Если вы не хотите, чтобы символы, которым предшествует \, интерпретировались как специальные, то можете использовать raw string (сырые строки - прим. перев.), добавив r перед первой кавычкой:

>>> print('C:\some\name')  # здесь \n означает новую строку!
C:\some
ame
>>> print(r'C:\some\name')  # обратите внимание на r перед кавычкой
C:\some\name
Строковые литералы могут охватывать множество строк. Один способ - это использование тройных кавычек: """...""" или '''...'''. Конец строки по-умолчанию обозначает переход на новою, но есть возможность предотвратить это, добавив \ в конец строки. Следующий пример:

print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
дает следующий вывод (заметьте, что начальная новая строка не включена):

Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
Строки могут быть соединены (склеены вместе) оператором + и повторены с помощью *:

>>> # 3 раза 'un' с последующим 'ium'
>>> 3 * 'un' + 'ium'
'unununium'
Два или более строковых литерала (т. е. когда каждый заключен в кавычки), следующих друг за другом, автоматически конкатенируются.

>>> 'Py' 'thon'
'Python'
Однако это работает только с двумя литералами, но не с переменными или выражениями:

>>> prefix = 'Py'
>>> prefix 'thon'  # не может соединить переменную и строковый литерал
  ...
SyntaxError: invalid syntax
>>> ('un' * 3) 'ium'
  ...
SyntaxError: invalid syntax
Если вы хотите конкатенировать переменные или переменную и литерал, используйте +:

>>> prefix + 'thon'
'Python'
Это свойство особенно полезно, когда вы хотите разорвать длинную строку:

>>> text = ('Put several strings within parentheses '
            'to have them joined together.')
>>> text
'Put several strings within parentheses to have them joined together.'
Строка может быть проиндексирована, первый символ имеет индекс 0. Отдельный символьный тип отсутствует, символ - это просто строка единичной размерностью:

>>> word = 'Python'
>>> word[0]  # символ в позиции 0
'P'
>>> word[5]  # символ в позиции 5
'n'
Индексы также могут быть отрицательными числами для начала отсчета справа:

>>> word[-1]  # последний символ
'n'
>>> word[-2]  # второй с конца символ
'o'
>>> word[-6]
'P'
Заметьте, что поскольку -0 - это тоже самое, что 0, то отрицательные индексы начинаются с -1.

В дополнение к индексации также поддерживаются срезы. В то время как индексация используется, чтобы получать отдельные символы, срезы позволяют вам получать подстроки:

>>> word[0:2]  # символы от позиции 0 (включая) до 2 (исключая) 
'Py'
>>> word[2:5]  # символы от позиции 2 (включая) до 5 (исключая) 
'tho'
Заметьте, что начало всегда включается, а конец всегда исключается. Это обеспечивает то, что s[:i] + s[i:] всегда равно s:

>>> word[:2] + word[2:]
'Python'
>>> word[:4] + word[4:]
'Python'
Индексация срезов имеет полезные свойства по умолчанию; опущенный первый индекс по умолчанию обозначает ноль, опущенный второй индекс по умолчанию обозначает размер строки, с которой берется срез.

>>> word[:2]  # символ от начала до позиции 2 (исключая)
'Py'
>>> word[4:]  # символ от позиции 4 (включая) до конца 
'on'
>>> word[-2:] # символы от второго с конца (включая) до конца
'on'
Один из способов запомнить, как работают срезы, - это думать об индексах как указывающих между символами, левый край первого символа нумеруется 0. Тогда как правый край последнего символа строки из n символов имеет индекс n, например:

 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
Первый ряд чисел дает позицию индексов 0...6 в строке; второй ряд дает соответствующие отрицательные индексы. Срез от i до j состоит из всех символов между краями, отмеченными i и j соответственно.

Для неотрицательных индексов длина среза представляет собой разность индексов, если оба находятся в границах. Например, длина word[1:3] равна 2.

Попытка использовать индекс, который является слишком большим, приведет к ошибке:

>>> word[42]  # у word только 6 символов
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
Однако индексы вне диапазона обрабатываются корректно при использовании для взятия среза:

>>> word[4:42]
'on'
>>> word[42:]
''
Строки Python не могут быть изменены - они неизменяемы (docs.python.org/3/glossary.html#term-immutable). Поэтому присвоение по индексированной позиции в строке приводит к ошибке:

>>> word[0] = 'J'
  ...
TypeError: 'str' object does not support item assignment
>>> word[2:] = 'py'
  ...
TypeError: 'str' object does not support item assignment
Если вам нужна другая строка, следует создать новую строку:

>>> 'J' + word[1:]
'Jython'
>>> word[:2] + 'py'
'Pypy'
Встроенная функция len() возвращает длину строки:

>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34
Смотрите также:

Тип текстовой последовательности — str 
Строки являются примером типов последовательностей и поддерживают обычные операции, поддерживаемые такими типами.
Методы строк 
Строки поддерживают большое число методов для основных преобразований и поиска.
Formatted string literals (docs.python.org/3/reference/lexical_analysis.html#f-strings)
Строковые литералы со встроенными выражениями.
Format String Syntax (docs.python.org/3/library/string.html#formatstrings)
Информация о форматировании строк с помощью str.format().
printf-стиль форматирования строки
Старые операции форматирования вызываются, когда строки являются левым операндом оператора %, описанного более подробно здесь.
3.1.3. Списки
Python'у известно определенное количество сложных типов данных, используемых для группировки разных значений. Наиболее гибким является list (список - прим. пер.), который может быть описан как список разделенных запятой значений (элементов) между квадратными скобками. Списки могут включать элементы различных типов, но обычно все элементы имеют одинаковый тип.

>>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
Как строки (и все другие встроенные типы последовательностей (docs.python.org/3/glossary.html#term-sequence)), списки могут быть проиндексированы и из них можно брать срезы:

>>> squares[0]  # индекс возвращает элемент
1
>>> squares[-1]
25
>>> squares[-3:]  # срез возвращает новый список
[9, 16, 25]
Все операции взятия среза возвращают новый список, содержащий запрошенные элементы. Это значит, что ниже следующий срез возвращает новую (поверхностную) копию списка:

>>> squares[:]
[1, 4, 9, 16, 25]
Списки также поддерживают такую операцию как конкатенацию:

>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
В отличие от строк, которые неизменяемые (docs.python.org/3/glossary.html#term-immutable), списки являются изменяемым (docs.python.org/3/glossary.html#term-mutable) типом, т. е. есть возможность изменить их содержание:

>>> cubes = [1, 8, 27, 65, 125]  # что-то здесь не так
>>> 4 ** 3  # 4 в кубе равно 64, а не 65!
64
>>> cubes[3] = 64  # замена ошибочного значения
>>> cubes
[1, 8, 27, 64, 125]
Вы также можете добавить новый элемент в конец списка, используя метод append() (мы узнаем о методах больше позже):

>>> cubes.append(216)  # добавление куба 6-ти
>>> cubes.append(7 ** 3)  # и куба 7-ми
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
Присвоение срезов также возможно, и этим можно даже изменить размер списка или полностью его очистить:

>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # замена нескольких значений
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # теперь удалим их
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # очистим список, заменив все элементы на пустой список
>>> letters[:] = []
>>> letters
[]
Встроенная функция len() также применима к спискам:

>>> letters = ['a', 'b', 'c', 'd']
>>> len(letters)
4
Возможно вкладывать списки (создавать списки, включающие другие списки), например:

>>> a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0]
['a', 'b', 'c']
>>> x[0][1]
'b'
3.2. Первые шаги к программированию
Конечно мы можем использовать Python для более сложных задач, чем складывать вместе два и два. Например, мы можем написать начальную часть последовательности ряда Фибоначчи вот так:

>>> # ряд Фибоначчи:
... # сумма двух элементов определяет следующий
... a, b = 0, 1
>>> while b < 10:
...     print(b)
...     a, b = b, a+b
...
1
1
2
3
5
8
Этот пример знакомит с несколькими новыми свойствами.

Первая строка содержит множественное присваивание: переменные a и b одновременно получают новые значения 0 и 1. В последней строке это используется опять, демонстрируя, что сначала выражения с правой стороны полностью оцениваются, прежде чем произойдет какое-либо присваивание. Выражения с правой стороны выполняются слева направо.
Цикл while (docs.python.org/3/reference/compound_stmts.html#while) выполняется до тех пор, пока условие (здесь b < 10) остается верным. В Python, как в C, любое ненулевое численное значение является правдой; ноль является ложью. Условие может также быть строкой или списком, в действительности любой последовательностью; все с ненулевой длинной является правдой, пустая последовательность является ложью. Проверка, используемая в примере, является простым сравнением. Стандартные операторы сравнения записываются также как в C: < (меньше, чем), > (больше, чем), == (равно), <= (меньше или равно), >= (больше или равно) и != (не равно).
Тело цикла имеет отступ: в Python отступ - это способ группировки выражений. В интерактивном режиме вы должны ввести табуляцию или пробел(ы) для каждой строки с отступом. На практике вы будете подготавливать более сложный ввод для Python с помощью текстового редактора; все приличные текстовые редакторы имеют автоматическую установку отступов. Когда составное выражение вводится в интерактивном режиме, за ним должна следовать пустая строка, чтобы указать завершение (поскольку синтаксический анализатор не может угадать, когда вы ввели последнюю строку). Обратите внимание, что каждая строка в основном блоке должна быть с отступом на одно и то же значение.
Функция print() выводит значение переданных ей аргумента(ов). Это отличается от просто вывода выражений, которые вы хотите вывести (как мы ранее делали раньше в примерах с калькулятором) способом обработки множества аргументов, величин с плавающей точкой и строк. Строки печатаются без кавычек, и между элементами вставляются пробелы, таким образом вы можете красиво форматировать объекты, подобно этому:
>>> i = 256*256
>>> print('The value of i is', i)
The value of i is 65536
Аргумент ключевое слово end может быть использовано для отмены новой строки после вывода, или окончания вывода другой строкой:

>>> a, b = 0, 1
>>> while b < 1000:
...     print(b, end=',')
...     a, b = b, a+b
...
1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
Примечания

[1] Поскольку ** имеет более высокий приоритет, чем -, то -3**2 будет интерпретировано как -(3**2) и поэтому даст результат -9. Чтобы избежать этого и получить 9, вы можете использовать (-3)**2.

[2] В отличие от других языков специальные символы, такие как \n, имеют одинаковое значение как в одинарных ('...'), так и двойных ("...") кавычках. Разница между двумя вариантами только в том, что в одинарных кавычках вам не надо экранировать " (но вы должны экранировать \') и наоборот.

4. Управление потоком выполнения
Операторы if
Операторы for
Функция range()
Операторы break и continue, ветка else в циклах
Операторы pass
Определение функций
Дополнительно об определении функций
Значение аргументов по умолчанию
Аргументы с ключевым словом
Списки произвольных аргументов
Распаковка списков аргументов
Lambda-выражения
Строки документирования
Аннотации функций
Стиль кодирования
Кроме оператора while (docs.python.org/3/reference/compound_stmts.html#while), который только что был представлен, Python знает обычные операторы управления потоком, известные из других языков, но с некоторыми особенностями.

4.1. Операторы if
Возможно наиболее хорошо известным типом оператора является if (docs.python.org/3/reference/compound_stmts.html#if). Например:

>>> x = int(input("Пожалуйста, введите число: "))
Пожалуйста, введите число: 42
>>> if x < 0:
...     x = 0
...     print('Отрицательное изменяется на 0')
... elif x == 0:
...     print('Ноль')
... elif x == 1:
...     print('Один')
... else:
...     print('Больше')
...
Больше
Частей elif (docs.python.org/3/reference/compound_stmts.html#elif) может быть больше или не быть вообще, часть else (docs.python.org/3/reference/compound_stmts.html#else) также необязательна. Ключевое слово 'elif' есть сокращение от 'else if' и полезно для избежания излишних отступов. Последовательность if ... elif ... elif ... есть замена для операторов switch или case, встречающихся в других языках.

4.2. Операторы for
В Python оператор for (docs.python.org/3/reference/compound_stmts.html#for) немного отличается от того, что вы могли использовать в C или Pascal. Вместо того, чтобы всегда выполнять итерацию по арифметической прогрессии чисел (как в Pascal), или давая пользователю возможность определить как шаг итерации, так и условие остановки (как в C), в Python оператор for перебирает элементы любой последовательности (список или строку) в том порядке, в котором они появляются в последовательности. Например (нет намеренной игры слов):

>>> # Измерить несколько слов:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))
...
cat 3
window 6
defenestrate 12
Если вам надо изменить последовательность, вы перебираете внутри цикла (например, для дублирования выбранных элементов), рекомендуется сначала сделать копию. Выполнение итерации над последовательностью безоговорочно не создает ее копию. Взятие среза делает это особенно удобным:

>>> for w in words[:]:  # Цикл по срезу-копии целого списка.
...     if len(w) > 6:
...         words.insert(0, w)
...
>>> words
['defenestrate', 'cat', 'window', 'defenestrate']
С for w in words: пример попытался бы создать бесконечный список, вставляя defenestrate опять и опять.

4.3. Функция range()
Если вам надо перебрать последовательность чисел, пригодится встроенная функция range(). Она генерирует арифметические прогрессии:

>>> for i in range(5):
...     print(i)
...
0
1
2
3
4
Заданная конечная точка никогда не входит в генерируемую последовательность; range(10) генерирует 10 значений, индексируемые как обычная последовательность длинной 10. Возможно установить другое число в качестве начала диапазона или указать другое приращение (даже отрицательное; иногда приращение называют "шагом"):

range(5, 10)
   от 5 по 9
 
range(0, 10, 3)
   0, 3, 6, 9
 
range(-10, -100, -30)
  -10, -40, -70
Для перебора по индексам последовательности, вы можете сочетать range() и len() как в следующем примере:

>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
В большинстве подобных случаев, однако, удобно использовать функцию enumerate(), см. Приемы использования цикла.

Странная вещь случится, если вы просто напечатаете диапазон:

>>> print(range(10))
range(0, 10)
Во многих отношениях объект, возвращаемый range(), ведет себя так, как будто это список, но на самом деле это не так. Это объект, который возвращает последовательные элементы желаемой последовательности, когда вы перебираете его, но это на самом деле не список, тем самым экономится пространство.

Мы говорим, что объект является iterable (итерация, итерируемый - прим. пер.), то есть подходит в качестве цели для функций и конструкций, которые ожидают что-то, из чего они могут получить последовательные элементы, пока они не исчерпаны. Мы видели, что оператор for именно такой iterator (итератор - прим. пер.). Функций list() есть другой; она создает списки из итерируемых (перечисляемых) объектов:

>>> list(range(5))
[0, 1, 2, 3, 4]
Позже мы увидим больше функций, которые возвращают итерации и принимают итерации в качестве аргумента.

4.4. Операторы break, continue и условие else в циклах
Оператор break (docs.python.org/3/reference/simple_stmts.html#break), как и в C, прерывает выполнение вмещающего (самого внутреннего) его цикла for (docs.python.org/3/reference/compound_stmts.html#for) или while (docs.python.org/3/reference/compound_stmts.html#while).

Операторы цикла могут иметь условие else; оно выполняется, когда цикл завершается при исчерпании списка (с for) или когда условие становится ложным (с while), но не в том случае, когда цикл прерван оператором break. Это иллюстрирует следующий пример с циклом, в котором ищутся простые числа:

>>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, 'equals', x, '*', n//x)
...             break
...     else:
...         # цикл потерпел неудачу, не найдя множитель
...         print(n, 'is a prime number')
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
(Да, это корректный код. Посмотрите внимательней: условие else относится к циклу for, не к оператору if.)

При использовании с циклом условие else имеет больше общего с условием else оператора try (docs.python.org/3/reference/compound_stmts.html#try), чем if (docs.python.org/3/reference/compound_stmts.html#if): ветка else оператора try срабатывает, когда исключения не происходит, а ветка else цикла срабатывает, когда не срабатывает break. За дополнительной информацией по оператору try и исключениям, см. Обработка исключений.

Оператор continue (docs.python.org/3/reference/simple_stmts.html#continue) также заимствован из C, он продолжает выполнение со следующей итерации цикла:

>>> for num in range(2, 10):
...     if num % 2 == 0:
...         print("Found an even number", num)
...         continue
...     print("Found a number", num)
Found an even number 2
Found a number 3
Found an even number 4
Found a number 5
Found an even number 6
Found a number 7
Found an even number 8
Found a number 9
4.5. Оператор pass
Оператор pass (docs.python.org/3/reference/simple_stmts.html#pass) ничего не делает. Он может быть использован, когда синтаксически требуется какой-нибудь оператор, но программа не требует действия. Например:

>>> while True:
...     pass  # Занят ожиданием прерывания с клавиатуры (Ctrl+C)
...
Обычно это используется при создании очень маленьких классов:

>>> class MyEmptyClass:
...     pass
...
В других случаях pass может быть использован, как заполнитель функции или тела условного выражения, когда вы работаете над новым кодом, позволяя вам продолжать размышлять на более абстрактном уровне. pass  молча игнорируется:

>>> def initlog(*args):
...     pass   # Вспомните потом реализовать это!
...
4.6. Определение функций
Мы можем создать функцию, которая выводит ряд Фибоначчи до произвольной границы:

>>> def fib(n):    # выводит ряд Фибоначчи до n
...     """Печатает ряд Фибоначчи вплоть до n."""
...     a, b = 0, 1
...     while a < n:
...         print(a, end=' ')
...         a, b = b, a+b
...     print()
...
>>> # Теперь вызовем функцию, которую мы только что определили:
... fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
Ключевое слово def (docs.python.org/3/reference/compound_stmts.html#def) вводит определение функции. За ним должно следовать имя функции и в круглых скобках список формальных параметров. Выражения, которые формируют тело функции, начинаются на следующей строке и должны быть с отступом.

Опционально (не обязательно) первое выражение тела функции может быть строковым литералом; этот строковый литерал является строкой документации функции, или docstring. (Дополнительно о строках документации может быть найдено в разделе Строки документации.) Есть инструменты, которые используют строки документации для автоматического создания онлайн или печатной документации, или позволить пользователю интерактивно просматривать код; это хорошая практика включать строки документации в код, который вы пишите, так что сделайте это привычкой.

Выполнение функции вводит новую таблицу обозначений, используемую для локальных переменных функции. Точнее, все присваивания переменным в функции сохраняют значение в локальной таблице обозначений; так ссылки на переменные сначала ищутся в локальной таблице, затем в локальной таблице обрамляющих функций, затем в глобальной таблице обозначений, и наконец в таблице встроенных имен. Поэтому глобальные переменные не могут быть связаны со значением непосредственно в функции (если не названы в операторе global (docs.python.org/3/reference/simple_stmts.html#global)), хотя на них можно ссылаться.

Фактические параметры (аргументы) при вызове функции вводятся в ее локальную таблицу имен; таким образом, аргументы передаются с помощью вызова по значению (где значение всегда ссылка на объект, не значение объекта). [1] Когда функция вызывает другую функцию, создается новая локальная таблица имен для этого вызова.

Определение функции вводит ее имя в текущую таблицу обозначений. Значение имени функции имеет тип, который распознается интерпретатором как определенная пользователем функция. Это значение может быть связано с другим именем, которое затем может также быть использовано как функция. Это служит в качестве общего механизма переименования:

>>> fib
<function fib at 10042ed0>
>>> f = fib
>>> f(100)
0 1 1 2 3 5 8 13 21 34 55 89
Придя из других языков, вы можете подумать, что объект fib не функция, а процедура, поскольку она не возвращает значение. В действительности даже функции без оператора return (docs.python.org/3/reference/simple_stmts.html#return) делают возврат значения, хотя довольно скучный. Это значение называется None (это встроенное имя). Вывод значения None обычно подавляется интерпретатором, если это будет только записанное значение. Вы можете увидеть это, если захотите с помощью print():

>>> fib(0)
>>> print(fib(0))
None
Просто написать функцию, которая возвращает список чисел ряда Фибоначчи, вместо их вывода:

>>> def fib2(n): # возвращает ряд Фибоначчи вплоть до n
...     """Возвращает список, включающий ряд Фибоначчи вплоть до n."""
...     result = []
...     a, b = 0, 1
...     while a < n:
...         result.append(a)    # смотри ниже
...         a, b = b, a+b
...     return result
...
>>> f100 = fib2(100)    # вызов
>>> f100                # вывод результата
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
Этот пример, как обычно, демонстрирует некоторые особенности Python:

Оператор return (docs.python.org/3/reference/simple_stmts.html#return) возвращает значение из функции. return без выражения аргумента возвращает None. Выполнение функции до конца также возвращает None.
Выражение result.append(a) вызывает метод спискового объекта result. Метод - это функция, которая "принадлежит" объекту и называется obj.methodname, где obj - это какой-либо объект (это может быть выражение), а methodname - имя метода, который определен типом объекта. Различные типы определяют разные методы. Методы разных типов могут иметь одинаковые имена, при этом не возникает неоднозначности. (Возможно определить ваши собственные типы объектов и методы, используя классы, см. Классы.) Метод append(), показанный в примере, определен для списковых объектов; он добавляет новый элемент в конец списка. В данном примере это эквивалентно result = result + [a], но более эффективно.
4.7. Подробнее об определении функций
Также возможно определять функции с переменным числом аргументов. Есть три формы, которые могут быть комбинированы.

4.7.1. Значения аргументов по умолчанию
Наиболее полезная форма - это указать значение по умолчанию для одного или более аргументов. Это создает функцию, которая может быть вызвана с меньшим количеством аргументов, чем это определено по умолчанию. Например:

def ask_ok(prompt, retries=4, reminder='Please try again!'):
    while True:
        ok = input(prompt)
        if ok in ('y', 'ye', 'yes'):
            return True
        if ok in ('n', 'no', 'nop', 'nope'):
            return False
        retries = retries - 1
        if retries < 0:
            raise ValueError('invalid user response')
        print(reminder)
Эта функция может быть вызвана несколькими способами:

передачей только обязательного аргумента: ask_ok('Do you really want to quit?')
передачей одного из необязательных аргументов: ask_ok('OK to overwrite the file?', 2)
или даже передачей всех аргументов: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')
Этот пример также знакомит с ключевым словом in (docs.python.org/3/reference/expressions.html#in). Оно проверяет содержит ли последовательность определенное значение.

Значения по умолчанию вычисляются в точке определения функции в области определения, так что

i = 5
 
def f(arg=i):
    print(arg)
 
i = 6
f()
напечатает 5.

Важное предупреждение: Значение по умолчанию вычисляется только один раз. Это создает различие, когда по умолчанию задается изменяемый объект, такой как список, словарь или экземпляры большинства классов. Например, следующая функция накапливает переданные ей аргументы на последующие вызовы:

def f(a, L=[]):
    L.append(a)
    return L
 
print(f(1))
print(f(2))
print(f(3))
Это напечатает

[1]
[1, 2]
[1, 2, 3]
Если вы не хотите, чтобы по умолчанию было разделено между последующими вызовами, то можете написать функцию как эта:

def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
4.7.2. Аргументы с ключевым словом
Функции также могут быть вызваны с использованием keyword arguments (docs.python.org/3/glossary.html#term-keyword-argument) вида kwarg=value. Например, следующая функция:

def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")
принимает один обязательный аргумент (voltage) и три необязательных (state, action и type). Эта функция может быть вызвана любым из следующих способов:

parrot(1000)                                          # 1 позиционный аргумент
parrot(voltage=1000)                                  # 1 аргумент ключевое слово
parrot(voltage=1000000, action='VOOOOOM')             # 2 аргумента ключевых слова
parrot(action='VOOOOOM', voltage=1000000)             # 2 аргумента ключевых слова
parrot('a million', 'bereft of life', 'jump')         # 3 позиционных аргумента
parrot('a thousand', state='pushing up the daisies')  # 1 позиционный, 1 ключевое слово
но все следующие вызовы будут считаться недействительными:

parrot()                     # опущен обязательный аргумент
parrot(voltage=5.0, 'dead')  # аргумент без ключевого слова после аргумента с ключевым словом
parrot(110, voltage=220)     # дублирование значения для одного и того же аргумента
parrot(actor='John Cleese')  # неизвестный аргумент ключевое слово
В вызове функции аргументы с ключевыми словами должны следовать после позиционных аргументов. Все передаваемые аргументы с ключевым словом должны соответствовать одному из аргументов, принимаемых функцией (например, actor не действительный аргумент для функции parrot), и их порядок не важен. Это также включает неопциональные аргументы (например, parrot(voltage=1000) также верно). Ни один аргумент не может получить значение более, чем один раз. Вот пример, который не работает из-за этого ограничения:

>>> def function(a):
...     pass
...
>>> function(0, a=0)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: function() got multiple values for keyword argument 'a'
Когда конечные формальные параметры представлены в форме **name, функция принимает словарь (см. Типы отображений — dict), включающий все аргументы с ключевыми словами за исключением тех, которые уже соответствуют формальным параметрам. Это может быть скомбинировано с формальным параметром в форме *name (описано в следующем подразделе), который получает кортеж, включающий позиционные аргументы за списком формальных параметров. (*name должен находиться перед **name.) Например, если мы определяем функцию, как эту:

def cheeseshop(kind, *arguments, **keywords):
    print("-- Do you have any", kind, "?")
    print("-- I'm sorry, we're all out of", kind)
    for arg in arguments:
        print(arg)
    print("-" * 40)
    keys = sorted(keywords.keys())
    for kw in keys:
        print(kw, ":", keywords[kw])
Она может быть вызвана так:

cheeseshop("Limburger", "It's very runny, sir.",
           "It's really very, VERY runny, sir.",
           shopkeeper="Michael Palin",
           client="John Cleese",
           sketch="Cheese Shop Sketch")
и конечно было бы выведено:

-- Do you have any Limburger ?
-- I'm sorry, we're all out of Limburger
It's very runny, sir.
It's really very, VERY runny, sir.
----------------------------------------
client : John Cleese
shopkeeper : Michael Palin
sketch : Cheese Shop Sketch
Заметьте, что порядок, в котором аргументы с ключевыми словами выводятся обязательно соответствуют порядку, в котором они были переданы в функцию при вызове.

4.7.3. Произвольные списки аргументов
Наконец, реже используется возможность вызова функции с произвольным числом аргументов. Эти аргументы будут обернуты в кортеж (см. Кортежи и последовательности). Перед переменным числом аргументов могут быть обычные аргументы или не быть ни одного.

def write_multiple_items(file, separator, *args):
    file.write(separator.join(args))
Как правило, эти variadic аргументы будут последними в списке формальных параметров, потому что они собирают все оставшиеся вводимые аргументы, которые передаются в функцию. Любые формальные параметры, которые находятся после параметра *args являются аргументами "только по ключевому слову", это означает, что они могут быть использованы только в качестве ключевых слов, а не позиционных аргументов.

>>> def concat(*args, sep="/"):
...    return sep.join(args)
...
>>> concat("earth", "mars", "venus")
'earth/mars/venus'
>>> concat("earth", "mars", "venus", sep=".")
'earth.mars.venus'
4.7.4. Распаковка списков аргументов
Происходит обратная ситуация, когда аргументы уже в списке или кортеже, но должны быть распакованы при вызове функции, требующей отдельных позиционных аргументов. Например, встроенная функция range() ожидает отдельных аргументов start и stop. Если они не доступны по отдельности, записывают вызов функции с *-оператором для распаковки аргументов из списка или кортежа:

>>> list(range(3, 6)) # нормальный вызов с отдельными аргументами
[3, 4, 5]
>>> args = [3, 6]
>>> list(range(*args)) # вызов с аргументами, распакованными из списка
[3, 4, 5]
В такой же форме словари могут поставлять аргументы с ключевым словом с помощью **-оператора:

>>> def parrot(voltage, state='a stiff', action='voom'):
...     print("-- This parrot wouldn't", action, end=' ')
...     print("if you put", voltage, "volts through it.", end=' ')
...     print("E's", state, "!")
...
>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
>>> parrot(**d)
-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !
4.7.5. Lambda-выражения
С помощью ключевого слова lambda (docs.python.org/3/reference/expressions.html#lambda) может быть создана маленькая анонимная функция. Эта функция возвращает сумму ее двух аргументов: lambda a, b: a+b. Lambda-функции могут быть использованы там, где требуются объекты-функции. Синтаксически они ограничены одним выражением. Семантически они являются просто синтаксическим сахаром для обычного определения функции. Как вложенные определения функции lambda-функции могут ссылаться на переменные из содержащей области:

>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
Пример выше использует lambda-выражения для возврата функции. Другое использование - это передать небольшую функцию в качестве аргумента:

>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
>>> pairs.sort(key=lambda pair: pair[1])
>>> pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]
4.7.6. Строки документации
Здесь несколько соглашений о содержании и форматировании строк документации.

Первой строке всегда следует быть короткой, краткая сводка назначения объекта. Для краткости не следует явно указывать имя или тип объекта, поскольку они доступны другими способами (за исключением, если имя оказывается глаголом, описывающим операцию функции). Эта строка должна начинаться с заглавной буквы и заканчиваться точкой.

Если есть еще строки документации, вторая должна быть пустой, визуально отделяя сводку от остального описания. Следующие строки должны представлять собой один или несколько параграфов, описывающих соглашения о вызовах объекта, его побочные эффекты и т.д.

Анализатор Python не удаляет отступ из многострочных строковых литералов, так что инструменты, которые обрабатывают документацию, должны удалять отступы, если это необходимо. Это делается с помощью следующего соглашения. Первый непустая линия после первой строки определяет размер отступа для всей строки документации. (Мы не можем использовать первую строку, поскольку она, как правило, примыкает к открывающим кавычкам строки, так что ее отступ не является очевидным в строковом литерале.) Пробелы "эквивалентные" этому отступу затем удаляются из начала всех линий строки. Линий с меньшим отступом быть не должно, но если они есть, все их ведущие пробелы должны удаляться. Эквивалентность пробелов должна быть проверена после расширения табуляций (до 8 пробелов, как правило).

Вот пример многострочной строки документации:

>>> def my_function():
...     """Do nothing, but document it.
...
...     No, really, it doesn't do anything.
...     """
...     pass
...
>>> print(my_function.__doc__)
Do nothing, but document it.
 
    No, really, it doesn't do anything.
4.7.7. Аннотации функций
Function annotations (docs.python.org/3/reference/compound_stmts.html#function) являются полностью необязательными метаданными о типах, используемых пользовательскими функциями (см. PEP 484 (python.org/dev/peps/pep-0484) для получения дополнительной информации).

Аннотации хранятся в атрибуте __annotations__ функции как словарь и не имеют никакого эффекта на любую другую часть функции. Параметры аннотаций определяются двоеточием после имени параметра, за которым следует выражение, оценивающее значение аннотации. Возвращения аннотации определяются литералом ->, следующим выражению, между списком параметра и двоеточием, обозначая конец оператора def (docs.python.org/3/reference/compound_stmts.html#def). Следующий пример имеет позиционный аргумент, аргумент с ключевым словом и аннотированное возвращаемое значение:

>>> def f(ham: str, eggs: str = 'eggs') -> str:
...     print("Annotations:", f.__annotations__)
...     print("Arguments:", ham, eggs)
...     return ham + ' and ' + eggs
...
>>> f('spam')
Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
Arguments: spam eggs
'spam and eggs'
4.8. Стиль кодирования
Теперь, когда вы собираетесь писать более длинный, более сложный код на Python, настало время поговорить о coding style (стиле кодирования - прим. пер.). В большинстве языков можно писать (или по-другому, форматировать) в различных стилях; некоторые из них более читабельные, чем другие. Создание кода более читаемого для других - всегда хорошая идея, и принятый хороший стиль кодирования чрезвычайно помогает этому.

Для Python, появился PEP 8 (python.org/dev/peps/pep-0008) как руководство по стилю, которого придерживается большинство проектов; он поощряет хорошо читаемый и приятный для глаз стиль кодирования. Каждый разработчик Python должен прочитать это однажды; вот наиболее важные извлеченные пункты для вас:

Используйте 4-х-пробельный отступ, а не табуляцию.
4 пробела - хороший компромисс между маленьким отступом (позволяет большую глубину вложенности) и большим отступом (легче для чтения). Табуляции вносят путаницу, и лучше опустить их.
Делайте строки длиной не более 79 символов.
Это поможет пользователям с маленькими дисплеями и сделает возможным расположить рядом несколько файлов с кодом на больших дисплеях.
Используйте пустые строки для отделения функций и классов, а большие блоки кода помещайте внутрь функций.
Когда возможно, оставляйте комментарии на их собственной строке.
Используйте строки документации.
Используйте пробелы вокруг операторов и после запятой, но не непосредственно внутри конструкции скобок: a = f(1, 2) + g(3, 4).
Называйте ваши классы и функции последовательно; соглашением является использование CamelCase ("верблюжьей" нотации - прим. пер.) для классов и lower_case_with_underscores (нижнего регистра с подчеркиванием - прим. пер.) для функций и методов. Всегда используйте self в качестве имени первого аргумента метода (см. Первый взгляд на классы для большей информации о классах и методах).
Не используйте причудливые кодировки, если ваш код предназначен для использования в международной среде. По умолчанию в Python UTF-8 или даже обычный ASCII работает лучше в любом случае.
Точно так же не используйте не-ASCII символы в идентификаторах, если есть хотя бы малейший шанс, что люди, говорящие на другом языке, будут читать или поддерживать этот код.
Примечания

[1] На самом деле, вызов по ссылки на объект было бы лучшим описанием, поскольку если передается изменяемый объект, тот кто вызывает будет видеть любые изменения, которые вызываемый сделает с ним (элементы вставляются в список).

5. Структуры данных
5.1. Подробнее о списках
5.1.1. Использование списков в качестве стеков
5.1.2. Использование списков в качестве очередей
5.1.3. Генераторы списков
5.1.4. Вложенные генераторы списков
5.2. Оператор del
5.3. Кортежи и последовательности
5.4. Множества
5.5. Словари
5.6. Приемы использования цикла
5.7. Подробнее об условиях
5.8. Сравнение последовательностей и других типов
Эта глава более подробно описывает некоторые моменты, с которыми вы уже знакомы, и также добавляет некоторые новые факты.

5.1. Подробнее о списках
Списковый тип данных имеет несколько больше методов. Здесь все методы списковых объектов:

list.append(x)
Добавляет элемент в конец списка. Эквивалентно a[len(a):] = [x].

list.extend(iterable)
Расширяет список добавлением всех элементов из итерации. Эквивалентно a[len(a):] = iterable.

list.insert(i, x)
Вставляет элемент в заданную позицию. Первый аргумент - это индекс элемента, перед которым происходит вставка, так a.insert(0, x) вставляет впереди списка, а a.insert(len(a), x) эквивалентно a.append(x).

list.remove(x)
Удаляет первый элемент из списка, чье значение равно x. Возникает ошибка, если такого элемента нет.

list.pop([i])
Удаляет элемент в заданной позиции в списке и возвращает его. Если индекс не указан, a.pop() удаляет и возвращает последний элемент в списке. (Квадратные скобки вокруг i в сигнатуре метода означают, что параметр необязательный, а не то, что вы должны вводить квадратные скобки в том месте. Вы часто увидите такую нотацию в Справке по библиотеке Python.)

list.clear()
Удаляет все элементы из списка. Эквивалентно del a[:].

list.index(x[, start[, end]])
Возвращает индекс (отсчет с нуля) первого элемента в списке, чье значение равно x. Возникает ValueError (docs.python.org/3/library/exceptions.html#ValueError), если такого элемента нет.

Необязательные аргументы start и end интерпретируются как запись среза и используются как ограничитель для поиска в конкретной последовательности списка. Возвращаемый индекс вычисляется относительно начала полной последовательности, а не от аргумента start.

list.count(x)
Возвращает какое число раз x добавлен в список.

list.sort(key=None, reverse=False)
Сортирует элементы списка на месте (аргументы могут быть использованы для настройки сортировки, см. sorted() для разъяснений).

list.reverse()
Выполняет реверс (обратное построение - прим. пер) элементов списка на месте.

list.copy()
Возвращает поверхностную копию списка. Эквивалентно a[:].

Пример, в котором используется большинство методов списка:

>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
>>> fruits.count('apple')
2
>>> fruits.count('tangerine')
0
>>> fruits.index('banana')
3
>>> fruits.index('banana', 4)  # Находит следующий banana, начиная с позиции 4
6
>>> fruits.reverse()
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']
>>> fruits.append('grape')
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']
>>> fruits.sort()
>>> fruits
['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']
>>> fruits.pop()
'pear'
Вы могли заметить, что такие методы как insert, remove и sort, которые только изменяют список, не возвращают значения, которое может быть выведено, по умолчанию они возвращают None. [1] Это принцип работы всех изменяемых структур данных в Python.

5.1.1. Использование списков в качестве стеков
Методы списков делают возможным очень легко использовать список как стек, в котором последний добавленный элемент есть первый извлеченный элемент ("последним вошел, первым вышел"). Для добавления элемента вверх стека используйте append(). Для извлечения элемента из верха стека, используйте pop() без конкретного индекса. Например:

>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
5.1.2. Использование списков в качестве очередей
Также возможно использовать список как очередь, где первый добавленный элемент есть первый извлеченный элемент ("первым вошел, первым вышел"); однако списки не эффективны для этой цели. В то время как добавление с помощью append() и извлечение с помощью pop() с конца списка осуществляются быстро, добавление с помощью insert() или извлечение с помощью pop() из начала списка происходит медленно (потому что все другие элементы должны быть сдвинуты на один).

Для реализации очереди используйте collections.deque (docs.python.org/3/library/collections.html#collections.deque), который был разработан для быстрых добавлений и извлечений с обоих концов. Например:

>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terry прибыл
>>> queue.append("Graham")          # Graham прибыл
>>> queue.popleft()                 # Первый прибывший теперь покинул
'Eric'
>>> queue.popleft()                 # Второй прибывший теперь покинул
'John'
>>> queue                           # Остальная очередь в порядке прибытия
deque(['Michael', 'Terry', 'Graham'])
5.1.3. Генераторы списков
Генераторы списков обеспечивает лаконичный способ их создания. Обычные приложения создают новые списки, где каждый элемент есть результат нескольких операций, применяемых к каждому члену другой последовательности или итерации, или создают подпоследовательности тех элементов, которые удовлетворяют конкретному условию.

Например, предположим, мы хотим создать такой список квадратов:

>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
Заметьте, что создается (или перезаписывается) переменная под именем x, которая продолжает существовать после завершения цикла. Мы можем вычислить список квадратов без какого-либо побочного эффекта так:

squares = list(map(lambda x: x**2, range(10)))
что эквивалентно:

squares = [x**2 for x in range(10)]
Это более кратко и читабельно.

Генератор списка состоит из скобок, содержащих выражение, за которым следует for (docs.python.org/3/reference/compound_stmts.html#for), затем ни одной или больше for или условий if (docs.python.org/3/reference/compound_stmts.html#if). Результатом будет новый список, полученный от вычисления выражения в данном контексте присутствующих записей for и if. Например, этот listcomp сочетает в себе элементы двух списков, если они не равны:

>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
и это эквивалент для:

>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
Заметьте, что порядок операторов for и if одинаков в обоих данных частях кода.

Если выражение является кортежем (как (x, y) в предыдущем примере), оно должно быть заключено в скобки.

>>> vec = [-4, -2, 0, 2, 4]
>>> # создает новый список с удвоенными значениями
>>> [x*2 for x in vec]
[-8, -4, 0, 4, 8]
>>> # фильтрует список, исключая отрицательные числа
>>> [x for x in vec if x >= 0]
[0, 2, 4]
>>> # применяет функцию для всех элементов
>>> [abs(x) for x in vec]
[4, 2, 0, 2, 4]
>>> # вызывает метод для каждого элемента
>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> # создает список двойных кортежей как (число, квадрат)
>>> [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
>>> # кортеж должен быть заключен в скобки, иначе возбуждается ошибка
>>> [x, x**2 for x in range(6)]
  File "<stdin>", line 1, in ?
    [x, x**2 for x in range(6)]
               ^
SyntaxError: invalid syntax
>>> # делает список одноуровневым, используя listcomp с двумя 'for'
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
Генератор списков может содержать сложные выражения и вложенные функции:

>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
5.1.4. Вложенные генераторы списков
Начальное выражение в генераторе списка может быть любым произвольным выражением, включающим другой генератор списка.

Рассмотрим следующий пример матрицы 3x4, реализованной как список из 3-х списков длиной по 4:

>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]
Следующий генератор списка переставит строки и столбцы:

>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
Как мы видели в предыдущем разделе, вложенный listcomp оценивается в контексте for (docs.python.org/3/reference/compound_stmts.html#for), который следует за ним, таким образом этот пример есть эквивалент для:

>>> transposed = []
>>> for i in range(4):
...     transposed.append([row[i] for row in matrix])
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
который, в свою очередь, есть то же самое, что:

>>> transposed = []
>>> for i in range(4):
...     # следующие 3 строки реализуют вложенный listcomp
...     transposed_row = []
...     for row in matrix:
...         transposed_row.append(row[i])
...     transposed.append(transposed_row)
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
В действительности вам следует предпочитать встроенные функции сложным цепочкам выражений. Функция zip() прекрасно выполнить работу в данном случае:

>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
См. Распаковка списков аргументов для деталей о звездочке в этой строке.

5.2. Оператор del
Существует способ удалить элемент из списка, передав его индекс вместо значения: оператор del (docs.python.org/3/reference/simple_stmts.html#del). Это отличается от метода pop(), который возвращает значение. Также оператор del может быть использован для удаления среза из списка или очистки всего списка (что мы делали раньше присвоением пустого списка срезу). Например:

>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
del также может быть использован для полного удаления переменных:

>>> del a
Обращение к имени a в дальнейшем - это ошибка (до тех пор, пока другое значение не будет связано с ним). Позже мы обнаружим другие варианты использования del.

5.3. Кортежи и последовательности
Мы видели, что списки и строки имеют много общих свойств, такие как индексирование и операция взятия среза. Они являются двумя примерами типа данных последовательностей (см. Типы последовательностей — list, tuple, range). Поскольку Python - развивающийся язык, другие типы данных последовательностей могут быть добавлены. Существует также другой стандартный тип данных последовательностей: tuple (кортеж).

Кортеж состоит из ряда значений, разделенных запятыми, например:

>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # Кортежи могут быть вложенными:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # Кортежи неизменяемые:
... t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # но они могут содержать изменяемые объекты:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
Как вы видите, при выводе кортежи всегда заключены в скобки, так что вложенные кортежи интерпретируются корректно; они могут быть введены с и без окружающих скобок, хотя часто скобки необходимы в любом случае (если кортеж является частью большего выражения). Невозможно присвоить индивидуальному элементу кортежа, однако возможно создать кортежи, которые содержат изменяемые объекты, такие как списки.

Хотя кортежи могут показаться подобными спискам, они часто используются в разных ситуациях и для различных целей. Кортежи неизменяемые (docs.python.org/3/glossary.html#term-immutable) и обычно включают разнородную последовательность элементов, которые доступны через распаковку (см. позже в этом разделе) или индексирование (или даже по атрибуту в случае namedtuples (docs.python.org/3/library/collections.html#collections.namedtuple)). Списки изменяемы (docs.python.org/3/glossary.html#term-mutable), а их элементы обычно однородны и доступны посредством итерации списка.

Особая проблема - создание кортежей, включающих 0 или 1 элемент: у синтаксиса есть некоторые дополнительные особенности для этого. Пустые кортежи создаются пустой парой скобок; кортежи с одним элементом - значением после которого идет запятая (недостаточно заключить одиночное значение в скобки). Уродливо, но эффективно. Например:

>>> empty = ()
>>> singleton = 'hello',    # <-- заметьте запятую в конце
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
('hello',)
Выражение t = 12345, 54321, 'hello!' является примером упаковки кортежа: значения 12345, 54321 и 'hello!' упаковываются вместе в кортеж. Обратная операция также возможна:

>>> x, y, z = t
Это называется распаковкой последовательности и работает для любой последовательности с правой стороны. Распаковка последовательности требует, чтобы было в наличии так много переменных с левой стороны от знака равенства, сколько есть элементов в последовательности. Обратите внимание, что множественное присваивание на самом деле есть просто комбинирование упаковки кортежа и распаковки последовательности.

5.4. Множества
Python также включает тип данных для множеств (sets). Множество - это неупорядоченная коллекция, не содержащая повторов элементов. Основное применение включает проверку наличия члена и устранение дублирующихся записей. Объекты множеств также поддерживают математические операции, такие как объединение, пересечение, разность и симметричная разность.

Для создания множеств могут быть использованы фигурные скобки или функция set(). Заметьте: для создания пустого множества вы должны использовать set(), а не {}; последние создают пустой словарь, структуру данных, которую мы обсудим в следующем разделе.

Вот краткая демонстрация:

>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # покажет, что дубликаты были удалены
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # быстрая проверка членства
True
>>> 'crabgrass' in basket
False
 
>>> # Демонстрируются операции над множествами на уникальных буквах из двух слов ...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # уникальные буквы в a
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # буквы в a, но не в b
{'r', 'd', 'b'}
>>> a | b                              # буквы или в a или в b
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # буквы и в a и в b
{'a', 'c'}
>>> a ^ b                              # буквы в a или b, но не в обоих
{'r', 'd', 'b', 'm', 'z', 'l'}
Подобно генераторам списка, генераторы множеств также поддерживаются:

>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
5.5. Словари
Другой полезный тип данных, встроенный в Python, - это словарь (см. Типы отображений — dict). Словари иногда встречаются в других языках как "ассоциативные записи" или "ассоциативные массивы". В отличие от последовательностей, которые индексируются диапазоном чисел, словари индексируются по ключам, которые могут быть любым неизменяемым типом; строки и числа всегда могут быть ключами. Кортежи могут быть использованы как ключи, если они содержат только строки, числа или кортежи; если кортеж включает какой-либо изменяемый объект, прямо или косвенно, он не может быть использован в качестве ключа. Вы не можете использовать списки как ключи, поскольку списки могут быть изменены на месте с помощью присваивания по индексу, срезу или такими методами как append() и extend().

Лучше всего думать о словарях как о неупорядоченном множестве пар key: value (ключ: значение) с тем требованием, что ключ уникален (внутри одного словаря). Пара скобок создает пустой словарь: {}. Размещение разделенного запятыми списка пар ключ: значение внутри скобок добавляет начальные пары в словарь; таким же способом словари выводятся.

Основными операциями над словарями являются сохранение значения с каким-либо ключом и извлечение значения по данному ключу. Также возможно удаление пары key:value с помощью del. Если вы сохраняете, используя ключ, который уже используется, то старое значение, связанное с этим ключом, будет потеряно. Ошибкой является извлечение значения, используя несуществующий ключ.

Применение list(d.keys()) к словарю возвращает список всех ключей, используемых в словаре в произвольном порядке (если вы хотите отсортировать, просто вместо этого используйте sorted(d.keys())). [2] Чтобы проверить, есть ли какой-нибудь один ключ в словаре, используйте ключевое слово in (docs.python.org/3/reference/expressions.html#in).

Здесь небольшие примеры, использующие словарь:

>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'sape': 4139, 'guido': 4127, 'jack': 4098}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'guido': 4127, 'irv': 4127, 'jack': 4098}
>>> list(tel.keys())
['irv', 'guido', 'jack']
>>> sorted(tel.keys())
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
Конструктор dict() строит словари прямо из последовательностей пар ключ-значение

>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'jack': 4098, 'guido': 4127}
Кроме того, словарные сборки могут быть использованы для создания словарей из произвольных выражений ключей и значений:

>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
Когда ключи являются простыми строками, то иногда проще указать пары, используя именованные аргументы:

>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'jack': 4098, 'guido': 4127}
5.6. Приемы использования цикла
Когда цикл проходит по словарям, ключ и связанное значение могут быть извлечены одновременно с помощью метода items().

>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
Когда цикл проходит через последовательность, позиционный индекс и связанное значение могут быть извлечены одновременно с помощью функции enumerate().

>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
При прохождении цикла через две и более последовательности одновременно, записи могут быть объединены в пары с помощью функции zip().

>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
Для перебора последовательности в обратном направлении, сначала указывают последовательность в прямом направлении и затем вызывают функцию reversed():

>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
Для цикла по последовательности в отсортированном порядке, используйте функцию sorted(), которая возвращает новый отсортированный список, оставляя исходный неизменным.

>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
Иногда заманчиво изменить список, пока вы перебираете его в цикле; однако вместо этого обычно проще и безопаснее создать новый список.

>>> import math
>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
>>> filtered_data = []
>>> for value in raw_data:
...     if not math.isnan(value):
...         filtered_data.append(value)
...
>>> filtered_data
[56.2, 51.7, 55.3, 52.5, 47.8]
5.7. Подробнее об условиях
Условия, используемые в операторах while и if могут содержать любые операторы, а не только сравнения.

Операторы сравнения in и not in проверяют, встречается ли (или нет) значение в последовательности. Операторы is и is not проверяют, являются ли два объекта действительно одним и тем же объектом; это имеет значение только для изменяемых объектов, как списки. У всех операторов сравнения одинаковый приоритет, который ниже, чем у всех численных операторов.

Сравнения могут быть объединены в цепь. Например, a < b == c проверяет, меньше ли a, чем b, и вдобавок b равно ли c.

Сравнения могут быть объединены с помощью логических операторов and и or, а результат сравнения (или любого другого логического выражения) может быть перевернут на обратный с помощью not. У этих операторов более низкий приоритет, чем у операторов сравнения; среди них not имеет самый высокий приоритет, а or самый низкий, так что A and not B or C есть эквивалент (A and (not B)) or C. Как всегда скобки могут быть использованы для указания желаемой последовательности выполнения.

Логические операторы and и or являются так называемыми операторами short-circuit (короткое замыкание - прим. пер.): их аргументы оцениваются слева на право, и оценка останавливается, как только результат определен. Например, если A и C являются правдой, но B является ложью, то A and B and C не оценивает выражение C. При использовании не логического значения возвращаемым значением оператора короткого замыкания является последний аргумент, который был оценен.

Есть возможность присвоить результат сравнения или другого логического выражения переменной. Например,

>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
Заметьте, что в Python, в отличие от C, присваивание не может происходить внутри выражений. Программистов на C это может разочаровать, но это позволяет избежать распространенного класса проблем, возникающих в программах на C: ввод = в выражении, когда подразумевалось ==.

5.8. Сравнение последовательностей и других типов
Объекты последовательностей могут сравниваться с другими объектами того же типа. Сравнение использует лексикографический порядок: сначала сравниваются первые два элемента, если они разные, то они и определяют результат сравнения; если они равны, сравниваются следующие два элемента, и т. д., пока одна из двух последовательностей не будет исчерпана. Если два сравниваемых элемента сами являются последовательностями одного типа, то лексикографическое сравнение осуществляется рекурсивно. Если все элементы последовательностей равны, то последовательности считаются равными. Если одна последовательность совпадает с началом другой, более короткая последовательность считается меньшей. Лексикографический порядок для строк использует численный код Unicode для сравнения отдельных символов. Несколько примеров сравнения между последовательностями одного типа:

(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
Обратите внимание, что сравнение объектов различных типов с помощью < или > является законным при условии, что объекты имеют соответствующие методы сравнения. Например, смешанные числовые типы сравниваются в соответствии с их числовым значением, так 0 равен 0.0 и т. д. Когда сравнение невозможно, интерпретатор не обеспечивает случайный порядок, а возбуждает исключение TypeError (docs.python.org/3/library/exceptions.html#TypeError).

Примечания

[1] Другие языки могут возвращать измененный объект, что позволяет цепочка методов, такая как d->insert("a")->remove("b")->sort();.

[2] Вызов d.keys() вернет объект dictionary view. Он поддерживает такие операции, как проверка членства и итерация, но его содержание не зависит от исходного словаря - это только вид.

6. Модули
6.1. Подробнее о модулях
6.1.1. Выполнение модулей как скриптов
6.1.2. Путь поиска модуля
6.1.3. "Скомпилированные" файлы Python
6.2. Стандартные модули
6.3. Функция dir()
6.4. Пакеты
6.4.1. Импортирование * из пакета
6.4.2. Внутрипакетные ссылки
6.4.3. Пакеты во множестве директорий
Если вы выходите из интерпретатора Python и входите в него снова, определения, которые вы сделали (функции и переменные) теряются. Следовательно, если вы хотите написать какую-нибудь более длинную программу, вам лучше использовать текстовый редактор для подготовки ввода для интерпретатора, и передать код из этого файла в качестве входных данных. Это называется созданием скриптов. Когда ваша программа становится длиннее, вы можете захотеть разделить ее на несколько файлов для более легкого сопровождения. Вы также можете захотеть использовать удобную написанную вами функцию в нескольких программах без копирования ее определения в каждую программу.

Для поддержки этого в Python есть способ поместить определения в файл и использовать их в скриптах или в интерактивном режиме интерпретатора. Такой файл называется модулем; определения из модуля могут быть импортированы в другие модули или в главный модуль (коллекция переменных, к которым вы имеете доступ в выполняемом скрипте на верхнем уровне и в режиме калькулятора).

Модуль - это файл, содержащий определения и операторы Python. Имя файла является именем модуля с добавленным суффиксом .py. В модуле имя модуля (как строка) доступно как значение глобальной переменной __name__. Для примера, используйте ваш любимый текстовый редактор для создания файла под названием fibo.py в текущей директории со следующим содержанием:

# модуль чисел Фибоначчи
 
def fib(n):    # выводит ряд Фибоначчи до n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()
 
def fib2(n): # возвращает ряд Фибоначчи до n
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result
Теперь войдите в интерпретатор Python и импортируйте этот модуль с помощью следующей команды:

>>> import fibo
Это не вводит имена определенных в fibo функций прямо в текущую таблицу имен; это вводит сюда только имя модуля fibo. Используя имя модуля, вы можете получить доступ к функциям:

>>> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'
Если вы намерены использовать функцию часто, то можете связать ее с локальным именем:

>>> fib = fibo.fib
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
6.1. Подробнее о модулях
Наряду с определениями функций модули могут содержать исполняемые операторы. Эти операторы предназначены для инициализации модуля. Они выполняются только однажды, когда в операторе импорта встречается имя модуля. [1] (Они также запускаются, если файл выполняется как скрипт.)

Каждый модуль имеет его собственную приватную таблицу имен, которая используется как глобальная всеми функциями, определенными в модуле. Поэтому разработчик модуля может использовать глобальную переменную в модуле без беспокойства о случайном конфликте с глобальными переменными пользователя. С другой стороны, если вы знаете, что делаете, то можете использовать глобальную переменную модуля с такой же нотацией, которая используется для ссылки на его функцию, modname.itemname.

Модули могут импортировать другие модули. Принято, но не является необходимым, размещать все операторы import (docs.python.org/3/reference/simple_stmts.html#import) в начале модуля (это касается и скрипта). Имя импортируемого модуля помещается в глобальную таблицу имен импортирующего модуля.

Существует вариант оператора import, который импортирует имена из модуля прямо в таблицу имен импортирующего модуля. Например:

>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
Это не вводит имя модуля, из которого осуществляется импорт, в локальную таблицу имен (так в примере, fibo не определено).

Есть даже вариант импорта всех имен, которые определяет модуль:

>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
В данном случае импортируются все имена за исключением тех, которые начинаются с подчеркивания (_). В большинстве случаев программисты на Python не используют такой импорт, поскольку он вводит неизвестное множество имен в интерпретатор, возможно скрытие нескольких объектов, которые вы уже определили.

Заметьте, что в общепринятой практике импортирование * из модуля вызывает неодобрение, поскольку часто это делает код плохо читаемым. Однако это удобно использовать в интерактивной сессии, чтобы меньше набирать.

Примечание: Для повышения эффективности каждый модуль импортируется только однажды за сессию интерпретатора. Следовательно, если вы изменяете ваши модули, вы должны перезапустить интерпретатор, или, если вы просто хотите проверить один модуль в интерактивном режиме, используйте importlib.reload(), например, import importlib; importlib.reload(modulename).

6.1.1. Выполнение модулей как скриптов
Когда вы запускаете модуль Python командой

python fibo.py <arguments>
код в модуле будет выполнен, просто как если бы вы импортировали его, но с __name__, установленным в "__main__". Это означает, что при добавлении этого кода в конец вашего модуля

if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
вы можете сделать файл используемым как скрипт, в то же время он останется импортируемым модулем, потому что код, который разбирает командную строку, запускается только, если модуль выполняется как файл "main" (главный - прим. пер.):

$ python fibo.py 50
1 1 2 3 5 8 13 21 34
Если модуль импортируется, то код не выполняется:

>>> import fibo
>>>
Это часто используется либо для обеспечения удобного пользовательского интерфейса к модулю, либо для целей тестирования (при запуске модуля как скрипта выполняется ряд тестов).

6.1.2. Путь поиска модуля
Когда осуществляется импорт модуля по имени spam, сначала интерпретатор ищет встроенные модули с таким именем. Если не находит, то затем ищет файл по имени spam.py в списке каталогов, заданных переменной sys.path (docs.python.org/3/library/sys.html#sys.path). sys.path инициируется из этих мест:

Каталог, содержащий выполняемый скрипт (или текущий каталог, когда не указан никакой файл).
PYTHONPATH (список имен каталогов, с таким же синтаксисом как переменная оболочки PATH).
Умолчания, зависимые от установки.
Примечание: В файловой системе, которая поддерживает символические ссылки, каталог, содержащий запущенный скрипт, обрабатывается после символической ссылки. Другими словами, каталог, содержащий символическую ссылку, не добавляется к пути поиска модуля.

После инициализация программа на Python может изменить sys.path. Директория, содержащая запущенный скрипт, размещается в начале пути поиска, впереди пути стандартной библиотеки. Это означает, что скрипты из данной директории будут загружены вместо модулей с такими же именами в каталоге библиотеки. Если замена не предполагалась, то это ошибка. См. раздел Стандартные модули для большей информации.

6.1.3. "Скомпилированные" файлы Python
Для ускорения загрузки модулей Python кэширует скомпилированную версию каждого модуля в каталоге __pycache__ под именем module.version.pyc, где версия кодирует формат скомпилированного файла; обычно включает номер версии Python. Например, в CPython релизе 3.3 скомпилированная версия была бы кэширована как __pycache__/spam.cpython-33.pyc. Такое соглашение наименования позволяет компилировать модули из различных релизов и различных версий Python для сосуществования.

Python сравнивает дату изменения исходного кода со скомпилированной версией, чтобы обнаружить, если она устарела и нуждается в перекомпиляции. Это полностью автоматический процесс. Также скомпилированные модули не зависят от платформы, так одна и та же библиотека может быть разделена среди систем с различными архитектурами.

Python не проверяет кэш в двух случаях. Во-первых, он всегда перекомпилирует и не хранит результат для модуля, который загружается прямо из командной строки. Во вторых, он не проверяет кэш, если нет исходного кода модуля. Для поддержки распространения без исходного кода скомпилированный модуль должен быть в каталоге с исходными кодами, и здесь не должно быть исходных кодов модуля.

Некоторые советы для специалистов:

Вы можете использовать переключатели -O (docs.python.org/3/using/cmdline.html#cmdoption-O) и -OO (docs.python.org/3/using/cmdline.html#cmdoption-OO) в командах Python для уменьшения размера скомпилированного модуля. Переключатель -O удаляет заявляемые операторы, переключатель -OO удаляет как эти операторы, так и строки __doc__. Поскольку некоторые программы могут рассчитывать, что все это доступно, вам следует использовать эту опцию, если вы знаете, что делаете. "Оптимизированные" модули имеют opt-tag и обычно меньше. Будущие релизы могут изменить эффекты оптимизации.
Программа не работает быстрее, когда читается из файлов .pyc, чем когда она читается из файла .py; единственное, что быстрее для файлов .pyc - это скорость, с которой они загружаются.
Модуль compileall (docs.python.org/3/library/compileall.html#module-compileall) может создавать файлы .pyc для всех модулей в каталоге.
Есть больше информации по этому процессу, включая блок-схему решения, в PEP 3147.
6.2. Стандартные модули
Python поставляется с библиотекой стандартных модулей, описанных в отдельном документе, Справка по библиотеки Python (ниже "Справка по библиотеке"). Несколько модулей встроено в интерпретатор; они предоставляют доступ к операциям, которые не являются частью ядра языка, но тем не менее встроены в него, либо для повышения эффективности, либо для обеспечения доступа к примитивам операционной системы, таким как системные вызовы. Установка таких модулей является конфигурационной опцией, которая также зависит от используемой платформы. Например, модуль winreg (docs.python.org/3/library/winreg.html#module-winreg) предоставляется только на системах Windows. Один особый модуль заслуживает внимания: sys (docs.python.org/3/library/sys.html#module-sys), который встроен в каждый интерпретатор Python. Переменные sys.ps1 и sys.ps2 определяют строки, используемые как первичное и вторичное приглашения:

>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
>>> sys.ps1 = 'C> '
C> print('Yuck!')
Yuck!
C>
Эти две переменные определены, только если интерпретатор в интерактивном режиме.

Переменная sys.path является списком строк, который определяет путь поиска модулей интерпретатора. Он инициируется путем по умолчанию, взятым из переменной окружения PYTHONPATH (docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH), или из встроенного по умолчанию, если PYTHONPATH не установлена. Вы можете изменить ее, используя стандартный список операций:

>>> import sys
>>> sys.path.append('/ufs/guido/lib/python')
6.3. Функция dir()
Функция dir() используется для выяснения, какие имена модулей определены. Она возвращает отсортированный список строк:

>>> import fibo, sys
>>> dir(fibo)
['__name__', 'fib', 'fib2']
>>> dir(sys)  
['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__',
 '__package__', '__stderr__', '__stdin__', '__stdout__',
 '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',
 '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv',
 'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder',
 'call_tracing', 'callstats', 'copyright', 'displayhook',
 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',
 'executable', 'exit', 'flags', 'float_info', 'float_repr_style',
 'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',
 'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',
 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount',
 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',
 'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path',
 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1',
 'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit',
 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout',
 'thread_info', 'version', 'version_info', 'warnoptions']
Без аргументов dir() перечисляет имена, которые вы определили в настоящее время:

>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir()
['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']
Заметьте, что она перечисляет все типы имен: переменные, модули, функции и т. д.

dir() не перечисляет имена встроенных функций и переменных. Если вы хотите получить их список, они определены в стандартном модуле builtins (docs.python.org/3/library/builtins.html#module-builtins):

>>> import builtins
>>> dir(builtins)  
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',
 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',
 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',
 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',
 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',
 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',
 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',
 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',
 'NotImplementedError', 'OSError', 'OverflowError',
 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',
 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',
 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',
 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',
 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',
 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',
 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',
 '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',
 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',
 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',
 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',
 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',
 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',
 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',
 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',
 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',
 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',
 'zip']
6.4. Пакеты
Пакеты являются способом структурирования пространства имен Python с помощью "точечных имен модулей". Например, имя модуля A.B обозначает подмодуль с именем B в пакете с именем A. Такое использование модулей позволяет разработчикам различных модулей не беспокоится об именах глобальных переменных друг друга, использование точечных имен модулей позволяет авторам мультимодульных пакетов, таких как NumPy или Python Imaging Library, не беспокоиться об именах модулей друг друга.

Предположим, вы хотите разработать коллекцию модулей ("пакет") для единообразной обработки звуковых файлов и звуковых данных. Существует множество различных форматов звуковых файлов (обычно распознаваемых по их расширению, например: .wav, .aiff, .au), поэтому вам может потребоваться создавать и поддерживать растущую коллекцию модулей для конверсии между различными форматами файлов. Есть также множество различных операций, которые можно выполнять над звуковыми данными (такие как смешивание, добавление эхо, применение функции эквалайзера, создание искусственного стерео-эффекта), поэтому в дополнение вы будете писать нескончаемый поток модулей для выполнения этих операций. Здесь возможная структура для вашего пакета (выраженная в терминах иерархической файловой системы):

sound/                          Пакет верхнего уровня
      __init__.py               Инициализирует звуковой пакет
      formats/                  Подпакет для конверсии файловых форматов
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Подпакет для звуковых эффектов
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Подпакет для фильтров
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
При импорте пакета Python просматривает каталоги в соответствии с sys.path для обнаруживания подкаталога пакета.

Фалы __init__.py требуются для того, чтобы Python обрабатывал каталоги как содержащие пакеты; это делается для предотвращения, что каталоги с обычными именами, такими как string, не будут непреднамеренно скрывать действительные модули, которые обнаружатся позже по пути поиска модулей. В самом простом случае __init__.py может просто быть пустым файлом, но он также может выполнять инициализирующий код для пакета или устанавливать переменную __all__, описанную позже.

Пользователи пакета могут импортировать индивидуальные модули из пакета, например:

import sound.effects.echo
Загружается подмодуль sound.effects.echo. На него надо ссылаться по его полному имени:

sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
Альтернативный способ импорта подмодуля:

from sound.effects import echo
Также загружается подмодуль echo, но он доступен без его пакетного префикса, поэтому он может быть использован так:

echo.echofilter(input, output, delay=0.7, atten=4)
Еще одним вариантом является непосредственный импорт нужной функции или переменной:

from sound.effects.echo import echofilter
Опять же такой импорт загружает подмодуль echo, но это делает его функцию echofilter() доступной напрямую:

echofilter(input, output, delay=0.7, atten=4)
Заметьте, что когда используется from package import item, item может быть либо подмодулем (или подпакетом) пакета, либо каким-нибудь другим именем, определенным в пакете, как функция, класс или переменная. Оператор import сначала проверяет, есть ли определенный элемент в пакете; если нет, он предполагает, что это модуль и пытается загрузить его. Если он не находится, возбуждается исключение ImportError (docs.python.org/3/library/exceptions.html#ImportError).

Наоборот, когда используется синтаксис как import item.subitem.subsubitem, каждый элемент исключается, и последний должен быть пакетом; последний элемент может быть модулем или пакетом, но не может быть классом или функцией или переменной, определенными в предыдущем элементе.

6.4.1. Импортирование * из пакета
Теперь что случится, когда пользователь напишет sound.effects import *? Хотелось бы надеяться, что в идеале это как-нибудь выходит на файловую систему, находит, какие подмодули есть в пакете, и импортирует их все. Это может занять долгое время и импортирование подмодулей может иметь нежелательный побочный эффект, который должен происходить только, когда подмодули явно импортированы.

Для разработчика пакета есть только одно решение обеспечить явное индексирование пакета. Оператор import использует следующее соглашение: если код __init__.py пакета определяет список под названием __all__, он берется как список имен модуля, которые должны быть импортированы, когда встречается from package import *. Разработчик пакета должен обновлять список, когда выпускается новая версия пакета. Разработчики пакета могут также решить не поддерживать это, если они не видят использования для импортирования * из их пакета. Например, файл sound/effects/__init__.py может содержать следующий код:

__all__ = ["echo", "surround", "reverse"]
Это бы означало, что from sound.effects import * будет импортировать три названных подмодуля пакета sound.

Если __all__ не определена, выражение from sound.effects import * не импортирует все подмодули из пакета sound.effects в текущее пространство имен; это только обеспечивает то, что пакет sound.effects был импортирован (возможно выполняется какой-нибудь код инициализации из __init__.py) и затем импортирует любые имена, определенные в пакете. Это включает какие-либо имена определенные (и подмодули, загруженные явно) __init__.py. Это также включает какие-либо подмодули пакета, которые были явно загружены предыдущими операторами import (docs.python.org/3/reference/simple_stmts.html#import). Рассмотрим этот код:

import sound.effects.echo
import sound.effects.surround
from sound.effects import *
В этом примере модули echo и surround импортируются в текущее пространство имен, потому что они определены в пакете sound.effects, когда выполняется выражение from...import (это также работает, когда определена __all__.)

Хотя некоторые модули разработаны для экспорта только имен, которые следуют определенным шаблонам, когда вы используете import *, это по-прежнему считается плохой практикой в рабочем коде.

Помните, нет ничего плохого в использовании from Package import specific_submodule! На самом деле это рекомендованная нотация, если не требуется из импортируемого модуля использовать подмодули с одинаковыми именами из различных пакетов.

6.4.2. Внутрипакетные ссылки
Когда пакеты структурированы в подпакеты (как в пакете sound в примере), вы можете использовать абсолютные импорты для обращения к подмодулям сестринских пакетов. Например, если модулю sound.filters.vocoder надо использовать модуль echo в пакете sound.effects, он может использовать from sound.effects import echo.

Вы также можете писать относительные импорты, с формой оператора import from module import name . Такие импорты используют лидирующие точки для указания текущего и родительского пакетов, вовлеченных в относительный импорт. Например, из модуля surround вы можете использовать:

from . import echo
from .. import formats
from ..filters import equalizer
Заметьте, такой относительный импорт основывается на имени текущего модуля. Поскольку имя главного модуля всегда "__main__", модули, предназначенные для использования в качестве главного модуля приложений Python, должны всегда использовать абсолютные импорты.

6.4.3. Пакеты во множестве директорий
Пакеты поддерживают один более специфический атрибут, __path__ (docs.python.org/3/reference/import.html#__path__). Он инициализируется как список, содержащий имя каталога, хранящего __init__.py пакета, перед кодом в котором файл выполняется. Эта переменная может быть изменена; оказывая таким образом влияние на будущий поиск модулей и подпакетов, включенных в пакет.

В то время как эта возможность не часто требуется, она может быть использована для расширения набора модулей, обнаруженных в пакете.

Примечания

[1] На самом деле определения функций также "операторы", которые "выполняются"; выполнение определения функции уровня модуля вводит имя функции в глобальную таблицу имен модуля.

7. Ввод и вывод
7.1. Особенности форматирования вывода
7.1.1. Старое форматирование строк
7.2. Чтение и запись файлов
7.2.1. Методы файловых объектов
7.2.2. Сохранение структурированных данных с помощью json
Существует несколько способов представить вывод программы; данные могут быть напечатаны в читаемой форме или записаны в файл для будущего использования. В этой главе будут рассмотрены некоторые из этих возможностей.

7.1. Особенности форматирования вывода
До сих пор мы сталкивались с двумя способами вывода значений: операторы выражений и функция print(). (Третий способ - это использование метода write() файловых объектов; на файл стандартного вывода можно ссылаться как на sys.stdout. См. Справку по библиотеке для дополнительной информации об этом.)

Чаще вам захочется больше контроля над форматированием вашего вывода, чем простое печатание разделенных пробелом значений. Есть два способа форматировать ваш вывод; первый способ - чтобы все строки обрабатывали сами себя; используя нарезание строк и операторы конкатенации, вы можете создать любую разметку, какое можете представить. Строковый тип имеет несколько методов, которые выполняют полезные операции для обивки строк данной шириной столбца; скоро они будут обсуждаться. Второй способ - использовать formatted string literals (docs.python.org/3/reference/lexical_analysis.html#f-strings) или метод str.format().

Модуль string (docs.python.org/3/library/string.html#module-string) содержит класс Template (docs.python.org/3/library/string.html#string.Template), который предлагает еще один способ подстановки значений в строки.

Конечно остается один вопрос: как вы конвертируете значения в строки? К счастью Python имеет способы конвертации любого значения в строку: передайте его функции repr() или str().

Функция str() подразумевалась для возврата представлений значений, которые достаточно читабельны, тогда как repr() подразумевалась для генерации представлений, которые могут быть прочитаны интерпретатором (или приведут к SyntaxError (docs.python.org/3/library/exceptions.html#SyntaxError), если не окажется эквивалентного синтаксиса). Для объектов, которые не имеют конкретного представления для восприятия человеком, str() вернет то же самое значение, что и repr(). Множество значений, такие как числа или структуры как списки и словари, имеют одинаковое представление, используя любую функцию. Строки, в частности, имеют два отдельных представления.

Несколько примеров:

>>> s = 'Hello, world.'
>>> str(s)
'Hello, world.'
>>> repr(s)
"'Hello, world.'"
>>> str(1/7)
'0.14285714285714285'
>>> x = 10 * 3.25
>>> y = 200 * 200
>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
>>> print(s)
The value of x is 32.5, and y is 40000...
>>> # repr() строки добавляет строковые кавычки и бэкслэши:
... hello = 'hello, world\n'
>>> hellos = repr(hello)
>>> print(hellos)
'hello, world\n'
>>> # Аргумент для repr() может быть любым объектом Python:
... repr((x, y, ('spam', 'eggs')))
"(32.5, 40000, ('spam', 'eggs'))"
Вот два способа вывести таблицу квадратов и кубов:

>>> for x in range(1, 11):
...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
...     # Обратите внимание на использование 'end' в предыдущей строке
...     print(repr(x*x*x).rjust(4))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
 
>>> for x in range(1, 11):
...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
(Заметьте, что в первом примере один пробел между каждым столбцом был добавлен с помощью print(): он всегда добавляет пробелы между своими аргументами.)

Этот пример демонстрирует метод строковых объектов str.rjust(), который выравнивает строку по правому краю в поле заданной ширины, заполняя ее пробелами слева. Есть схожие методы str.ljust() и str.center(). Они ничего не выводят, а просто возвращают новую строку. Если вводимая строка слишком длинная, они не урезают ее, а возвращают без изменений; это приведет в беспорядок вашу планировку столбцов, но это обычно лучше, чем альтернатива, которая выдала бы ложное значение. (Если вы действительно хотите усечь, вы всегда можете добавить оператор среза, как в x.ljust(n)[:n].)

Существует другой метод, str.zfill(), который заполняет нулями слева числовую строку. Он понимает знаки плюс и минус:

>>> '12'.zfill(5)
'00012'
>>> '-3.14'.zfill(7)
'-003.14'
>>> '3.14159265359'.zfill(5)
'3.14159265359'
Основное использование метода str.format() выглядит вот так:

>>> print('We are the {} who say "{}!"'.format('knights', 'Ni'))
We are the knights who say "Ni!
Скобки и символы внутри них (называемые полями форматирования) заменяются объектами, переданными методу str.format(). Число в скобках может быть использовано как ссылка на позицию объекта, переданного методу str.format().

>>> print('{0} and {1}'.format('spam', 'eggs'))
spam and eggs
>>> print('{1} and {0}'.format('spam', 'eggs'))
eggs and spam
Если в методе используются аргументы-ключевые слова, их значения определяются путем использования имени аргумента.

>>> print('This {food} is {adjective}.'.format(
...       food='spam', adjective='absolutely horrible'))
This spam is absolutely horrible.
Позиционные и keyword (ключевые слова - прим. пер.) аргументы могут быть произвольно скомбинированы:

>>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
                                                       other='Georg'))
The story of Bill, Manfred, and Georg.
'!a' (применяет ascii()), '!s' (применяет str()) и '!r' (применяет repr() ) могут быть использованы для конвертирования значение перед тем, как оно будет отформатировано:

>>> contents = 'eels'
>>> print('My hovercraft is full of {}.'.format(contents))
My hovercraft is full of eels.
>>> print('My hovercraft is full of {!r}.'.format(contents))
My hovercraft is full of 'eels'.
Необязательное ':' и спецификатор формата могут следовать за именем поля. Это позволяет получить больший контроль над форматированием значения. Следующий пример округляет Pi до трех знаков после точки.

>>> import math
>>> print('The value of PI is approximately {0:.3f}.'.format(math.pi))
The value of PI is approximately 3.142.
Передача целого числа после ':' создаст поле, минимальная ширина которого будет соответствовать этому числу. Это полезно для создания таблицы.

>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...     print('{0:10} ==> {1:10d}'.format(name, phone))
...
Jack       ==>       4098
Dcab       ==>       7678
Sjoerd     ==>       4127
Если у вас действительно длинная строка, которую вы не хотите разделять, будет замечательно, если вы упомяните переменные, которые форматируются по имени, вместо позиций. Это может быть сделано простой передачей словаря и использованием квадратных скобок '[]' для доступа к ключам

>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
...       'Dcab: {0[Dcab]:d}'.format(table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
Это может быть также сделано передачей таблицы в качестве аргумента-ключевого слова с использованием нотации '**'.

>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
Это особенно полезно в сочетании с функцией vars(), которая возвращает словарь, включающий все локальные переменные.

Для полного обзора строкового форматирования с помощью str.format() см. Format String Syntax (docs.python.org/3/library/string.html#formatstrings).

7.1.1. Старое форматирование строк
Оператор % также может быть использован для форматирования строки. Он интерпретирует левый аргумент так же, как sprintf()-стиль формата строки, будучи примененным к правому аргументу, и возвращает строку результата из этой форматирующей операции. Например:

>>> import math
>>> print('The value of PI is approximately %5.3f.' % math.pi)
The value of PI is approximately 3.142.
Больше информации может быть найдено в разделе printf-стиль форматирования строк.

7.2. Чтение и запись файлов
open() возвращает файловый объект (docs.python.org/3/glossary.html#term-file-object) и чаще всего используется с двумя аргументами: open(filename, mode).

>>> f = open('workfile', 'w')
Первый аргумент является строкой, содержащей имя файла. Второй аргумент - другая строка, содержащая несколько символов, описывающих способ, которым файл будет открыт. mode (режим - прим. пер.) может быть 'r', когда файл будет только читаться, 'w' - только для записи (существующий файл с таким же именем будет стерт), и 'a' открывает файл для добавления; любые данные, записанные в файл, автоматически добавляются в конец. 'r+' открывает файл как для чтения, так и записи. Аргумент mode опциональный; если он пропущен, будет назначен 'r'.

 Обычно файл открывается в текстовом режиме, это означает, что вы считываете из файла и записываете в файл строки. Файл кодируется в определенной кодировке. Если кодировка не указана, то по умолчанию она зависит от платформы (см. open()). Добавление 'b' к режиму откроет файл в режиме binary (бинарном - прим. пер.): теперь данные читаются и записываются из байтовых объектов. Этот режим следует использовать для всех файлов, которые не содержат текст.

В текстовом режиме, по-умолчанию при чтении происходит преобразование окончания строки, которое зависит от платформы (\n в Unix, \r\n в Windows) в просто \n. При записи в текстовом режиме происходит обратная конвертация. Это происходящее за сценой преобразование файловых данные прекрасно для текстовых файлов, но будет портить бинарные данные как те, что в файлах JPEG или EXE. Будьте очень осторожны, используя бинарный режим, когда читаете и пишите такие файлы.

7.2.1. Методы файловых объектов
Остальные примеры в этом разделе будут предполагать, что файловый объект под названием f уже был создан.

Считывая содержимое файла, вызовите f.read(size), который читает некоторое количество данных и возвращает их как строку (в текстовом режиме) или объект байтов (в бинарном режиме). size - необязательный числовой аргумент. Когда size пропущен или отрицателен, все содержимое файла будет прочитано и возвращено; это ваша проблема, если файл окажется вдвое больше, чем память компьютера. По-другому, наибольший размер байтов читается и возвращается. Если был достигнут конец файла, f.read() вернет пустую строку.

>>> f.read()
'This is the entire file.\n'
>>> f.read()
''
f.readline() читает одну строку (линию) из файла; символ новой строки (\n) остается в конце строки, и опускается только на последней строке файла, если файл не заканчивается новой строкой. Это делает возврат значения недвусмысленным; если f.readline() возвращает пустую строку, значит был достигнут конец файла, в то время как пустая линия представлена '\n', строкой, содержащей только одиночный символ новой линии.

>>> f.readline()
'This is the first line of the file.\n'
>>> f.readline()
'Second line of the file\n'
>>> f.readline()
''
Для чтения строк из файла, вы можете использовать цикл для обхода файлового объекта. Это эффективно для памяти, быстро и управляется простым кодом:

>>> for line in f:
...     print(line, end='')
...
This is the first line of the file.
Second line of the file
Если вы хотите считать все строки файла в список, вы можете также использовать list(f) или f.readlines().

f.write(string) записывает содержимое string в файл, возвращает количество записанных символов.

>>> f.write('This is a test\n')
15
Другие типы объектов нуждаются в конвертации - или в строку (в текстовом режиме) или объект байтов (в бинарном режиме) - перед своей записью:

>>> value = ('the answer', 42)
>>> s = str(value)  # конвертирование кортежа в строку
>>> f.write(s)
18
При двоичном режиме f.tell() возвращает целое число, указывающее для файлового объекта текущую позицию в файле, представленное как количество байтов от начала файла, и непрозрачный номер в текстовом режиме.

Чтобы изменить позицию в файловом объекте, используйте f.seek(offset, from_what). Позиция вычисляется из добавления offset (смещение - прим. пер.) к упомянутой точке; эта точка определяется аргументом from_what. Значение 0 from_what  указывает на начало файла, 1 использует текущую позицию файла и 2 - конец файла как упомянутая точка. from_what может быть опущен, что приравнивает его к 0, использованию начала файла, как отправной точки.

>>> f = open('workfile', 'rb+')
>>> f.write(b'0123456789abcdef')
16
>>> f.seek(5)      # Идем к 6-му байту в файле
5
>>> f.read(1)
b'5'
>>> f.seek(-3, 2)  # Идем к третьему байту с конца
13
>>> f.read(1)
b'd'
В текстовых фалах (тех, что были открыты без 'b') seek разрешен только относительно начала файла (исключение - ищет самый конец файла с помощью seek(0, 2)), и единственными допустимыми значениями смещения являются те, которые возвращаются из f.tell(), или ноль. Любое другое значение смещения вызывает неопределенное поведение.

Когда вы закончите с файлом, вызовите f.close(), чтобы закрыть его и освободить какие-либо системные ресурсы, занятые открытым файлом. После вызова f.close(), попытки использовать файловый объект будут приводить к автоматическому сбою.

>>> f.close()
>>> f.read()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: I/O operation on closed file
Хорошая практика - использовать ключевое слово with (docs.python.org/3/reference/compound_stmts.html#with), когда имеете дело с объектами-файлами. У этого есть преимущество, что файл правильно закроется после завершения его набора, даже если по пути возникнет исключение. Это также намного короче, чем писать эквивалентный try(docs.python.org/3/reference/compound_stmts.html#try)-finally(docs.python.org/3/reference/compound_stmts.html#finally) блок:

>>> with open('workfile', 'r') as f:
...     read_data = f.read()
>>> f.closed
True
Файловые объекты имеют несколько дополнительных методов, таких как isstty() и trancate(), которые используются менее часто; обратитесь к справке по библиотеке для полного экскурса по объектам-файлам.

7.2.2. Сохранение структурированных данных с помощью json
Строки могут быть легко записаны в и считаны из файла. Числа отнимают немного больше усилий, поскольку метод read() возвращает только строку, которая будет передана функции наподобие int() (docs.python.org/3/library/functions.html#int), которая примет строку как '123' и вернет ее числовое значение 123. Когда вы хотите сохранить более сложные типы данных как вложенные списки и словари, ручной разбор и сериализация становятся сложными.

Вместо того, чтобы постоянно писать и отлаживать код для сохранения сложных типов данных в файлах, Python позволяет использовать популярный формат обмена данными под названием JSON (JavaScript Object Notation) (json.org/). Стандартный модуль под названием json (docs.python.org/3/library/json.html#module-json) может принимать иерархии данных Python и конвертировать их в строковое представление; этот процесс называется serializing (сериализация, упорядочивание, издание выпусками - прим. пер.). Реконструкция данных из строкового представления называется deserializing. Между сериализацией и десереализацией строковое представление объекта может быть сохранено в файле или данных, или отправлено по сетевому соединению удаленному компьютеру.

Обратите внимание: Формат JSON обычно используется современными приложениями для позволения обмена данными. Много программистов уже хорошо знакомы с ним, что хорошо для совместимости.

Если у вас есть объект x, вы можете взглянуть на его JSON представление в виде строки с помощью одной строки кода:

>>> json.dumps([1, 'simple', 'list'])
'[1, "simple", "list"]'
Другой вариант функции dumps() (docs.python.org/3/library/json.html#json.dumps), называемый dump() (docs.python.org/3/library/json.html#json.dump), просто сериализует объект в текстовый файл (docs.python.org/3/glossary.html#term-text-file). Так если f - текстовый файловый объект, открытый на запись, мы можем сделать это:

json.dump(x, f)
Для декодирования объекта опять если f - текстовый файл, который был открыт для чтения:

x = json.load(f)
Это простая техника сериализации может обрабатывать списки и словари, но сериализация объектов произвольных классов в JSON требует немного больше дополнительных усилий. Обратитесь к справке по модулю json, содержащей объяснение этого.

См. также: pickle (docs.python.org/3/library/pickle.html#module-pickle) - модуль pickle

В противоположность JSON, pickle - протокол, который позволяет сериализацию произвольных объектов Python. Как таковой он специфичен для Python и не может использоваться для взаимодействия с приложениями, написанными на других языках. Он также небезопасен по-умолчанию: десериализация данных pickle, приходящих из ненадежных источников, может выполнить произвольный код, если данные были созданы опытным злоумышленником.