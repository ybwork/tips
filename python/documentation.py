1. Разжигая ваш аппетит
Если вы много работаете на компьютерах, в конце концов обнаружите, что есть некоторые задачи, которые вы хотели бы автоматизировать. Так возможно вам хочется выполнить операцию поиска и замены над большим количеством текстовых файлов, или переименовать и переупорядочить группу файлов фотографий со сложным путем к ним. Возможно вы хотели бы написать маленькую пользовательскую базу данных или специализированное GUI-приложение или простую игру.

Если вы профессиональный разработчик программного обеспечения, вам возможно приходится работать с несколькими C/C++/Java библиотеками, но вы находите обычный цикл записи/компиляции/тестирования/перекомпиляции слишком медленным. Возможно вы пишете набор тестов для такой библиотеки и находите написание тестирующего кода утомительной задачей. Или, может быть, вы написали программу, которая может использовать язык расширения, и не хотите разрабатывать и реализовывать целый новый язык для вашего приложения.

Python - просто язык для вас.

Вы могли бы написать скрипт для командной оболочки Unix или пакеты файлов Windows для некоторых подобных задач, но shell-скрипты самое лучшее для перемещения окружающих файлов и изменении текстовых данных, не очень хорошо подходит для GUI-приложений или игр. Вы могли бы написать C/C++/Java программу, но это может занять много времени разработки, чтобы получить даже первый черновой вариант программы. Python проще в использовании, доступен на операционных системах Windows, Mac OS X и Unix и поможет сделать эту работу более быстро.

Python прост в использовании, но это реальный язык программирования, предлагающий намного больше структуры и поддержки для больших программ, чем могут предложить shell-скрипты или пакеты файлов. С другой стороны, Python также предлагает намного больше проверки ошибок, чем C, и, будучи весьма высоко-уровневым языком, он имеет встроенные высоко-уровневые типы данных, такие как гибкие массивы данных и словари. Из-за его более общих типов данных Python применим к гораздо более обширной сфере проблем, чем Awk или даже Perl, однако многое по меньшей мере также легко сделать в Python, как и в тех языках.

Python позволяет разделить вашу программу на модули, которые могут быть повторно использованы в других программах на Python. Он поставляется с большой коллекцией стандартных модулей, которые вы можете использовать в качестве основы ваших программ, или в качестве примеров, чтобы начать обучение программировать на Python. Некоторые из этих модулей предоставляют такие вещи как файловый ввод/вывод, системные вызовы, сокеты и даже интерфейсы инструментария GUI, такого как Tk.

Python - интерпретируемый язык, который может сберечь вам много времени в процессе разработки программы, т. к. нет необходимости в компиляции и компоновке. Интерпретатор может использоваться в интерактивном режиме, который позволяет легко экспериментировать с особенностями языка, писать одноразовые программы или тестировать функции при разработке программ "снизу вверх". Это также удобный настольный калькулятор.

Python позволяет программам быть написанными компактно и читаемо. Программы, написанные на Python, обычно намного короче, чем эквивалентные программы на C, C++ или Java, по нескольким причинам:

высоко-уровневые типы данных позволяют вам выражать комплекс операций в одном высказывании;
группировка высказываний осуществляется отступом, а не скобками начала и конца;
нет необходимости в объявлении переменных или аргументов.
Python расширяем: если вы знаете, как программировать на C, то легко добавите в интерпретатор встроенную функцию или модуль как для выполнения критических операций на максимальной скорости, так и свяжите Python-программу с библиотеками, которые могут быть доступны только в бинарной форме (такие как графические библиотеки конкретного производителя). Когда действительно войдете во вкус, можете связывать интерпретатор Python с приложениями, написанными на C, и использовать его, как язык расширения или команд для того приложения.

Кстати, язык назван в честь шоу BBC “Monty Python’s Flying Circus” ("Летающий цирк Монти Пайтона") и не имеет ничего общего с рептилиями. Создание ссылок на пародии Монти Пайтона в документации не только позволительно, это приветствуется!

Теперь когда вы все взволнованы Python, вы захотите изучить его более детально. Поскольку лучшим способом выучить язык является его использование, учебник приглашает вас поиграть с интерпретатором Python во время чтения.

В следующей главе объясняется принцип использования интерпретатора. Это довольно обыденная информация, но следует опробовать примеры, приведенные ниже.

Остальная часть учебника знакомит с различными особенностями языка Python и системы на примерах, начиная с простых выражений, высказываний и типов данных, через функции и модули, и, наконец, касаясь продвинутых концепций, таких как исключения и пользовательские классы.

2. Использование интерпретатора Python
2.1. Вызов интерпретатора
Интерпретатор Python обычно устанавливается по адресу /usr/local/bin/python3.6 на тех машинах, где это возможно; размещение в /usr/local/bin делает возможным поиску пути вашей командной оболочки Unix запустить его, набрав команду:

python3.6
в оболочке. [1] Поскольку выбор каталога, в котором находится интерпретатор, определяется установкой, то возможны другие места; свяжитесь с вашим местным гуру Python или системным администратором. (Например, /usr/local/python распространенное альтернативное место.)

Как правило, на компьютерах с Windows установка Python производится в C:\Python36, хотя вы можете изменить это в процессе установки. Чтобы добавить эту директорию к вашему пути, вы можете ввести следующую команду в командной строке DOS:

set path=%path%;C:\python36
Ввод символа конца файла (Control-D на Unix, Control-Z на Windows) в строке приглашения заставляет интерпретатор выйти со статусом нулевого выхода. Если это не работает, вы можете выйти из интерпретатора, введя следующую команду: quit().

Особенности строки ввода интерпретатора включают интерактивное редактирование, подстановка истории и завершение кода на системах, которые поддерживают readline (библиотеку, осуществляющую совместное с оболочкой автозавершение - прим. пер.). Вероятно самый быстрый способ увидеть, поддерживается ли редактирование командной строки, это ввести Control-P в первой строке приглашения Python, полученной вами. Если есть звуковой сигнал, то у вас редактируемая командная строка; см. дополнение Редактирование интерактивного ввода и подстановка истории для знакомства с ключами. Если ничего не происходит или если ^P повторяется, то редактирование командной строки недоступно; вы сможете только использовать Backspace для удаления символов из текущей строки.

В некоторой степени интерпретатор работает как оболочка Unix: при вызове со стандартного ввода, подключенного к устройству tty, он читает и выполняет команды интерактивно; при вызове с именем файла в качестве аргумента или с файлом в качестве стандартного ввода, он читает и выполняет скрипт из этого файла.

Второй способ запуска интерпретатора: python -c command [arg] ..., который выполняет оператор(ы) в command, аналогично опции -c (docs.python.org/3/using/cmdline.html#cmdoption-c) командной оболочки. Поскольку выражения Python часто содержат пробелы или другие символы, которые имеют специальное значение для оболочки, то обычно рекомендуется цитировать command целиком в одинарных кавычках.

Некоторые модули Python также полезны как скрипты. Они могут быть вызваны с помощью python -m module [arg] ..., который выполняет код файла module, как если бы вы написали его полное имя в командной строке.

При использовании файла скрипта, иногда полезно иметь возможность запустить скрипт и потом войти в интерактивный режим. Это может быть сделано путем передачи -i (docs.python.org/3/using/cmdline.html#cmdoption-i) перед скриптом.

Все опции командной строки описаны в Command line and environment (docs.python.org/3/using/cmdline.html#using-on-general).

2.1.1. Передача аргумента
Как известно для интерпретатора имя скрипта и дополнительные аргументы впоследствии превращаются в список строк и присваиваются переменной argv модуля sys. Вы можете обращаться к этому списку, выполняя import sys. Длина списка по крайней мере равна одному; когда не передано ни одного скрипта и аргумента, то sys.argv[0] является пустой строкой. Когда имя скрипта передается как '-' (означает стандартный ввод), sys.argv[0] устанавливается в '-'. При использовании -c (docs.python.org/3/using/cmdline.html#cmdoption-c) command, sys.argv[0] устанавливается в '-c'. При использовании -m (docs.python.org/3/using/cmdline.html#cmdoption-m) module, sys.argv[0] устанавливается к полному имени местонахождения модуля. Опции, обнаруженные после -c (docs.python.org/3/using/cmdline.html#cmdoption-c) command или -m (docs.python.org/3/using/cmdline.html#cmdoption-m) module не потребляются обработчиком опций интерпретатора Python, а оставляются в sys.argv для обработки командой или модулем.

2.1.2. Интерактивный режим
Когда команды считываются из tty (терминала - прим. пер.), интерпретатору говорится быть в interactive mode (интерактивном режиме - прим. пер.). В этом режиме он предлагает ввести следующую команды с primary promp (первичного приглашения - прим. пер.), обычно три знака "больше, чем" (>>>); для продолжения строк он подсказывает с secondary prompt (вторичного приглашения - прим. пер.), по умолчанию три точки (...). Интерпретатор выводит приветственное сообщение, начинающееся с его номера версии и уведомления об авторских правах, перед выводом первого приглашения:

$ python3.6
Python 3.6 (default, Sep 16 2015, 09:25:04)
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
Продолжение строк необходимо при вводе многострочной конструкции. В качестве примера посмотрите на это выражение if (docs.python.org/3/reference/compound_stmts.html#if):

>>> the_world_is_flat = True
>>> if the_world_is_flat:
...     print("Be careful not to fall off!")
...
Be careful not to fall off!
Чтобы узнать больше об интерактивном режиме, смотрите Интерактивный режим.

2.2. Интерпретатор и его окружение
2.2.1. Кодировка исходного кода
По умолчанию исходные файлы Python рассматриваются как кодированные в UTF-8. В этой кодировке символы большинства языков мира могут быть использованы одновременно в строковых литералах, идентификаторах и комментариях - хотя стандартная библиотека использует только символы ASCII для идентификаторов, это соглашение, которому должен следовать любой переносимый код. Чтобы отобразить все эти символы должным образом, ваш редактор должен распознавать, что файл в кодировке UTF-8, и он должен использовать шрифт, который поддерживает все символы в файле.

Чтобы объявить кодировку отличную от той, что используется по-умолчанию, первой строкой файла должна быть добавлена специальная строка комментария. Синтаксис такой как следующий:

# -*- coding: encoding -*-
где encoding одна из действующих codecs (docs.python.org/3/library/codecs.html#module-codecs), поддерживаемых Python.

Например, чтобы объявить, что используется кодировка Windows-1252, первая строка в вашем файле исходного кода должна быть:

# -*- coding: cp-1252 -*-
Есть одно исключение из правила первой строки: когда исходный код начинается с UNIX "shebang" line. В этом случае объявление кодировки должно быть добавлено второй строкой файла. Например:

#!/usr/bin/env python3
# -*- coding: cp-1252 -*-
Примечания

[1] В Unix интерпретатор Python 3.x не устанавливается по-умолчанию с исполняемым именем python, так что нет конфликта с одновременно установленным Python 2.x.

Неформальное введение в Python
Использование Python в качестве калькулятора
Числа
Строки
Списки
Первые шаги к программированию
В следующих примерах ввод и вывод различаются присутствием или отсутствием приглашений (>>> (docs.python.org/3/glossary.html#term) и ... (docs.python.org/3/glossary.html#term-1)): чтобы повторить пример, вы должны ввести все после приглашения, когда оно появляется; строки, которые не начинаются с приглашения, являются выводом интерпретатора. Заметьте, что вторичное приглашение на отдельной строке в примере означает, что вы должны ввести пустую строку; это используется для окончания многострочной команды.

Многие из примеров в данном руководстве, даже те, которые вводятся в интерактивном режиме, включают комментарии. Комментарии в Python начинаются с хэш-символа # и продолжаются до конца физической строки. Комментарий может появиться в начале строки или после пробела или кода, но не внутри строкового литерала. Хэш-символ внутри строки - это просто хэш-символ. Так как комментарии являются пояснением кода и не интерпретируются Python, они могут быть опущены при работе с примерами.

Несколько примеров:

# это первый комментарий
spam = 1  # а это второй комментарий
          # ... и теперь третий!
text = "# Это не комментарий, т. к. это находится внутри кавычек."
3.1. Использование Python в качестве калькулятора
Испытаем несколько простых команд Python. Запустите интерпретатор и дождитесь первичного приглашения >>>. (Это не должно занять много времени.)

3.1.1. Числа
Интерпретатор действует как простой калькулятор: вы можете ввести в него выражение, и он выведет результат. Синтаксис выражения простой: операторы +, -, * и / работают также как в большинстве других языках (например, Pascal или C); круглые скобки могут быть использованы для группировки. Например:

>>> 2 + 2
4
>>> 50 - 5*6
20
>>> (50 - 5*6) / 4
5.0
>>> 8 / 5  # деление всегда возвращает число с плавающей точкой
1.6
Целые числа (например, 2, 4, 20) имеют тип int, другие с дробной частью (например, 5.0, 1.6) имеют тип float. Далее в учебнике мы подробнее познакомимся с числовыми типами.

Деление (/) всегда возвращает вещественное число. Чтобы выполнить floor division (docs.python.org/3/glossary.html#term-floor-division) и получить целый результат (отбрасыванием какой-либо дробной части), вы можете использовать оператор //; для вычисления остатка можете использовать %:

>>> 17 / 3  # классическое деление возвращает вещественное число
5.666666666666667
>>>
>>> 17 // 3  # деление нацело отбрасывает дробную часть
5
>>> 17 % 3  # оператор % возвращает остаток от деления
2
>>> 5 * 3 + 2  # результат * делитель + остаток
17
В Python возможно использовать оператор ** для вычисления степени [1]:

>>> 5 ** 2  # 5 в квадрате
25
>>> 2 ** 7  # 2 в степени 7
128
Знак равенства (=) используется для присваивания значения переменной. При этом никакого результата не отображается перед следующим интерактивным приглашением:

>>> width = 20
>>> height = 5 * 9
>>> width * height
900
Если переменная не "определена" (не присвоено значение), попытка использовать ее выдаст вам ошибку:

>>> n  # попытка доступа к неопределенной переменной
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined
Есть полная поддержка для чисел с плавающей точкой; операторы со смешанными типами операндов конвертируют целый операнд в число с плавающей точкой:

>>> 3 * 3.75 / 1.5
7.5
>>> 7.0 / 2
3.5
В интерактивном режиме последнее выведенное выражение присваивается переменной _. Это означает, что когда вы используете Python как настольный калькулятор, то в какой-то степени легче продолжать вычисления, например:

>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
Эту переменную следует рассматривать только как предназначенную для чтения пользователем. Не присваивайте ей значение явно - вы создадите независимую локальную переменную с таким же именем, маскирующую встроенную переменную с ее волшебным поведением.

В дополнение к int и float Python поддерживает другие типы чисел, такие как Decimal (docs.python.org/3/library/decimal.html#decimal.Decimal) и Fraction (docs.python.org/3/library/fractions.html#fractions.Fraction). Python также имеет встроенную поддержку для комплексных чисел и использует суффикс j или J для обозначения мнимой части (например, 3+5j).

3.1.2. Строки
Кроме чисел Python также может манипулировать строками, которые могут быть описаны несколькими способами. Они могут быть заключены в одинарные кавычки ('...') или двойные кавычки ("...") с одинаковым результатом [2]. \ может быть использован для экранирования кавычек:

>>> 'spam eggs'  # одинарные кавычки
'spam eggs'
>>> 'doesn\'t'  # используйте \' для экранирования одиночной кавычки...
"doesn't"
>>> "doesn't"  # ...или вместо этого используйте двойные кавычки
"doesn't"
>>> '"Yes," he said.'
'"Yes," he said.'
>>> "\"Yes,\" he said."
'"Yes," he said.'
>>> '"Isn\'t," she said.'
'"Isn\'t," she said.'
В интерактивном интерпретаторе выводящаяся строка заключена в кавычки и специальные символы экранируются бэкслешами. В то же время это может иногда отличаться от ввода (заключающие кавычки могли измениться), две строки эквивалентны. Строка заключена в двойные кавычки, если она включает одинарные, при этом двойные кавычки отсутствуют, иначе она заключена в одинарные кавычки. Функция print() создает более читабельный вывод, опуская ограждающие кавычки и интерпретируя экранируемые и специальные символы:

>>> '"Isn\'t," she said.'
'"Isn\'t," she said.'
>>> print('"Isn\'t," she said.')
"Isn't," she said.
>>> s = 'First line.\nSecond line.'  # \n означает новую строку
>>> s  # без print(), \n содержится в выводе
'First line.\nSecond line.'
>>> print(s)  # с print(), \n создает новую строку
First line.
Second line.
Если вы не хотите, чтобы символы, которым предшествует \, интерпретировались как специальные, то можете использовать raw string (сырые строки - прим. перев.), добавив r перед первой кавычкой:

>>> print('C:\some\name')  # здесь \n означает новую строку!
C:\some
ame
>>> print(r'C:\some\name')  # обратите внимание на r перед кавычкой
C:\some\name
Строковые литералы могут охватывать множество строк. Один способ - это использование тройных кавычек: """...""" или '''...'''. Конец строки по-умолчанию обозначает переход на новою, но есть возможность предотвратить это, добавив \ в конец строки. Следующий пример:

print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
дает следующий вывод (заметьте, что начальная новая строка не включена):

Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
Строки могут быть соединены (склеены вместе) оператором + и повторены с помощью *:

>>> # 3 раза 'un' с последующим 'ium'
>>> 3 * 'un' + 'ium'
'unununium'
Два или более строковых литерала (т. е. когда каждый заключен в кавычки), следующих друг за другом, автоматически конкатенируются.

>>> 'Py' 'thon'
'Python'
Однако это работает только с двумя литералами, но не с переменными или выражениями:

>>> prefix = 'Py'
>>> prefix 'thon'  # не может соединить переменную и строковый литерал
  ...
SyntaxError: invalid syntax
>>> ('un' * 3) 'ium'
  ...
SyntaxError: invalid syntax
Если вы хотите конкатенировать переменные или переменную и литерал, используйте +:

>>> prefix + 'thon'
'Python'
Это свойство особенно полезно, когда вы хотите разорвать длинную строку:

>>> text = ('Put several strings within parentheses '
            'to have them joined together.')
>>> text
'Put several strings within parentheses to have them joined together.'
Строка может быть проиндексирована, первый символ имеет индекс 0. Отдельный символьный тип отсутствует, символ - это просто строка единичной размерностью:

>>> word = 'Python'
>>> word[0]  # символ в позиции 0
'P'
>>> word[5]  # символ в позиции 5
'n'
Индексы также могут быть отрицательными числами для начала отсчета справа:

>>> word[-1]  # последний символ
'n'
>>> word[-2]  # второй с конца символ
'o'
>>> word[-6]
'P'
Заметьте, что поскольку -0 - это тоже самое, что 0, то отрицательные индексы начинаются с -1.

В дополнение к индексации также поддерживаются срезы. В то время как индексация используется, чтобы получать отдельные символы, срезы позволяют вам получать подстроки:

>>> word[0:2]  # символы от позиции 0 (включая) до 2 (исключая) 
'Py'
>>> word[2:5]  # символы от позиции 2 (включая) до 5 (исключая) 
'tho'
Заметьте, что начало всегда включается, а конец всегда исключается. Это обеспечивает то, что s[:i] + s[i:] всегда равно s:

>>> word[:2] + word[2:]
'Python'
>>> word[:4] + word[4:]
'Python'
Индексация срезов имеет полезные свойства по умолчанию; опущенный первый индекс по умолчанию обозначает ноль, опущенный второй индекс по умолчанию обозначает размер строки, с которой берется срез.

>>> word[:2]  # символ от начала до позиции 2 (исключая)
'Py'
>>> word[4:]  # символ от позиции 4 (включая) до конца 
'on'
>>> word[-2:] # символы от второго с конца (включая) до конца
'on'
Один из способов запомнить, как работают срезы, - это думать об индексах как указывающих между символами, левый край первого символа нумеруется 0. Тогда как правый край последнего символа строки из n символов имеет индекс n, например:

 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
Первый ряд чисел дает позицию индексов 0...6 в строке; второй ряд дает соответствующие отрицательные индексы. Срез от i до j состоит из всех символов между краями, отмеченными i и j соответственно.

Для неотрицательных индексов длина среза представляет собой разность индексов, если оба находятся в границах. Например, длина word[1:3] равна 2.

Попытка использовать индекс, который является слишком большим, приведет к ошибке:

>>> word[42]  # у word только 6 символов
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
Однако индексы вне диапазона обрабатываются корректно при использовании для взятия среза:

>>> word[4:42]
'on'
>>> word[42:]
''
Строки Python не могут быть изменены - они неизменяемы (docs.python.org/3/glossary.html#term-immutable). Поэтому присвоение по индексированной позиции в строке приводит к ошибке:

>>> word[0] = 'J'
  ...
TypeError: 'str' object does not support item assignment
>>> word[2:] = 'py'
  ...
TypeError: 'str' object does not support item assignment
Если вам нужна другая строка, следует создать новую строку:

>>> 'J' + word[1:]
'Jython'
>>> word[:2] + 'py'
'Pypy'
Встроенная функция len() возвращает длину строки:

>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34
Смотрите также:

Тип текстовой последовательности — str 
Строки являются примером типов последовательностей и поддерживают обычные операции, поддерживаемые такими типами.
Методы строк 
Строки поддерживают большое число методов для основных преобразований и поиска.
Formatted string literals (docs.python.org/3/reference/lexical_analysis.html#f-strings)
Строковые литералы со встроенными выражениями.
Format String Syntax (docs.python.org/3/library/string.html#formatstrings)
Информация о форматировании строк с помощью str.format().
printf-стиль форматирования строки
Старые операции форматирования вызываются, когда строки являются левым операндом оператора %, описанного более подробно здесь.
3.1.3. Списки
Python'у известно определенное количество сложных типов данных, используемых для группировки разных значений. Наиболее гибким является list (список - прим. пер.), который может быть описан как список разделенных запятой значений (элементов) между квадратными скобками. Списки могут включать элементы различных типов, но обычно все элементы имеют одинаковый тип.

>>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
Как строки (и все другие встроенные типы последовательностей (docs.python.org/3/glossary.html#term-sequence)), списки могут быть проиндексированы и из них можно брать срезы:

>>> squares[0]  # индекс возвращает элемент
1
>>> squares[-1]
25
>>> squares[-3:]  # срез возвращает новый список
[9, 16, 25]
Все операции взятия среза возвращают новый список, содержащий запрошенные элементы. Это значит, что ниже следующий срез возвращает новую (поверхностную) копию списка:

>>> squares[:]
[1, 4, 9, 16, 25]
Списки также поддерживают такую операцию как конкатенацию:

>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
В отличие от строк, которые неизменяемые (docs.python.org/3/glossary.html#term-immutable), списки являются изменяемым (docs.python.org/3/glossary.html#term-mutable) типом, т. е. есть возможность изменить их содержание:

>>> cubes = [1, 8, 27, 65, 125]  # что-то здесь не так
>>> 4 ** 3  # 4 в кубе равно 64, а не 65!
64
>>> cubes[3] = 64  # замена ошибочного значения
>>> cubes
[1, 8, 27, 64, 125]
Вы также можете добавить новый элемент в конец списка, используя метод append() (мы узнаем о методах больше позже):

>>> cubes.append(216)  # добавление куба 6-ти
>>> cubes.append(7 ** 3)  # и куба 7-ми
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
Присвоение срезов также возможно, и этим можно даже изменить размер списка или полностью его очистить:

>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # замена нескольких значений
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # теперь удалим их
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # очистим список, заменив все элементы на пустой список
>>> letters[:] = []
>>> letters
[]
Встроенная функция len() также применима к спискам:

>>> letters = ['a', 'b', 'c', 'd']
>>> len(letters)
4
Возможно вкладывать списки (создавать списки, включающие другие списки), например:

>>> a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0]
['a', 'b', 'c']
>>> x[0][1]
'b'
3.2. Первые шаги к программированию
Конечно мы можем использовать Python для более сложных задач, чем складывать вместе два и два. Например, мы можем написать начальную часть последовательности ряда Фибоначчи вот так:

>>> # ряд Фибоначчи:
... # сумма двух элементов определяет следующий
... a, b = 0, 1
>>> while b < 10:
...     print(b)
...     a, b = b, a+b
...
1
1
2
3
5
8
Этот пример знакомит с несколькими новыми свойствами.

Первая строка содержит множественное присваивание: переменные a и b одновременно получают новые значения 0 и 1. В последней строке это используется опять, демонстрируя, что сначала выражения с правой стороны полностью оцениваются, прежде чем произойдет какое-либо присваивание. Выражения с правой стороны выполняются слева направо.
Цикл while (docs.python.org/3/reference/compound_stmts.html#while) выполняется до тех пор, пока условие (здесь b < 10) остается верным. В Python, как в C, любое ненулевое численное значение является правдой; ноль является ложью. Условие может также быть строкой или списком, в действительности любой последовательностью; все с ненулевой длинной является правдой, пустая последовательность является ложью. Проверка, используемая в примере, является простым сравнением. Стандартные операторы сравнения записываются также как в C: < (меньше, чем), > (больше, чем), == (равно), <= (меньше или равно), >= (больше или равно) и != (не равно).
Тело цикла имеет отступ: в Python отступ - это способ группировки выражений. В интерактивном режиме вы должны ввести табуляцию или пробел(ы) для каждой строки с отступом. На практике вы будете подготавливать более сложный ввод для Python с помощью текстового редактора; все приличные текстовые редакторы имеют автоматическую установку отступов. Когда составное выражение вводится в интерактивном режиме, за ним должна следовать пустая строка, чтобы указать завершение (поскольку синтаксический анализатор не может угадать, когда вы ввели последнюю строку). Обратите внимание, что каждая строка в основном блоке должна быть с отступом на одно и то же значение.
Функция print() выводит значение переданных ей аргумента(ов). Это отличается от просто вывода выражений, которые вы хотите вывести (как мы ранее делали раньше в примерах с калькулятором) способом обработки множества аргументов, величин с плавающей точкой и строк. Строки печатаются без кавычек, и между элементами вставляются пробелы, таким образом вы можете красиво форматировать объекты, подобно этому:
>>> i = 256*256
>>> print('The value of i is', i)
The value of i is 65536
Аргумент ключевое слово end может быть использовано для отмены новой строки после вывода, или окончания вывода другой строкой:

>>> a, b = 0, 1
>>> while b < 1000:
...     print(b, end=',')
...     a, b = b, a+b
...
1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
Примечания

[1] Поскольку ** имеет более высокий приоритет, чем -, то -3**2 будет интерпретировано как -(3**2) и поэтому даст результат -9. Чтобы избежать этого и получить 9, вы можете использовать (-3)**2.

[2] В отличие от других языков специальные символы, такие как \n, имеют одинаковое значение как в одинарных ('...'), так и двойных ("...") кавычках. Разница между двумя вариантами только в том, что в одинарных кавычках вам не надо экранировать " (но вы должны экранировать \') и наоборот.

4. Управление потоком выполнения
Операторы if
Операторы for
Функция range()
Операторы break и continue, ветка else в циклах
Операторы pass
Определение функций
Дополнительно об определении функций
Значение аргументов по умолчанию
Аргументы с ключевым словом
Списки произвольных аргументов
Распаковка списков аргументов
Lambda-выражения
Строки документирования
Аннотации функций
Стиль кодирования
Кроме оператора while (docs.python.org/3/reference/compound_stmts.html#while), который только что был представлен, Python знает обычные операторы управления потоком, известные из других языков, но с некоторыми особенностями.

4.1. Операторы if
Возможно наиболее хорошо известным типом оператора является if (docs.python.org/3/reference/compound_stmts.html#if). Например:

>>> x = int(input("Пожалуйста, введите число: "))
Пожалуйста, введите число: 42
>>> if x < 0:
...     x = 0
...     print('Отрицательное изменяется на 0')
... elif x == 0:
...     print('Ноль')
... elif x == 1:
...     print('Один')
... else:
...     print('Больше')
...
Больше
Частей elif (docs.python.org/3/reference/compound_stmts.html#elif) может быть больше или не быть вообще, часть else (docs.python.org/3/reference/compound_stmts.html#else) также необязательна. Ключевое слово 'elif' есть сокращение от 'else if' и полезно для избежания излишних отступов. Последовательность if ... elif ... elif ... есть замена для операторов switch или case, встречающихся в других языках.

4.2. Операторы for
В Python оператор for (docs.python.org/3/reference/compound_stmts.html#for) немного отличается от того, что вы могли использовать в C или Pascal. Вместо того, чтобы всегда выполнять итерацию по арифметической прогрессии чисел (как в Pascal), или давая пользователю возможность определить как шаг итерации, так и условие остановки (как в C), в Python оператор for перебирает элементы любой последовательности (список или строку) в том порядке, в котором они появляются в последовательности. Например (нет намеренной игры слов):

>>> # Измерить несколько слов:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))
...
cat 3
window 6
defenestrate 12
Если вам надо изменить последовательность, вы перебираете внутри цикла (например, для дублирования выбранных элементов), рекомендуется сначала сделать копию. Выполнение итерации над последовательностью безоговорочно не создает ее копию. Взятие среза делает это особенно удобным:

>>> for w in words[:]:  # Цикл по срезу-копии целого списка.
...     if len(w) > 6:
...         words.insert(0, w)
...
>>> words
['defenestrate', 'cat', 'window', 'defenestrate']
С for w in words: пример попытался бы создать бесконечный список, вставляя defenestrate опять и опять.

4.3. Функция range()
Если вам надо перебрать последовательность чисел, пригодится встроенная функция range(). Она генерирует арифметические прогрессии:

>>> for i in range(5):
...     print(i)
...
0
1
2
3
4
Заданная конечная точка никогда не входит в генерируемую последовательность; range(10) генерирует 10 значений, индексируемые как обычная последовательность длинной 10. Возможно установить другое число в качестве начала диапазона или указать другое приращение (даже отрицательное; иногда приращение называют "шагом"):

range(5, 10)
   от 5 по 9
 
range(0, 10, 3)
   0, 3, 6, 9
 
range(-10, -100, -30)
  -10, -40, -70
Для перебора по индексам последовательности, вы можете сочетать range() и len() как в следующем примере:

>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
В большинстве подобных случаев, однако, удобно использовать функцию enumerate(), см. Приемы использования цикла.

Странная вещь случится, если вы просто напечатаете диапазон:

>>> print(range(10))
range(0, 10)
Во многих отношениях объект, возвращаемый range(), ведет себя так, как будто это список, но на самом деле это не так. Это объект, который возвращает последовательные элементы желаемой последовательности, когда вы перебираете его, но это на самом деле не список, тем самым экономится пространство.

Мы говорим, что объект является iterable (итерация, итерируемый - прим. пер.), то есть подходит в качестве цели для функций и конструкций, которые ожидают что-то, из чего они могут получить последовательные элементы, пока они не исчерпаны. Мы видели, что оператор for именно такой iterator (итератор - прим. пер.). Функций list() есть другой; она создает списки из итерируемых (перечисляемых) объектов:

>>> list(range(5))
[0, 1, 2, 3, 4]
Позже мы увидим больше функций, которые возвращают итерации и принимают итерации в качестве аргумента.

4.4. Операторы break, continue и условие else в циклах
Оператор break (docs.python.org/3/reference/simple_stmts.html#break), как и в C, прерывает выполнение вмещающего (самого внутреннего) его цикла for (docs.python.org/3/reference/compound_stmts.html#for) или while (docs.python.org/3/reference/compound_stmts.html#while).

Операторы цикла могут иметь условие else; оно выполняется, когда цикл завершается при исчерпании списка (с for) или когда условие становится ложным (с while), но не в том случае, когда цикл прерван оператором break. Это иллюстрирует следующий пример с циклом, в котором ищутся простые числа:

>>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, 'equals', x, '*', n//x)
...             break
...     else:
...         # цикл потерпел неудачу, не найдя множитель
...         print(n, 'is a prime number')
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
(Да, это корректный код. Посмотрите внимательней: условие else относится к циклу for, не к оператору if.)

При использовании с циклом условие else имеет больше общего с условием else оператора try (docs.python.org/3/reference/compound_stmts.html#try), чем if (docs.python.org/3/reference/compound_stmts.html#if): ветка else оператора try срабатывает, когда исключения не происходит, а ветка else цикла срабатывает, когда не срабатывает break. За дополнительной информацией по оператору try и исключениям, см. Обработка исключений.

Оператор continue (docs.python.org/3/reference/simple_stmts.html#continue) также заимствован из C, он продолжает выполнение со следующей итерации цикла:

>>> for num in range(2, 10):
...     if num % 2 == 0:
...         print("Found an even number", num)
...         continue
...     print("Found a number", num)
Found an even number 2
Found a number 3
Found an even number 4
Found a number 5
Found an even number 6
Found a number 7
Found an even number 8
Found a number 9
4.5. Оператор pass
Оператор pass (docs.python.org/3/reference/simple_stmts.html#pass) ничего не делает. Он может быть использован, когда синтаксически требуется какой-нибудь оператор, но программа не требует действия. Например:

>>> while True:
...     pass  # Занят ожиданием прерывания с клавиатуры (Ctrl+C)
...
Обычно это используется при создании очень маленьких классов:

>>> class MyEmptyClass:
...     pass
...
В других случаях pass может быть использован, как заполнитель функции или тела условного выражения, когда вы работаете над новым кодом, позволяя вам продолжать размышлять на более абстрактном уровне. pass  молча игнорируется:

>>> def initlog(*args):
...     pass   # Вспомните потом реализовать это!
...
4.6. Определение функций
Мы можем создать функцию, которая выводит ряд Фибоначчи до произвольной границы:

>>> def fib(n):    # выводит ряд Фибоначчи до n
...     """Печатает ряд Фибоначчи вплоть до n."""
...     a, b = 0, 1
...     while a < n:
...         print(a, end=' ')
...         a, b = b, a+b
...     print()
...
>>> # Теперь вызовем функцию, которую мы только что определили:
... fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
Ключевое слово def (docs.python.org/3/reference/compound_stmts.html#def) вводит определение функции. За ним должно следовать имя функции и в круглых скобках список формальных параметров. Выражения, которые формируют тело функции, начинаются на следующей строке и должны быть с отступом.

Опционально (не обязательно) первое выражение тела функции может быть строковым литералом; этот строковый литерал является строкой документации функции, или docstring. (Дополнительно о строках документации может быть найдено в разделе Строки документации.) Есть инструменты, которые используют строки документации для автоматического создания онлайн или печатной документации, или позволить пользователю интерактивно просматривать код; это хорошая практика включать строки документации в код, который вы пишите, так что сделайте это привычкой.

Выполнение функции вводит новую таблицу обозначений, используемую для локальных переменных функции. Точнее, все присваивания переменным в функции сохраняют значение в локальной таблице обозначений; так ссылки на переменные сначала ищутся в локальной таблице, затем в локальной таблице обрамляющих функций, затем в глобальной таблице обозначений, и наконец в таблице встроенных имен. Поэтому глобальные переменные не могут быть связаны со значением непосредственно в функции (если не названы в операторе global (docs.python.org/3/reference/simple_stmts.html#global)), хотя на них можно ссылаться.

Фактические параметры (аргументы) при вызове функции вводятся в ее локальную таблицу имен; таким образом, аргументы передаются с помощью вызова по значению (где значение всегда ссылка на объект, не значение объекта). [1] Когда функция вызывает другую функцию, создается новая локальная таблица имен для этого вызова.

Определение функции вводит ее имя в текущую таблицу обозначений. Значение имени функции имеет тип, который распознается интерпретатором как определенная пользователем функция. Это значение может быть связано с другим именем, которое затем может также быть использовано как функция. Это служит в качестве общего механизма переименования:

>>> fib
<function fib at 10042ed0>
>>> f = fib
>>> f(100)
0 1 1 2 3 5 8 13 21 34 55 89
Придя из других языков, вы можете подумать, что объект fib не функция, а процедура, поскольку она не возвращает значение. В действительности даже функции без оператора return (docs.python.org/3/reference/simple_stmts.html#return) делают возврат значения, хотя довольно скучный. Это значение называется None (это встроенное имя). Вывод значения None обычно подавляется интерпретатором, если это будет только записанное значение. Вы можете увидеть это, если захотите с помощью print():

>>> fib(0)
>>> print(fib(0))
None
Просто написать функцию, которая возвращает список чисел ряда Фибоначчи, вместо их вывода:

>>> def fib2(n): # возвращает ряд Фибоначчи вплоть до n
...     """Возвращает список, включающий ряд Фибоначчи вплоть до n."""
...     result = []
...     a, b = 0, 1
...     while a < n:
...         result.append(a)    # смотри ниже
...         a, b = b, a+b
...     return result
...
>>> f100 = fib2(100)    # вызов
>>> f100                # вывод результата
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
Этот пример, как обычно, демонстрирует некоторые особенности Python:

Оператор return (docs.python.org/3/reference/simple_stmts.html#return) возвращает значение из функции. return без выражения аргумента возвращает None. Выполнение функции до конца также возвращает None.
Выражение result.append(a) вызывает метод спискового объекта result. Метод - это функция, которая "принадлежит" объекту и называется obj.methodname, где obj - это какой-либо объект (это может быть выражение), а methodname - имя метода, который определен типом объекта. Различные типы определяют разные методы. Методы разных типов могут иметь одинаковые имена, при этом не возникает неоднозначности. (Возможно определить ваши собственные типы объектов и методы, используя классы, см. Классы.) Метод append(), показанный в примере, определен для списковых объектов; он добавляет новый элемент в конец списка. В данном примере это эквивалентно result = result + [a], но более эффективно.
4.7. Подробнее об определении функций
Также возможно определять функции с переменным числом аргументов. Есть три формы, которые могут быть комбинированы.

4.7.1. Значения аргументов по умолчанию
Наиболее полезная форма - это указать значение по умолчанию для одного или более аргументов. Это создает функцию, которая может быть вызвана с меньшим количеством аргументов, чем это определено по умолчанию. Например:

def ask_ok(prompt, retries=4, reminder='Please try again!'):
    while True:
        ok = input(prompt)
        if ok in ('y', 'ye', 'yes'):
            return True
        if ok in ('n', 'no', 'nop', 'nope'):
            return False
        retries = retries - 1
        if retries < 0:
            raise ValueError('invalid user response')
        print(reminder)
Эта функция может быть вызвана несколькими способами:

передачей только обязательного аргумента: ask_ok('Do you really want to quit?')
передачей одного из необязательных аргументов: ask_ok('OK to overwrite the file?', 2)
или даже передачей всех аргументов: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')
Этот пример также знакомит с ключевым словом in (docs.python.org/3/reference/expressions.html#in). Оно проверяет содержит ли последовательность определенное значение.

Значения по умолчанию вычисляются в точке определения функции в области определения, так что

i = 5
 
def f(arg=i):
    print(arg)
 
i = 6
f()
напечатает 5.

Важное предупреждение: Значение по умолчанию вычисляется только один раз. Это создает различие, когда по умолчанию задается изменяемый объект, такой как список, словарь или экземпляры большинства классов. Например, следующая функция накапливает переданные ей аргументы на последующие вызовы:

def f(a, L=[]):
    L.append(a)
    return L
 
print(f(1))
print(f(2))
print(f(3))
Это напечатает

[1]
[1, 2]
[1, 2, 3]
Если вы не хотите, чтобы по умолчанию было разделено между последующими вызовами, то можете написать функцию как эта:

def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
4.7.2. Аргументы с ключевым словом
Функции также могут быть вызваны с использованием keyword arguments (docs.python.org/3/glossary.html#term-keyword-argument) вида kwarg=value. Например, следующая функция:

def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")
принимает один обязательный аргумент (voltage) и три необязательных (state, action и type). Эта функция может быть вызвана любым из следующих способов:

parrot(1000)                                          # 1 позиционный аргумент
parrot(voltage=1000)                                  # 1 аргумент ключевое слово
parrot(voltage=1000000, action='VOOOOOM')             # 2 аргумента ключевых слова
parrot(action='VOOOOOM', voltage=1000000)             # 2 аргумента ключевых слова
parrot('a million', 'bereft of life', 'jump')         # 3 позиционных аргумента
parrot('a thousand', state='pushing up the daisies')  # 1 позиционный, 1 ключевое слово
но все следующие вызовы будут считаться недействительными:

parrot()                     # опущен обязательный аргумент
parrot(voltage=5.0, 'dead')  # аргумент без ключевого слова после аргумента с ключевым словом
parrot(110, voltage=220)     # дублирование значения для одного и того же аргумента
parrot(actor='John Cleese')  # неизвестный аргумент ключевое слово
В вызове функции аргументы с ключевыми словами должны следовать после позиционных аргументов. Все передаваемые аргументы с ключевым словом должны соответствовать одному из аргументов, принимаемых функцией (например, actor не действительный аргумент для функции parrot), и их порядок не важен. Это также включает неопциональные аргументы (например, parrot(voltage=1000) также верно). Ни один аргумент не может получить значение более, чем один раз. Вот пример, который не работает из-за этого ограничения:

>>> def function(a):
...     pass
...
>>> function(0, a=0)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: function() got multiple values for keyword argument 'a'
Когда конечные формальные параметры представлены в форме **name, функция принимает словарь (см. Типы отображений — dict), включающий все аргументы с ключевыми словами за исключением тех, которые уже соответствуют формальным параметрам. Это может быть скомбинировано с формальным параметром в форме *name (описано в следующем подразделе), который получает кортеж, включающий позиционные аргументы за списком формальных параметров. (*name должен находиться перед **name.) Например, если мы определяем функцию, как эту:

def cheeseshop(kind, *arguments, **keywords):
    print("-- Do you have any", kind, "?")
    print("-- I'm sorry, we're all out of", kind)
    for arg in arguments:
        print(arg)
    print("-" * 40)
    keys = sorted(keywords.keys())
    for kw in keys:
        print(kw, ":", keywords[kw])
Она может быть вызвана так:

cheeseshop("Limburger", "It's very runny, sir.",
           "It's really very, VERY runny, sir.",
           shopkeeper="Michael Palin",
           client="John Cleese",
           sketch="Cheese Shop Sketch")
и конечно было бы выведено:

-- Do you have any Limburger ?
-- I'm sorry, we're all out of Limburger
It's very runny, sir.
It's really very, VERY runny, sir.
----------------------------------------
client : John Cleese
shopkeeper : Michael Palin
sketch : Cheese Shop Sketch
Заметьте, что порядок, в котором аргументы с ключевыми словами выводятся обязательно соответствуют порядку, в котором они были переданы в функцию при вызове.

4.7.3. Произвольные списки аргументов
Наконец, реже используется возможность вызова функции с произвольным числом аргументов. Эти аргументы будут обернуты в кортеж (см. Кортежи и последовательности). Перед переменным числом аргументов могут быть обычные аргументы или не быть ни одного.

def write_multiple_items(file, separator, *args):
    file.write(separator.join(args))
Как правило, эти variadic аргументы будут последними в списке формальных параметров, потому что они собирают все оставшиеся вводимые аргументы, которые передаются в функцию. Любые формальные параметры, которые находятся после параметра *args являются аргументами "только по ключевому слову", это означает, что они могут быть использованы только в качестве ключевых слов, а не позиционных аргументов.

>>> def concat(*args, sep="/"):
...    return sep.join(args)
...
>>> concat("earth", "mars", "venus")
'earth/mars/venus'
>>> concat("earth", "mars", "venus", sep=".")
'earth.mars.venus'
4.7.4. Распаковка списков аргументов
Происходит обратная ситуация, когда аргументы уже в списке или кортеже, но должны быть распакованы при вызове функции, требующей отдельных позиционных аргументов. Например, встроенная функция range() ожидает отдельных аргументов start и stop. Если они не доступны по отдельности, записывают вызов функции с *-оператором для распаковки аргументов из списка или кортежа:

>>> list(range(3, 6)) # нормальный вызов с отдельными аргументами
[3, 4, 5]
>>> args = [3, 6]
>>> list(range(*args)) # вызов с аргументами, распакованными из списка
[3, 4, 5]
В такой же форме словари могут поставлять аргументы с ключевым словом с помощью **-оператора:

>>> def parrot(voltage, state='a stiff', action='voom'):
...     print("-- This parrot wouldn't", action, end=' ')
...     print("if you put", voltage, "volts through it.", end=' ')
...     print("E's", state, "!")
...
>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
>>> parrot(**d)
-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !
4.7.5. Lambda-выражения
С помощью ключевого слова lambda (docs.python.org/3/reference/expressions.html#lambda) может быть создана маленькая анонимная функция. Эта функция возвращает сумму ее двух аргументов: lambda a, b: a+b. Lambda-функции могут быть использованы там, где требуются объекты-функции. Синтаксически они ограничены одним выражением. Семантически они являются просто синтаксическим сахаром для обычного определения функции. Как вложенные определения функции lambda-функции могут ссылаться на переменные из содержащей области:

>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
Пример выше использует lambda-выражения для возврата функции. Другое использование - это передать небольшую функцию в качестве аргумента:

>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
>>> pairs.sort(key=lambda pair: pair[1])
>>> pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]
4.7.6. Строки документации
Здесь несколько соглашений о содержании и форматировании строк документации.

Первой строке всегда следует быть короткой, краткая сводка назначения объекта. Для краткости не следует явно указывать имя или тип объекта, поскольку они доступны другими способами (за исключением, если имя оказывается глаголом, описывающим операцию функции). Эта строка должна начинаться с заглавной буквы и заканчиваться точкой.

Если есть еще строки документации, вторая должна быть пустой, визуально отделяя сводку от остального описания. Следующие строки должны представлять собой один или несколько параграфов, описывающих соглашения о вызовах объекта, его побочные эффекты и т.д.

Анализатор Python не удаляет отступ из многострочных строковых литералов, так что инструменты, которые обрабатывают документацию, должны удалять отступы, если это необходимо. Это делается с помощью следующего соглашения. Первый непустая линия после первой строки определяет размер отступа для всей строки документации. (Мы не можем использовать первую строку, поскольку она, как правило, примыкает к открывающим кавычкам строки, так что ее отступ не является очевидным в строковом литерале.) Пробелы "эквивалентные" этому отступу затем удаляются из начала всех линий строки. Линий с меньшим отступом быть не должно, но если они есть, все их ведущие пробелы должны удаляться. Эквивалентность пробелов должна быть проверена после расширения табуляций (до 8 пробелов, как правило).

Вот пример многострочной строки документации:

>>> def my_function():
...     """Do nothing, but document it.
...
...     No, really, it doesn't do anything.
...     """
...     pass
...
>>> print(my_function.__doc__)
Do nothing, but document it.
 
    No, really, it doesn't do anything.
4.7.7. Аннотации функций
Function annotations (docs.python.org/3/reference/compound_stmts.html#function) являются полностью необязательными метаданными о типах, используемых пользовательскими функциями (см. PEP 484 (python.org/dev/peps/pep-0484) для получения дополнительной информации).

Аннотации хранятся в атрибуте __annotations__ функции как словарь и не имеют никакого эффекта на любую другую часть функции. Параметры аннотаций определяются двоеточием после имени параметра, за которым следует выражение, оценивающее значение аннотации. Возвращения аннотации определяются литералом ->, следующим выражению, между списком параметра и двоеточием, обозначая конец оператора def (docs.python.org/3/reference/compound_stmts.html#def). Следующий пример имеет позиционный аргумент, аргумент с ключевым словом и аннотированное возвращаемое значение:

>>> def f(ham: str, eggs: str = 'eggs') -> str:
...     print("Annotations:", f.__annotations__)
...     print("Arguments:", ham, eggs)
...     return ham + ' and ' + eggs
...
>>> f('spam')
Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
Arguments: spam eggs
'spam and eggs'
4.8. Стиль кодирования
Теперь, когда вы собираетесь писать более длинный, более сложный код на Python, настало время поговорить о coding style (стиле кодирования - прим. пер.). В большинстве языков можно писать (или по-другому, форматировать) в различных стилях; некоторые из них более читабельные, чем другие. Создание кода более читаемого для других - всегда хорошая идея, и принятый хороший стиль кодирования чрезвычайно помогает этому.

Для Python, появился PEP 8 (python.org/dev/peps/pep-0008) как руководство по стилю, которого придерживается большинство проектов; он поощряет хорошо читаемый и приятный для глаз стиль кодирования. Каждый разработчик Python должен прочитать это однажды; вот наиболее важные извлеченные пункты для вас:

Используйте 4-х-пробельный отступ, а не табуляцию.
4 пробела - хороший компромисс между маленьким отступом (позволяет большую глубину вложенности) и большим отступом (легче для чтения). Табуляции вносят путаницу, и лучше опустить их.
Делайте строки длиной не более 79 символов.
Это поможет пользователям с маленькими дисплеями и сделает возможным расположить рядом несколько файлов с кодом на больших дисплеях.
Используйте пустые строки для отделения функций и классов, а большие блоки кода помещайте внутрь функций.
Когда возможно, оставляйте комментарии на их собственной строке.
Используйте строки документации.
Используйте пробелы вокруг операторов и после запятой, но не непосредственно внутри конструкции скобок: a = f(1, 2) + g(3, 4).
Называйте ваши классы и функции последовательно; соглашением является использование CamelCase ("верблюжьей" нотации - прим. пер.) для классов и lower_case_with_underscores (нижнего регистра с подчеркиванием - прим. пер.) для функций и методов. Всегда используйте self в качестве имени первого аргумента метода (см. Первый взгляд на классы для большей информации о классах и методах).
Не используйте причудливые кодировки, если ваш код предназначен для использования в международной среде. По умолчанию в Python UTF-8 или даже обычный ASCII работает лучше в любом случае.
Точно так же не используйте не-ASCII символы в идентификаторах, если есть хотя бы малейший шанс, что люди, говорящие на другом языке, будут читать или поддерживать этот код.
Примечания

[1] На самом деле, вызов по ссылки на объект было бы лучшим описанием, поскольку если передается изменяемый объект, тот кто вызывает будет видеть любые изменения, которые вызываемый сделает с ним (элементы вставляются в список).

5. Структуры данных
5.1. Подробнее о списках
5.1.1. Использование списков в качестве стеков
5.1.2. Использование списков в качестве очередей
5.1.3. Генераторы списков
5.1.4. Вложенные генераторы списков
5.2. Оператор del
5.3. Кортежи и последовательности
5.4. Множества
5.5. Словари
5.6. Приемы использования цикла
5.7. Подробнее об условиях
5.8. Сравнение последовательностей и других типов
Эта глава более подробно описывает некоторые моменты, с которыми вы уже знакомы, и также добавляет некоторые новые факты.

5.1. Подробнее о списках
Списковый тип данных имеет несколько больше методов. Здесь все методы списковых объектов:

list.append(x)
Добавляет элемент в конец списка. Эквивалентно a[len(a):] = [x].

list.extend(iterable)
Расширяет список добавлением всех элементов из итерации. Эквивалентно a[len(a):] = iterable.

list.insert(i, x)
Вставляет элемент в заданную позицию. Первый аргумент - это индекс элемента, перед которым происходит вставка, так a.insert(0, x) вставляет впереди списка, а a.insert(len(a), x) эквивалентно a.append(x).

list.remove(x)
Удаляет первый элемент из списка, чье значение равно x. Возникает ошибка, если такого элемента нет.

list.pop([i])
Удаляет элемент в заданной позиции в списке и возвращает его. Если индекс не указан, a.pop() удаляет и возвращает последний элемент в списке. (Квадратные скобки вокруг i в сигнатуре метода означают, что параметр необязательный, а не то, что вы должны вводить квадратные скобки в том месте. Вы часто увидите такую нотацию в Справке по библиотеке Python.)

list.clear()
Удаляет все элементы из списка. Эквивалентно del a[:].

list.index(x[, start[, end]])
Возвращает индекс (отсчет с нуля) первого элемента в списке, чье значение равно x. Возникает ValueError (docs.python.org/3/library/exceptions.html#ValueError), если такого элемента нет.

Необязательные аргументы start и end интерпретируются как запись среза и используются как ограничитель для поиска в конкретной последовательности списка. Возвращаемый индекс вычисляется относительно начала полной последовательности, а не от аргумента start.

list.count(x)
Возвращает какое число раз x добавлен в список.

list.sort(key=None, reverse=False)
Сортирует элементы списка на месте (аргументы могут быть использованы для настройки сортировки, см. sorted() для разъяснений).

list.reverse()
Выполняет реверс (обратное построение - прим. пер) элементов списка на месте.

list.copy()
Возвращает поверхностную копию списка. Эквивалентно a[:].

Пример, в котором используется большинство методов списка:

>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
>>> fruits.count('apple')
2
>>> fruits.count('tangerine')
0
>>> fruits.index('banana')
3
>>> fruits.index('banana', 4)  # Находит следующий banana, начиная с позиции 4
6
>>> fruits.reverse()
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']
>>> fruits.append('grape')
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']
>>> fruits.sort()
>>> fruits
['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']
>>> fruits.pop()
'pear'
Вы могли заметить, что такие методы как insert, remove и sort, которые только изменяют список, не возвращают значения, которое может быть выведено, по умолчанию они возвращают None. [1] Это принцип работы всех изменяемых структур данных в Python.

5.1.1. Использование списков в качестве стеков
Методы списков делают возможным очень легко использовать список как стек, в котором последний добавленный элемент есть первый извлеченный элемент ("последним вошел, первым вышел"). Для добавления элемента вверх стека используйте append(). Для извлечения элемента из верха стека, используйте pop() без конкретного индекса. Например:

>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
5.1.2. Использование списков в качестве очередей
Также возможно использовать список как очередь, где первый добавленный элемент есть первый извлеченный элемент ("первым вошел, первым вышел"); однако списки не эффективны для этой цели. В то время как добавление с помощью append() и извлечение с помощью pop() с конца списка осуществляются быстро, добавление с помощью insert() или извлечение с помощью pop() из начала списка происходит медленно (потому что все другие элементы должны быть сдвинуты на один).

Для реализации очереди используйте collections.deque (docs.python.org/3/library/collections.html#collections.deque), который был разработан для быстрых добавлений и извлечений с обоих концов. Например:

>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terry прибыл
>>> queue.append("Graham")          # Graham прибыл
>>> queue.popleft()                 # Первый прибывший теперь покинул
'Eric'
>>> queue.popleft()                 # Второй прибывший теперь покинул
'John'
>>> queue                           # Остальная очередь в порядке прибытия
deque(['Michael', 'Terry', 'Graham'])
5.1.3. Генераторы списков
Генераторы списков обеспечивает лаконичный способ их создания. Обычные приложения создают новые списки, где каждый элемент есть результат нескольких операций, применяемых к каждому члену другой последовательности или итерации, или создают подпоследовательности тех элементов, которые удовлетворяют конкретному условию.

Например, предположим, мы хотим создать такой список квадратов:

>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
Заметьте, что создается (или перезаписывается) переменная под именем x, которая продолжает существовать после завершения цикла. Мы можем вычислить список квадратов без какого-либо побочного эффекта так:

squares = list(map(lambda x: x**2, range(10)))
что эквивалентно:

squares = [x**2 for x in range(10)]
Это более кратко и читабельно.

Генератор списка состоит из скобок, содержащих выражение, за которым следует for (docs.python.org/3/reference/compound_stmts.html#for), затем ни одной или больше for или условий if (docs.python.org/3/reference/compound_stmts.html#if). Результатом будет новый список, полученный от вычисления выражения в данном контексте присутствующих записей for и if. Например, этот listcomp сочетает в себе элементы двух списков, если они не равны:

>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
и это эквивалент для:

>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
Заметьте, что порядок операторов for и if одинаков в обоих данных частях кода.

Если выражение является кортежем (как (x, y) в предыдущем примере), оно должно быть заключено в скобки.

>>> vec = [-4, -2, 0, 2, 4]
>>> # создает новый список с удвоенными значениями
>>> [x*2 for x in vec]
[-8, -4, 0, 4, 8]
>>> # фильтрует список, исключая отрицательные числа
>>> [x for x in vec if x >= 0]
[0, 2, 4]
>>> # применяет функцию для всех элементов
>>> [abs(x) for x in vec]
[4, 2, 0, 2, 4]
>>> # вызывает метод для каждого элемента
>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> # создает список двойных кортежей как (число, квадрат)
>>> [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
>>> # кортеж должен быть заключен в скобки, иначе возбуждается ошибка
>>> [x, x**2 for x in range(6)]
  File "<stdin>", line 1, in ?
    [x, x**2 for x in range(6)]
               ^
SyntaxError: invalid syntax
>>> # делает список одноуровневым, используя listcomp с двумя 'for'
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
Генератор списков может содержать сложные выражения и вложенные функции:

>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
5.1.4. Вложенные генераторы списков
Начальное выражение в генераторе списка может быть любым произвольным выражением, включающим другой генератор списка.

Рассмотрим следующий пример матрицы 3x4, реализованной как список из 3-х списков длиной по 4:

>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]
Следующий генератор списка переставит строки и столбцы:

>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
Как мы видели в предыдущем разделе, вложенный listcomp оценивается в контексте for (docs.python.org/3/reference/compound_stmts.html#for), который следует за ним, таким образом этот пример есть эквивалент для:

>>> transposed = []
>>> for i in range(4):
...     transposed.append([row[i] for row in matrix])
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
который, в свою очередь, есть то же самое, что:

>>> transposed = []
>>> for i in range(4):
...     # следующие 3 строки реализуют вложенный listcomp
...     transposed_row = []
...     for row in matrix:
...         transposed_row.append(row[i])
...     transposed.append(transposed_row)
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
В действительности вам следует предпочитать встроенные функции сложным цепочкам выражений. Функция zip() прекрасно выполнить работу в данном случае:

>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
См. Распаковка списков аргументов для деталей о звездочке в этой строке.

5.2. Оператор del
Существует способ удалить элемент из списка, передав его индекс вместо значения: оператор del (docs.python.org/3/reference/simple_stmts.html#del). Это отличается от метода pop(), который возвращает значение. Также оператор del может быть использован для удаления среза из списка или очистки всего списка (что мы делали раньше присвоением пустого списка срезу). Например:

>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
del также может быть использован для полного удаления переменных:

>>> del a
Обращение к имени a в дальнейшем - это ошибка (до тех пор, пока другое значение не будет связано с ним). Позже мы обнаружим другие варианты использования del.

5.3. Кортежи и последовательности
Мы видели, что списки и строки имеют много общих свойств, такие как индексирование и операция взятия среза. Они являются двумя примерами типа данных последовательностей (см. Типы последовательностей — list, tuple, range). Поскольку Python - развивающийся язык, другие типы данных последовательностей могут быть добавлены. Существует также другой стандартный тип данных последовательностей: tuple (кортеж).

Кортеж состоит из ряда значений, разделенных запятыми, например:

>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # Кортежи могут быть вложенными:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # Кортежи неизменяемые:
... t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # но они могут содержать изменяемые объекты:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
Как вы видите, при выводе кортежи всегда заключены в скобки, так что вложенные кортежи интерпретируются корректно; они могут быть введены с и без окружающих скобок, хотя часто скобки необходимы в любом случае (если кортеж является частью большего выражения). Невозможно присвоить индивидуальному элементу кортежа, однако возможно создать кортежи, которые содержат изменяемые объекты, такие как списки.

Хотя кортежи могут показаться подобными спискам, они часто используются в разных ситуациях и для различных целей. Кортежи неизменяемые (docs.python.org/3/glossary.html#term-immutable) и обычно включают разнородную последовательность элементов, которые доступны через распаковку (см. позже в этом разделе) или индексирование (или даже по атрибуту в случае namedtuples (docs.python.org/3/library/collections.html#collections.namedtuple)). Списки изменяемы (docs.python.org/3/glossary.html#term-mutable), а их элементы обычно однородны и доступны посредством итерации списка.

Особая проблема - создание кортежей, включающих 0 или 1 элемент: у синтаксиса есть некоторые дополнительные особенности для этого. Пустые кортежи создаются пустой парой скобок; кортежи с одним элементом - значением после которого идет запятая (недостаточно заключить одиночное значение в скобки). Уродливо, но эффективно. Например:

>>> empty = ()
>>> singleton = 'hello',    # <-- заметьте запятую в конце
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
('hello',)
Выражение t = 12345, 54321, 'hello!' является примером упаковки кортежа: значения 12345, 54321 и 'hello!' упаковываются вместе в кортеж. Обратная операция также возможна:

>>> x, y, z = t
Это называется распаковкой последовательности и работает для любой последовательности с правой стороны. Распаковка последовательности требует, чтобы было в наличии так много переменных с левой стороны от знака равенства, сколько есть элементов в последовательности. Обратите внимание, что множественное присваивание на самом деле есть просто комбинирование упаковки кортежа и распаковки последовательности.

5.4. Множества
Python также включает тип данных для множеств (sets). Множество - это неупорядоченная коллекция, не содержащая повторов элементов. Основное применение включает проверку наличия члена и устранение дублирующихся записей. Объекты множеств также поддерживают математические операции, такие как объединение, пересечение, разность и симметричная разность.

Для создания множеств могут быть использованы фигурные скобки или функция set(). Заметьте: для создания пустого множества вы должны использовать set(), а не {}; последние создают пустой словарь, структуру данных, которую мы обсудим в следующем разделе.

Вот краткая демонстрация:

>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # покажет, что дубликаты были удалены
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # быстрая проверка членства
True
>>> 'crabgrass' in basket
False
 
>>> # Демонстрируются операции над множествами на уникальных буквах из двух слов ...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # уникальные буквы в a
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # буквы в a, но не в b
{'r', 'd', 'b'}
>>> a | b                              # буквы или в a или в b
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # буквы и в a и в b
{'a', 'c'}
>>> a ^ b                              # буквы в a или b, но не в обоих
{'r', 'd', 'b', 'm', 'z', 'l'}
Подобно генераторам списка, генераторы множеств также поддерживаются:

>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
5.5. Словари
Другой полезный тип данных, встроенный в Python, - это словарь (см. Типы отображений — dict). Словари иногда встречаются в других языках как "ассоциативные записи" или "ассоциативные массивы". В отличие от последовательностей, которые индексируются диапазоном чисел, словари индексируются по ключам, которые могут быть любым неизменяемым типом; строки и числа всегда могут быть ключами. Кортежи могут быть использованы как ключи, если они содержат только строки, числа или кортежи; если кортеж включает какой-либо изменяемый объект, прямо или косвенно, он не может быть использован в качестве ключа. Вы не можете использовать списки как ключи, поскольку списки могут быть изменены на месте с помощью присваивания по индексу, срезу или такими методами как append() и extend().

Лучше всего думать о словарях как о неупорядоченном множестве пар key: value (ключ: значение) с тем требованием, что ключ уникален (внутри одного словаря). Пара скобок создает пустой словарь: {}. Размещение разделенного запятыми списка пар ключ: значение внутри скобок добавляет начальные пары в словарь; таким же способом словари выводятся.

Основными операциями над словарями являются сохранение значения с каким-либо ключом и извлечение значения по данному ключу. Также возможно удаление пары key:value с помощью del. Если вы сохраняете, используя ключ, который уже используется, то старое значение, связанное с этим ключом, будет потеряно. Ошибкой является извлечение значения, используя несуществующий ключ.

Применение list(d.keys()) к словарю возвращает список всех ключей, используемых в словаре в произвольном порядке (если вы хотите отсортировать, просто вместо этого используйте sorted(d.keys())). [2] Чтобы проверить, есть ли какой-нибудь один ключ в словаре, используйте ключевое слово in (docs.python.org/3/reference/expressions.html#in).

Здесь небольшие примеры, использующие словарь:

>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'sape': 4139, 'guido': 4127, 'jack': 4098}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'guido': 4127, 'irv': 4127, 'jack': 4098}
>>> list(tel.keys())
['irv', 'guido', 'jack']
>>> sorted(tel.keys())
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
Конструктор dict() строит словари прямо из последовательностей пар ключ-значение

>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'jack': 4098, 'guido': 4127}
Кроме того, словарные сборки могут быть использованы для создания словарей из произвольных выражений ключей и значений:

>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
Когда ключи являются простыми строками, то иногда проще указать пары, используя именованные аргументы:

>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'jack': 4098, 'guido': 4127}
5.6. Приемы использования цикла
Когда цикл проходит по словарям, ключ и связанное значение могут быть извлечены одновременно с помощью метода items().

>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
Когда цикл проходит через последовательность, позиционный индекс и связанное значение могут быть извлечены одновременно с помощью функции enumerate().

>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
При прохождении цикла через две и более последовательности одновременно, записи могут быть объединены в пары с помощью функции zip().

>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
Для перебора последовательности в обратном направлении, сначала указывают последовательность в прямом направлении и затем вызывают функцию reversed():

>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
Для цикла по последовательности в отсортированном порядке, используйте функцию sorted(), которая возвращает новый отсортированный список, оставляя исходный неизменным.

>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
Иногда заманчиво изменить список, пока вы перебираете его в цикле; однако вместо этого обычно проще и безопаснее создать новый список.

>>> import math
>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
>>> filtered_data = []
>>> for value in raw_data:
...     if not math.isnan(value):
...         filtered_data.append(value)
...
>>> filtered_data
[56.2, 51.7, 55.3, 52.5, 47.8]
5.7. Подробнее об условиях
Условия, используемые в операторах while и if могут содержать любые операторы, а не только сравнения.

Операторы сравнения in и not in проверяют, встречается ли (или нет) значение в последовательности. Операторы is и is not проверяют, являются ли два объекта действительно одним и тем же объектом; это имеет значение только для изменяемых объектов, как списки. У всех операторов сравнения одинаковый приоритет, который ниже, чем у всех численных операторов.

Сравнения могут быть объединены в цепь. Например, a < b == c проверяет, меньше ли a, чем b, и вдобавок b равно ли c.

Сравнения могут быть объединены с помощью логических операторов and и or, а результат сравнения (или любого другого логического выражения) может быть перевернут на обратный с помощью not. У этих операторов более низкий приоритет, чем у операторов сравнения; среди них not имеет самый высокий приоритет, а or самый низкий, так что A and not B or C есть эквивалент (A and (not B)) or C. Как всегда скобки могут быть использованы для указания желаемой последовательности выполнения.

Логические операторы and и or являются так называемыми операторами short-circuit (короткое замыкание - прим. пер.): их аргументы оцениваются слева на право, и оценка останавливается, как только результат определен. Например, если A и C являются правдой, но B является ложью, то A and B and C не оценивает выражение C. При использовании не логического значения возвращаемым значением оператора короткого замыкания является последний аргумент, который был оценен.

Есть возможность присвоить результат сравнения или другого логического выражения переменной. Например,

>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
Заметьте, что в Python, в отличие от C, присваивание не может происходить внутри выражений. Программистов на C это может разочаровать, но это позволяет избежать распространенного класса проблем, возникающих в программах на C: ввод = в выражении, когда подразумевалось ==.

5.8. Сравнение последовательностей и других типов
Объекты последовательностей могут сравниваться с другими объектами того же типа. Сравнение использует лексикографический порядок: сначала сравниваются первые два элемента, если они разные, то они и определяют результат сравнения; если они равны, сравниваются следующие два элемента, и т. д., пока одна из двух последовательностей не будет исчерпана. Если два сравниваемых элемента сами являются последовательностями одного типа, то лексикографическое сравнение осуществляется рекурсивно. Если все элементы последовательностей равны, то последовательности считаются равными. Если одна последовательность совпадает с началом другой, более короткая последовательность считается меньшей. Лексикографический порядок для строк использует численный код Unicode для сравнения отдельных символов. Несколько примеров сравнения между последовательностями одного типа:

(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
Обратите внимание, что сравнение объектов различных типов с помощью < или > является законным при условии, что объекты имеют соответствующие методы сравнения. Например, смешанные числовые типы сравниваются в соответствии с их числовым значением, так 0 равен 0.0 и т. д. Когда сравнение невозможно, интерпретатор не обеспечивает случайный порядок, а возбуждает исключение TypeError (docs.python.org/3/library/exceptions.html#TypeError).

Примечания

[1] Другие языки могут возвращать измененный объект, что позволяет цепочка методов, такая как d->insert("a")->remove("b")->sort();.

[2] Вызов d.keys() вернет объект dictionary view. Он поддерживает такие операции, как проверка членства и итерация, но его содержание не зависит от исходного словаря - это только вид.

6. Модули
6.1. Подробнее о модулях
6.1.1. Выполнение модулей как скриптов
6.1.2. Путь поиска модуля
6.1.3. "Скомпилированные" файлы Python
6.2. Стандартные модули
6.3. Функция dir()
6.4. Пакеты
6.4.1. Импортирование * из пакета
6.4.2. Внутрипакетные ссылки
6.4.3. Пакеты во множестве директорий
Если вы выходите из интерпретатора Python и входите в него снова, определения, которые вы сделали (функции и переменные) теряются. Следовательно, если вы хотите написать какую-нибудь более длинную программу, вам лучше использовать текстовый редактор для подготовки ввода для интерпретатора, и передать код из этого файла в качестве входных данных. Это называется созданием скриптов. Когда ваша программа становится длиннее, вы можете захотеть разделить ее на несколько файлов для более легкого сопровождения. Вы также можете захотеть использовать удобную написанную вами функцию в нескольких программах без копирования ее определения в каждую программу.

Для поддержки этого в Python есть способ поместить определения в файл и использовать их в скриптах или в интерактивном режиме интерпретатора. Такой файл называется модулем; определения из модуля могут быть импортированы в другие модули или в главный модуль (коллекция переменных, к которым вы имеете доступ в выполняемом скрипте на верхнем уровне и в режиме калькулятора).

Модуль - это файл, содержащий определения и операторы Python. Имя файла является именем модуля с добавленным суффиксом .py. В модуле имя модуля (как строка) доступно как значение глобальной переменной __name__. Для примера, используйте ваш любимый текстовый редактор для создания файла под названием fibo.py в текущей директории со следующим содержанием:

# модуль чисел Фибоначчи
 
def fib(n):    # выводит ряд Фибоначчи до n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()
 
def fib2(n): # возвращает ряд Фибоначчи до n
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result
Теперь войдите в интерпретатор Python и импортируйте этот модуль с помощью следующей команды:

>>> import fibo
Это не вводит имена определенных в fibo функций прямо в текущую таблицу имен; это вводит сюда только имя модуля fibo. Используя имя модуля, вы можете получить доступ к функциям:

>>> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'
Если вы намерены использовать функцию часто, то можете связать ее с локальным именем:

>>> fib = fibo.fib
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
6.1. Подробнее о модулях
Наряду с определениями функций модули могут содержать исполняемые операторы. Эти операторы предназначены для инициализации модуля. Они выполняются только однажды, когда в операторе импорта встречается имя модуля. [1] (Они также запускаются, если файл выполняется как скрипт.)

Каждый модуль имеет его собственную приватную таблицу имен, которая используется как глобальная всеми функциями, определенными в модуле. Поэтому разработчик модуля может использовать глобальную переменную в модуле без беспокойства о случайном конфликте с глобальными переменными пользователя. С другой стороны, если вы знаете, что делаете, то можете использовать глобальную переменную модуля с такой же нотацией, которая используется для ссылки на его функцию, modname.itemname.

Модули могут импортировать другие модули. Принято, но не является необходимым, размещать все операторы import (docs.python.org/3/reference/simple_stmts.html#import) в начале модуля (это касается и скрипта). Имя импортируемого модуля помещается в глобальную таблицу имен импортирующего модуля.

Существует вариант оператора import, который импортирует имена из модуля прямо в таблицу имен импортирующего модуля. Например:

>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
Это не вводит имя модуля, из которого осуществляется импорт, в локальную таблицу имен (так в примере, fibo не определено).

Есть даже вариант импорта всех имен, которые определяет модуль:

>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
В данном случае импортируются все имена за исключением тех, которые начинаются с подчеркивания (_). В большинстве случаев программисты на Python не используют такой импорт, поскольку он вводит неизвестное множество имен в интерпретатор, возможно скрытие нескольких объектов, которые вы уже определили.

Заметьте, что в общепринятой практике импортирование * из модуля вызывает неодобрение, поскольку часто это делает код плохо читаемым. Однако это удобно использовать в интерактивной сессии, чтобы меньше набирать.

Примечание: Для повышения эффективности каждый модуль импортируется только однажды за сессию интерпретатора. Следовательно, если вы изменяете ваши модули, вы должны перезапустить интерпретатор, или, если вы просто хотите проверить один модуль в интерактивном режиме, используйте importlib.reload(), например, import importlib; importlib.reload(modulename).

6.1.1. Выполнение модулей как скриптов
Когда вы запускаете модуль Python командой

python fibo.py <arguments>
код в модуле будет выполнен, просто как если бы вы импортировали его, но с __name__, установленным в "__main__". Это означает, что при добавлении этого кода в конец вашего модуля

if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
вы можете сделать файл используемым как скрипт, в то же время он останется импортируемым модулем, потому что код, который разбирает командную строку, запускается только, если модуль выполняется как файл "main" (главный - прим. пер.):

$ python fibo.py 50
1 1 2 3 5 8 13 21 34
Если модуль импортируется, то код не выполняется:

>>> import fibo
>>>
Это часто используется либо для обеспечения удобного пользовательского интерфейса к модулю, либо для целей тестирования (при запуске модуля как скрипта выполняется ряд тестов).

6.1.2. Путь поиска модуля
Когда осуществляется импорт модуля по имени spam, сначала интерпретатор ищет встроенные модули с таким именем. Если не находит, то затем ищет файл по имени spam.py в списке каталогов, заданных переменной sys.path (docs.python.org/3/library/sys.html#sys.path). sys.path инициируется из этих мест:

Каталог, содержащий выполняемый скрипт (или текущий каталог, когда не указан никакой файл).
PYTHONPATH (список имен каталогов, с таким же синтаксисом как переменная оболочки PATH).
Умолчания, зависимые от установки.
Примечание: В файловой системе, которая поддерживает символические ссылки, каталог, содержащий запущенный скрипт, обрабатывается после символической ссылки. Другими словами, каталог, содержащий символическую ссылку, не добавляется к пути поиска модуля.

После инициализация программа на Python может изменить sys.path. Директория, содержащая запущенный скрипт, размещается в начале пути поиска, впереди пути стандартной библиотеки. Это означает, что скрипты из данной директории будут загружены вместо модулей с такими же именами в каталоге библиотеки. Если замена не предполагалась, то это ошибка. См. раздел Стандартные модули для большей информации.

6.1.3. "Скомпилированные" файлы Python
Для ускорения загрузки модулей Python кэширует скомпилированную версию каждого модуля в каталоге __pycache__ под именем module.version.pyc, где версия кодирует формат скомпилированного файла; обычно включает номер версии Python. Например, в CPython релизе 3.3 скомпилированная версия была бы кэширована как __pycache__/spam.cpython-33.pyc. Такое соглашение наименования позволяет компилировать модули из различных релизов и различных версий Python для сосуществования.

Python сравнивает дату изменения исходного кода со скомпилированной версией, чтобы обнаружить, если она устарела и нуждается в перекомпиляции. Это полностью автоматический процесс. Также скомпилированные модули не зависят от платформы, так одна и та же библиотека может быть разделена среди систем с различными архитектурами.

Python не проверяет кэш в двух случаях. Во-первых, он всегда перекомпилирует и не хранит результат для модуля, который загружается прямо из командной строки. Во вторых, он не проверяет кэш, если нет исходного кода модуля. Для поддержки распространения без исходного кода скомпилированный модуль должен быть в каталоге с исходными кодами, и здесь не должно быть исходных кодов модуля.

Некоторые советы для специалистов:

Вы можете использовать переключатели -O (docs.python.org/3/using/cmdline.html#cmdoption-O) и -OO (docs.python.org/3/using/cmdline.html#cmdoption-OO) в командах Python для уменьшения размера скомпилированного модуля. Переключатель -O удаляет заявляемые операторы, переключатель -OO удаляет как эти операторы, так и строки __doc__. Поскольку некоторые программы могут рассчитывать, что все это доступно, вам следует использовать эту опцию, если вы знаете, что делаете. "Оптимизированные" модули имеют opt-tag и обычно меньше. Будущие релизы могут изменить эффекты оптимизации.
Программа не работает быстрее, когда читается из файлов .pyc, чем когда она читается из файла .py; единственное, что быстрее для файлов .pyc - это скорость, с которой они загружаются.
Модуль compileall (docs.python.org/3/library/compileall.html#module-compileall) может создавать файлы .pyc для всех модулей в каталоге.
Есть больше информации по этому процессу, включая блок-схему решения, в PEP 3147.
6.2. Стандартные модули
Python поставляется с библиотекой стандартных модулей, описанных в отдельном документе, Справка по библиотеки Python (ниже "Справка по библиотеке"). Несколько модулей встроено в интерпретатор; они предоставляют доступ к операциям, которые не являются частью ядра языка, но тем не менее встроены в него, либо для повышения эффективности, либо для обеспечения доступа к примитивам операционной системы, таким как системные вызовы. Установка таких модулей является конфигурационной опцией, которая также зависит от используемой платформы. Например, модуль winreg (docs.python.org/3/library/winreg.html#module-winreg) предоставляется только на системах Windows. Один особый модуль заслуживает внимания: sys (docs.python.org/3/library/sys.html#module-sys), который встроен в каждый интерпретатор Python. Переменные sys.ps1 и sys.ps2 определяют строки, используемые как первичное и вторичное приглашения:

>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
>>> sys.ps1 = 'C> '
C> print('Yuck!')
Yuck!
C>
Эти две переменные определены, только если интерпретатор в интерактивном режиме.

Переменная sys.path является списком строк, который определяет путь поиска модулей интерпретатора. Он инициируется путем по умолчанию, взятым из переменной окружения PYTHONPATH (docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH), или из встроенного по умолчанию, если PYTHONPATH не установлена. Вы можете изменить ее, используя стандартный список операций:

>>> import sys
>>> sys.path.append('/ufs/guido/lib/python')
6.3. Функция dir()
Функция dir() используется для выяснения, какие имена модулей определены. Она возвращает отсортированный список строк:

>>> import fibo, sys
>>> dir(fibo)
['__name__', 'fib', 'fib2']
>>> dir(sys)  
['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__',
 '__package__', '__stderr__', '__stdin__', '__stdout__',
 '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',
 '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv',
 'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder',
 'call_tracing', 'callstats', 'copyright', 'displayhook',
 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',
 'executable', 'exit', 'flags', 'float_info', 'float_repr_style',
 'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',
 'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',
 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount',
 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',
 'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path',
 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1',
 'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit',
 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout',
 'thread_info', 'version', 'version_info', 'warnoptions']
Без аргументов dir() перечисляет имена, которые вы определили в настоящее время:

>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir()
['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']
Заметьте, что она перечисляет все типы имен: переменные, модули, функции и т. д.

dir() не перечисляет имена встроенных функций и переменных. Если вы хотите получить их список, они определены в стандартном модуле builtins (docs.python.org/3/library/builtins.html#module-builtins):

>>> import builtins
>>> dir(builtins)  
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',
 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',
 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',
 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',
 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',
 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',
 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',
 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',
 'NotImplementedError', 'OSError', 'OverflowError',
 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',
 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',
 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',
 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',
 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',
 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',
 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',
 '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',
 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',
 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',
 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',
 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',
 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',
 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',
 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',
 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',
 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',
 'zip']
6.4. Пакеты
Пакеты являются способом структурирования пространства имен Python с помощью "точечных имен модулей". Например, имя модуля A.B обозначает подмодуль с именем B в пакете с именем A. Такое использование модулей позволяет разработчикам различных модулей не беспокоится об именах глобальных переменных друг друга, использование точечных имен модулей позволяет авторам мультимодульных пакетов, таких как NumPy или Python Imaging Library, не беспокоиться об именах модулей друг друга.

Предположим, вы хотите разработать коллекцию модулей ("пакет") для единообразной обработки звуковых файлов и звуковых данных. Существует множество различных форматов звуковых файлов (обычно распознаваемых по их расширению, например: .wav, .aiff, .au), поэтому вам может потребоваться создавать и поддерживать растущую коллекцию модулей для конверсии между различными форматами файлов. Есть также множество различных операций, которые можно выполнять над звуковыми данными (такие как смешивание, добавление эхо, применение функции эквалайзера, создание искусственного стерео-эффекта), поэтому в дополнение вы будете писать нескончаемый поток модулей для выполнения этих операций. Здесь возможная структура для вашего пакета (выраженная в терминах иерархической файловой системы):

sound/                          Пакет верхнего уровня
      __init__.py               Инициализирует звуковой пакет
      formats/                  Подпакет для конверсии файловых форматов
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Подпакет для звуковых эффектов
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Подпакет для фильтров
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
При импорте пакета Python просматривает каталоги в соответствии с sys.path для обнаруживания подкаталога пакета.

Фалы __init__.py требуются для того, чтобы Python обрабатывал каталоги как содержащие пакеты; это делается для предотвращения, что каталоги с обычными именами, такими как string, не будут непреднамеренно скрывать действительные модули, которые обнаружатся позже по пути поиска модулей. В самом простом случае __init__.py может просто быть пустым файлом, но он также может выполнять инициализирующий код для пакета или устанавливать переменную __all__, описанную позже.

Пользователи пакета могут импортировать индивидуальные модули из пакета, например:

import sound.effects.echo
Загружается подмодуль sound.effects.echo. На него надо ссылаться по его полному имени:

sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
Альтернативный способ импорта подмодуля:

from sound.effects import echo
Также загружается подмодуль echo, но он доступен без его пакетного префикса, поэтому он может быть использован так:

echo.echofilter(input, output, delay=0.7, atten=4)
Еще одним вариантом является непосредственный импорт нужной функции или переменной:

from sound.effects.echo import echofilter
Опять же такой импорт загружает подмодуль echo, но это делает его функцию echofilter() доступной напрямую:

echofilter(input, output, delay=0.7, atten=4)
Заметьте, что когда используется from package import item, item может быть либо подмодулем (или подпакетом) пакета, либо каким-нибудь другим именем, определенным в пакете, как функция, класс или переменная. Оператор import сначала проверяет, есть ли определенный элемент в пакете; если нет, он предполагает, что это модуль и пытается загрузить его. Если он не находится, возбуждается исключение ImportError (docs.python.org/3/library/exceptions.html#ImportError).

Наоборот, когда используется синтаксис как import item.subitem.subsubitem, каждый элемент исключается, и последний должен быть пакетом; последний элемент может быть модулем или пакетом, но не может быть классом или функцией или переменной, определенными в предыдущем элементе.

6.4.1. Импортирование * из пакета
Теперь что случится, когда пользователь напишет sound.effects import *? Хотелось бы надеяться, что в идеале это как-нибудь выходит на файловую систему, находит, какие подмодули есть в пакете, и импортирует их все. Это может занять долгое время и импортирование подмодулей может иметь нежелательный побочный эффект, который должен происходить только, когда подмодули явно импортированы.

Для разработчика пакета есть только одно решение обеспечить явное индексирование пакета. Оператор import использует следующее соглашение: если код __init__.py пакета определяет список под названием __all__, он берется как список имен модуля, которые должны быть импортированы, когда встречается from package import *. Разработчик пакета должен обновлять список, когда выпускается новая версия пакета. Разработчики пакета могут также решить не поддерживать это, если они не видят использования для импортирования * из их пакета. Например, файл sound/effects/__init__.py может содержать следующий код:

__all__ = ["echo", "surround", "reverse"]
Это бы означало, что from sound.effects import * будет импортировать три названных подмодуля пакета sound.

Если __all__ не определена, выражение from sound.effects import * не импортирует все подмодули из пакета sound.effects в текущее пространство имен; это только обеспечивает то, что пакет sound.effects был импортирован (возможно выполняется какой-нибудь код инициализации из __init__.py) и затем импортирует любые имена, определенные в пакете. Это включает какие-либо имена определенные (и подмодули, загруженные явно) __init__.py. Это также включает какие-либо подмодули пакета, которые были явно загружены предыдущими операторами import (docs.python.org/3/reference/simple_stmts.html#import). Рассмотрим этот код:

import sound.effects.echo
import sound.effects.surround
from sound.effects import *
В этом примере модули echo и surround импортируются в текущее пространство имен, потому что они определены в пакете sound.effects, когда выполняется выражение from...import (это также работает, когда определена __all__.)

Хотя некоторые модули разработаны для экспорта только имен, которые следуют определенным шаблонам, когда вы используете import *, это по-прежнему считается плохой практикой в рабочем коде.

Помните, нет ничего плохого в использовании from Package import specific_submodule! На самом деле это рекомендованная нотация, если не требуется из импортируемого модуля использовать подмодули с одинаковыми именами из различных пакетов.

6.4.2. Внутрипакетные ссылки
Когда пакеты структурированы в подпакеты (как в пакете sound в примере), вы можете использовать абсолютные импорты для обращения к подмодулям сестринских пакетов. Например, если модулю sound.filters.vocoder надо использовать модуль echo в пакете sound.effects, он может использовать from sound.effects import echo.

Вы также можете писать относительные импорты, с формой оператора import from module import name . Такие импорты используют лидирующие точки для указания текущего и родительского пакетов, вовлеченных в относительный импорт. Например, из модуля surround вы можете использовать:

from . import echo
from .. import formats
from ..filters import equalizer
Заметьте, такой относительный импорт основывается на имени текущего модуля. Поскольку имя главного модуля всегда "__main__", модули, предназначенные для использования в качестве главного модуля приложений Python, должны всегда использовать абсолютные импорты.

6.4.3. Пакеты во множестве директорий
Пакеты поддерживают один более специфический атрибут, __path__ (docs.python.org/3/reference/import.html#__path__). Он инициализируется как список, содержащий имя каталога, хранящего __init__.py пакета, перед кодом в котором файл выполняется. Эта переменная может быть изменена; оказывая таким образом влияние на будущий поиск модулей и подпакетов, включенных в пакет.

В то время как эта возможность не часто требуется, она может быть использована для расширения набора модулей, обнаруженных в пакете.

Примечания

[1] На самом деле определения функций также "операторы", которые "выполняются"; выполнение определения функции уровня модуля вводит имя функции в глобальную таблицу имен модуля.

7. Ввод и вывод
7.1. Особенности форматирования вывода
7.1.1. Старое форматирование строк
7.2. Чтение и запись файлов
7.2.1. Методы файловых объектов
7.2.2. Сохранение структурированных данных с помощью json
Существует несколько способов представить вывод программы; данные могут быть напечатаны в читаемой форме или записаны в файл для будущего использования. В этой главе будут рассмотрены некоторые из этих возможностей.

7.1. Особенности форматирования вывода
До сих пор мы сталкивались с двумя способами вывода значений: операторы выражений и функция print(). (Третий способ - это использование метода write() файловых объектов; на файл стандартного вывода можно ссылаться как на sys.stdout. См. Справку по библиотеке для дополнительной информации об этом.)

Чаще вам захочется больше контроля над форматированием вашего вывода, чем простое печатание разделенных пробелом значений. Есть два способа форматировать ваш вывод; первый способ - чтобы все строки обрабатывали сами себя; используя нарезание строк и операторы конкатенации, вы можете создать любую разметку, какое можете представить. Строковый тип имеет несколько методов, которые выполняют полезные операции для обивки строк данной шириной столбца; скоро они будут обсуждаться. Второй способ - использовать formatted string literals (docs.python.org/3/reference/lexical_analysis.html#f-strings) или метод str.format().

Модуль string (docs.python.org/3/library/string.html#module-string) содержит класс Template (docs.python.org/3/library/string.html#string.Template), который предлагает еще один способ подстановки значений в строки.

Конечно остается один вопрос: как вы конвертируете значения в строки? К счастью Python имеет способы конвертации любого значения в строку: передайте его функции repr() или str().

Функция str() подразумевалась для возврата представлений значений, которые достаточно читабельны, тогда как repr() подразумевалась для генерации представлений, которые могут быть прочитаны интерпретатором (или приведут к SyntaxError (docs.python.org/3/library/exceptions.html#SyntaxError), если не окажется эквивалентного синтаксиса). Для объектов, которые не имеют конкретного представления для восприятия человеком, str() вернет то же самое значение, что и repr(). Множество значений, такие как числа или структуры как списки и словари, имеют одинаковое представление, используя любую функцию. Строки, в частности, имеют два отдельных представления.

Несколько примеров:

>>> s = 'Hello, world.'
>>> str(s)
'Hello, world.'
>>> repr(s)
"'Hello, world.'"
>>> str(1/7)
'0.14285714285714285'
>>> x = 10 * 3.25
>>> y = 200 * 200
>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
>>> print(s)
The value of x is 32.5, and y is 40000...
>>> # repr() строки добавляет строковые кавычки и бэкслэши:
... hello = 'hello, world\n'
>>> hellos = repr(hello)
>>> print(hellos)
'hello, world\n'
>>> # Аргумент для repr() может быть любым объектом Python:
... repr((x, y, ('spam', 'eggs')))
"(32.5, 40000, ('spam', 'eggs'))"
Вот два способа вывести таблицу квадратов и кубов:

>>> for x in range(1, 11):
...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
...     # Обратите внимание на использование 'end' в предыдущей строке
...     print(repr(x*x*x).rjust(4))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
 
>>> for x in range(1, 11):
...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
(Заметьте, что в первом примере один пробел между каждым столбцом был добавлен с помощью print(): он всегда добавляет пробелы между своими аргументами.)

Этот пример демонстрирует метод строковых объектов str.rjust(), который выравнивает строку по правому краю в поле заданной ширины, заполняя ее пробелами слева. Есть схожие методы str.ljust() и str.center(). Они ничего не выводят, а просто возвращают новую строку. Если вводимая строка слишком длинная, они не урезают ее, а возвращают без изменений; это приведет в беспорядок вашу планировку столбцов, но это обычно лучше, чем альтернатива, которая выдала бы ложное значение. (Если вы действительно хотите усечь, вы всегда можете добавить оператор среза, как в x.ljust(n)[:n].)

Существует другой метод, str.zfill(), который заполняет нулями слева числовую строку. Он понимает знаки плюс и минус:

>>> '12'.zfill(5)
'00012'
>>> '-3.14'.zfill(7)
'-003.14'
>>> '3.14159265359'.zfill(5)
'3.14159265359'
Основное использование метода str.format() выглядит вот так:

>>> print('We are the {} who say "{}!"'.format('knights', 'Ni'))
We are the knights who say "Ni!
Скобки и символы внутри них (называемые полями форматирования) заменяются объектами, переданными методу str.format(). Число в скобках может быть использовано как ссылка на позицию объекта, переданного методу str.format().

>>> print('{0} and {1}'.format('spam', 'eggs'))
spam and eggs
>>> print('{1} and {0}'.format('spam', 'eggs'))
eggs and spam
Если в методе используются аргументы-ключевые слова, их значения определяются путем использования имени аргумента.

>>> print('This {food} is {adjective}.'.format(
...       food='spam', adjective='absolutely horrible'))
This spam is absolutely horrible.
Позиционные и keyword (ключевые слова - прим. пер.) аргументы могут быть произвольно скомбинированы:

>>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
                                                       other='Georg'))
The story of Bill, Manfred, and Georg.
'!a' (применяет ascii()), '!s' (применяет str()) и '!r' (применяет repr() ) могут быть использованы для конвертирования значение перед тем, как оно будет отформатировано:

>>> contents = 'eels'
>>> print('My hovercraft is full of {}.'.format(contents))
My hovercraft is full of eels.
>>> print('My hovercraft is full of {!r}.'.format(contents))
My hovercraft is full of 'eels'.
Необязательное ':' и спецификатор формата могут следовать за именем поля. Это позволяет получить больший контроль над форматированием значения. Следующий пример округляет Pi до трех знаков после точки.

>>> import math
>>> print('The value of PI is approximately {0:.3f}.'.format(math.pi))
The value of PI is approximately 3.142.
Передача целого числа после ':' создаст поле, минимальная ширина которого будет соответствовать этому числу. Это полезно для создания таблицы.

>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...     print('{0:10} ==> {1:10d}'.format(name, phone))
...
Jack       ==>       4098
Dcab       ==>       7678
Sjoerd     ==>       4127
Если у вас действительно длинная строка, которую вы не хотите разделять, будет замечательно, если вы упомяните переменные, которые форматируются по имени, вместо позиций. Это может быть сделано простой передачей словаря и использованием квадратных скобок '[]' для доступа к ключам

>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
...       'Dcab: {0[Dcab]:d}'.format(table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
Это может быть также сделано передачей таблицы в качестве аргумента-ключевого слова с использованием нотации '**'.

>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
Это особенно полезно в сочетании с функцией vars(), которая возвращает словарь, включающий все локальные переменные.

Для полного обзора строкового форматирования с помощью str.format() см. Format String Syntax (docs.python.org/3/library/string.html#formatstrings).

7.1.1. Старое форматирование строк
Оператор % также может быть использован для форматирования строки. Он интерпретирует левый аргумент так же, как sprintf()-стиль формата строки, будучи примененным к правому аргументу, и возвращает строку результата из этой форматирующей операции. Например:

>>> import math
>>> print('The value of PI is approximately %5.3f.' % math.pi)
The value of PI is approximately 3.142.
Больше информации может быть найдено в разделе printf-стиль форматирования строк.

7.2. Чтение и запись файлов
open() возвращает файловый объект (docs.python.org/3/glossary.html#term-file-object) и чаще всего используется с двумя аргументами: open(filename, mode).

>>> f = open('workfile', 'w')
Первый аргумент является строкой, содержащей имя файла. Второй аргумент - другая строка, содержащая несколько символов, описывающих способ, которым файл будет открыт. mode (режим - прим. пер.) может быть 'r', когда файл будет только читаться, 'w' - только для записи (существующий файл с таким же именем будет стерт), и 'a' открывает файл для добавления; любые данные, записанные в файл, автоматически добавляются в конец. 'r+' открывает файл как для чтения, так и записи. Аргумент mode опциональный; если он пропущен, будет назначен 'r'.

 Обычно файл открывается в текстовом режиме, это означает, что вы считываете из файла и записываете в файл строки. Файл кодируется в определенной кодировке. Если кодировка не указана, то по умолчанию она зависит от платформы (см. open()). Добавление 'b' к режиму откроет файл в режиме binary (бинарном - прим. пер.): теперь данные читаются и записываются из байтовых объектов. Этот режим следует использовать для всех файлов, которые не содержат текст.

В текстовом режиме, по-умолчанию при чтении происходит преобразование окончания строки, которое зависит от платформы (\n в Unix, \r\n в Windows) в просто \n. При записи в текстовом режиме происходит обратная конвертация. Это происходящее за сценой преобразование файловых данные прекрасно для текстовых файлов, но будет портить бинарные данные как те, что в файлах JPEG или EXE. Будьте очень осторожны, используя бинарный режим, когда читаете и пишите такие файлы.

7.2.1. Методы файловых объектов
Остальные примеры в этом разделе будут предполагать, что файловый объект под названием f уже был создан.

Считывая содержимое файла, вызовите f.read(size), который читает некоторое количество данных и возвращает их как строку (в текстовом режиме) или объект байтов (в бинарном режиме). size - необязательный числовой аргумент. Когда size пропущен или отрицателен, все содержимое файла будет прочитано и возвращено; это ваша проблема, если файл окажется вдвое больше, чем память компьютера. По-другому, наибольший размер байтов читается и возвращается. Если был достигнут конец файла, f.read() вернет пустую строку.

>>> f.read()
'This is the entire file.\n'
>>> f.read()
''
f.readline() читает одну строку (линию) из файла; символ новой строки (\n) остается в конце строки, и опускается только на последней строке файла, если файл не заканчивается новой строкой. Это делает возврат значения недвусмысленным; если f.readline() возвращает пустую строку, значит был достигнут конец файла, в то время как пустая линия представлена '\n', строкой, содержащей только одиночный символ новой линии.

>>> f.readline()
'This is the first line of the file.\n'
>>> f.readline()
'Second line of the file\n'
>>> f.readline()
''
Для чтения строк из файла, вы можете использовать цикл для обхода файлового объекта. Это эффективно для памяти, быстро и управляется простым кодом:

>>> for line in f:
...     print(line, end='')
...
This is the first line of the file.
Second line of the file
Если вы хотите считать все строки файла в список, вы можете также использовать list(f) или f.readlines().

f.write(string) записывает содержимое string в файл, возвращает количество записанных символов.

>>> f.write('This is a test\n')
15
Другие типы объектов нуждаются в конвертации - или в строку (в текстовом режиме) или объект байтов (в бинарном режиме) - перед своей записью:

>>> value = ('the answer', 42)
>>> s = str(value)  # конвертирование кортежа в строку
>>> f.write(s)
18
При двоичном режиме f.tell() возвращает целое число, указывающее для файлового объекта текущую позицию в файле, представленное как количество байтов от начала файла, и непрозрачный номер в текстовом режиме.

Чтобы изменить позицию в файловом объекте, используйте f.seek(offset, from_what). Позиция вычисляется из добавления offset (смещение - прим. пер.) к упомянутой точке; эта точка определяется аргументом from_what. Значение 0 from_what  указывает на начало файла, 1 использует текущую позицию файла и 2 - конец файла как упомянутая точка. from_what может быть опущен, что приравнивает его к 0, использованию начала файла, как отправной точки.

>>> f = open('workfile', 'rb+')
>>> f.write(b'0123456789abcdef')
16
>>> f.seek(5)      # Идем к 6-му байту в файле
5
>>> f.read(1)
b'5'
>>> f.seek(-3, 2)  # Идем к третьему байту с конца
13
>>> f.read(1)
b'd'
В текстовых фалах (тех, что были открыты без 'b') seek разрешен только относительно начала файла (исключение - ищет самый конец файла с помощью seek(0, 2)), и единственными допустимыми значениями смещения являются те, которые возвращаются из f.tell(), или ноль. Любое другое значение смещения вызывает неопределенное поведение.

Когда вы закончите с файлом, вызовите f.close(), чтобы закрыть его и освободить какие-либо системные ресурсы, занятые открытым файлом. После вызова f.close(), попытки использовать файловый объект будут приводить к автоматическому сбою.

>>> f.close()
>>> f.read()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: I/O operation on closed file
Хорошая практика - использовать ключевое слово with (docs.python.org/3/reference/compound_stmts.html#with), когда имеете дело с объектами-файлами. У этого есть преимущество, что файл правильно закроется после завершения его набора, даже если по пути возникнет исключение. Это также намного короче, чем писать эквивалентный try(docs.python.org/3/reference/compound_stmts.html#try)-finally(docs.python.org/3/reference/compound_stmts.html#finally) блок:

>>> with open('workfile', 'r') as f:
...     read_data = f.read()
>>> f.closed
True
Файловые объекты имеют несколько дополнительных методов, таких как isstty() и trancate(), которые используются менее часто; обратитесь к справке по библиотеке для полного экскурса по объектам-файлам.

7.2.2. Сохранение структурированных данных с помощью json
Строки могут быть легко записаны в и считаны из файла. Числа отнимают немного больше усилий, поскольку метод read() возвращает только строку, которая будет передана функции наподобие int() (docs.python.org/3/library/functions.html#int), которая примет строку как '123' и вернет ее числовое значение 123. Когда вы хотите сохранить более сложные типы данных как вложенные списки и словари, ручной разбор и сериализация становятся сложными.

Вместо того, чтобы постоянно писать и отлаживать код для сохранения сложных типов данных в файлах, Python позволяет использовать популярный формат обмена данными под названием JSON (JavaScript Object Notation) (json.org/). Стандартный модуль под названием json (docs.python.org/3/library/json.html#module-json) может принимать иерархии данных Python и конвертировать их в строковое представление; этот процесс называется serializing (сериализация, упорядочивание, издание выпусками - прим. пер.). Реконструкция данных из строкового представления называется deserializing. Между сериализацией и десереализацией строковое представление объекта может быть сохранено в файле или данных, или отправлено по сетевому соединению удаленному компьютеру.

Обратите внимание: Формат JSON обычно используется современными приложениями для позволения обмена данными. Много программистов уже хорошо знакомы с ним, что хорошо для совместимости.

Если у вас есть объект x, вы можете взглянуть на его JSON представление в виде строки с помощью одной строки кода:

>>> json.dumps([1, 'simple', 'list'])
'[1, "simple", "list"]'
Другой вариант функции dumps() (docs.python.org/3/library/json.html#json.dumps), называемый dump() (docs.python.org/3/library/json.html#json.dump), просто сериализует объект в текстовый файл (docs.python.org/3/glossary.html#term-text-file). Так если f - текстовый файловый объект, открытый на запись, мы можем сделать это:

json.dump(x, f)
Для декодирования объекта опять если f - текстовый файл, который был открыт для чтения:

x = json.load(f)
Это простая техника сериализации может обрабатывать списки и словари, но сериализация объектов произвольных классов в JSON требует немного больше дополнительных усилий. Обратитесь к справке по модулю json, содержащей объяснение этого.

См. также: pickle (docs.python.org/3/library/pickle.html#module-pickle) - модуль pickle

В противоположность JSON, pickle - протокол, который позволяет сериализацию произвольных объектов Python. Как таковой он специфичен для Python и не может использоваться для взаимодействия с приложениями, написанными на других языках. Он также небезопасен по-умолчанию: десериализация данных pickle, приходящих из ненадежных источников, может выполнить произвольный код, если данные были созданы опытным злоумышленником.

8. Ошибки и исключения
8.1. Синтаксические ошибки
8.2. Исключения
8.3. Обработка исключений
8.4. Возбуждение исключений
8.5. Определенные пользователем исключения
8.6. Определение очищающих действий
8.7. Предопределенные очищающие действия
До сих пор о сообщениях об ошибках лишь упоминалось, но если вы пытались проделать примеры, то, наверное, видели некоторые из них. Есть (по меньшей мере) два отличимых вида ошибок: синтаксические ошибки (syntax errors) и исключения (exceptions).

8.1. Синтаксические ошибки
Синтаксические ошибки (Syntax Errors), также известны как ошибки грамматического разбора (parsing errors), являются, пожалуй, наиболее распространенным видом жалоб пока вы все еще изучаете Python:

>>> while True print('Hello world')
  File "<stdin>", line 1, in ?
    while True print('Hello world')
                   ^
SyntaxError: invalid syntax
Синтаксический анализатор (parser - парсер) повторяет ошибочную строку и отображает маленькую "стрелку", указывая тем самым, что в предшествующей строке была обнаружена ошибка. Ошибка вызвана (или хотя бы обнаружилась) объектом предшествующим стрелке: в примере, ошибка обнаружена в функции print(), так как перед ней отсутствует двоеточие (':'). Имя файла и номер строки выводятся, чтобы вы знали, где искать в случае, если ввод был получен из скрипта.

8.2. Исключения
Даже если оператор или выражение синтаксически правильно, все-равно может возникнуть ошибка при попытке его выполнить. Ошибки, обнаруженные во время выполнения, называются исключениями (exceptions) и не являются безоговорочно фатальными: вы скоро узнаете, как их обрабатывать в программах на Python. Большинство исключений не обрабатываются программами, но выводятся сообщения об ошибке, как показано здесь:

>>> 10 * (1/0)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ZeroDivisionError: int division or modulo by zero
>>> 4 + spam*3
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
NameError: name 'spam' is not defined
>>> '2' + 2
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: Can't convert 'int' object to str implicitly
В последней строке сообщения об ошибке указывается, что произошло. Исключения бывают разных типов, тип выводится как часть сообщения: типами в примере являются ZeroDivisionError (docs.python.org/3/library/exceptions.html#ZeroDivisionError), NameError (docs.python.org/3/library/exceptions.html#NameError) и TypeError (docs.python.org/3/library/exceptions.html#TypeError). Название случившегося исключения выводится как название типа встроенного исключения. Это верно для всех встроенных исключений, но не обязательно для пользовательских исключений (хотя это полезное соглашение). Имена стандартных исключений представляют собой встроенные идентификаторы (не зарезервированные ключевые слова).

Остальная часть строки сообщает детали на основе типа исключения и того, что стало его причиной.

Предыдущая часть сообщения об ошибке показывает контекст, в котором произошло исключение, в форме отслеживания (traceback) в стеке. В общем он содержит стек трассировки листинга строк исходного кода, однако он не будет отображать строки прочитанные со стандартного ввода.

Встроенные исключения (docs.python.org/3/library/exceptions.html#bltin-exceptions) перечисляет встроенные исключения и их значения.

8.3. Обработка исключений
Существует возможность писать программы, которые обрабатывают выбранные исключения. Посмотрите на следующий пример, который запрашивает у пользователя ввод до тех пор, пока он не введет допустимое целое число, но позволяет пользователю прервать программу (с помощью Control-C или того, что поддерживает конкретная операционная система); обратите внимание, что сгенерированное пользователем прерывание возникает как исключение KeyboardInterrupt (docs.python.org/3/library/exceptions.html#KeyboardInterrupt) (клавиатурное прерывание).

>>> while True:
...     try:
...         x = int(input("Please enter a number: "))
...         break
...     except ValueError:
...         print("Oops!  That was no valid number.  Try again...")
...
Оператор try (docs.python.org/3/reference/compound_stmts.html#try) работает следующим образом.

Сначала выполняется блок try (выражение(я) между ключевыми словами try (docs.python.org/3/reference/compound_stmts.html#try) и except (docs.python.org/3/reference/compound_stmts.html#except)).
Если исключение не произошло, блок except пропускается и выполнение оператора try закончено.
Если во время выполнения содержимого try возникает исключение, выражения ниже пропускаются. Затем, если тип возникшего исключения соответствует имени исключения после ключевого слова except, содержимое except выполняется, и затем выполнение продолжается после всего оператора try.
Если происходит исключение, которое не соответствует имени исключения в строке except, оно передается на внешний оператор try; если обработчик не найден, то исключение становится необработанным и выполнение останавливается с сообщением, как показано выше.
Оператор try может иметь более, чем один пункт except, специальные обработчики для различных исключений. Только один обработчик будет выполнен. Обработчики обрабатывают только те исключения, которые происходят в соответствующей им части try, но не в других обработчиках оператора try. В строке except можно перечислить несколько исключений, взяв их в скобки как кортеж, например:

... except (RuntimeError, TypeError, NameError):
...     pass
Класс в блоке except совместим с исключением, если он является таким же классом или базовым классом такового (но не наоборот - блок except, перечисляющий производный класс, несовместим с базовым классом). Например, следующий код выведет B, C, D:

class B(Exception):
    pass

class C(B):
    pass

class D(C):
    pass

for cls in [B, C, D]:
    try:
        raise cls()
    except D:
        print("D")
    except C:
        print("C")
    except B:
        print("B")
Заметьте, что если бы блоки исключений шли в обратном порядке (первым except B), то было бы выведено B, B, B, так как сработало бы первое сопоставление блока except.

В последнем пункте except можно опустить название исключения(ий), он будет служить "джокером". Используйте эту возможность с особой осторожностью, так как таким образом легко замаскировать действительные ошибки программирования! Такой вариант также может быть использован для вывода сообщения об ошибке, и затем повторной генерации исключения (позволяет вызывающему также обработать исключение):

import sys
 
try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except IOError as err:
    print("I/O error: {0}".format(err))
except ValueError:
    print("Could not convert data to an integer.")
except:
    print("Unexpected error:", sys.exc_info()[0])
    raise
Оператор try ... except имеет еще опциональную ветку else, которая если присутствует, должны следовать после всех веток except. Это полезно для кода, который должен быть выполнен, если в ветке try не возникло никакого исключения. Например:

for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except IOError:
        print('cannot open', arg)
    else:
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()
Использование ветки else лучше, чем добавление дополнительного кода в try, потому что помогает избежать случайного перехвата исключения, которое не было сгенерировано кодом, находящимся под "защитой" оператора try ... except.

При возникновении исключения с ним может быть связанное значение, также называемое аргументом исключения. Наличие и тип аргумента зависят от типа исключения.

В ветке except после имени исключения можно указать переменную. Переменная привязана к экземпляру исключения с аргументами хранящимися в instance.args. Для удобства экземпляр исключения определяет __str__() (docs.python.org/3/reference/datamodel.html#object.__str__), так что аргументы можно вывести сразу, без того, чтобы ссылаться на .args. Также возможно проиллюстрировать (instantiate) исключение прежде, чем сгенерировать его и добавлять какие-либо атрибуты, как пожелаете.

>>> try:
...    raise Exception('spam', 'eggs')
... except Exception as inst:
...    print(type(inst))    # экземпляр исключения
...    print(inst.args)     # аргументы хранимые в .args
...    print(inst)          # __str__ позволяет вывести аргументы сразу,
...                         # но могут быть переведены в подклассы исключений
...    x, y = inst.args     # распаковка args
...    print('x =', x)
...    print('y =', y)
...
<class 'Exception'>
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs
Если у исключения есть аргументы, они выводятся как последняя часть (‘detail’ - подробность) сообщения для необработанных исключений.

Обработчики исключений не только обрабатывают исключения, которые происходят непосредственно в ветке try, но и если они происходят внутри функций, которые вызываются (даже ненапрямую) в try. Например:

>>> def this_fails():
...     x = 1/0
...
>>> try:
...     this_fails()
... except ZeroDivisionError as err:
...     print('Handling run-time error:', err)
...
Handling run-time error: division by zero
8.4. Вызов исключений
Оператор raise (docs.python.org/3/reference/simple_stmts.html#raise) позволяет программисту сгенерировать указанное исключение. Например:

>>> raise NameError('HiThere')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
NameError: HiThere
В единственном аргументе raise указывается исключение, которое будет вызвано. Оно должно быть либо экземпляром исключения, либо классом исключения (дочерним по отношению к Exception (docs.python.org/3/library/exceptions.html#Exception)). Если передается класс исключения, то будет неявно создан экземпляр объекта, вызовом его конструктора без аргументов:

raise ValueError  # сокращение для 'raise ValueError()'
Если вам необходимо определить, было ли возбуждено исключение, но вы не намерены перехватывать его, более простая форма оператора raise позволяет возбудить исключение снова:

>>> try:
...     raise NameError('HiThere')
... except NameError:
...     print('An exception flew by!')
...     raise
...
An exception flew by!
Traceback (most recent call last):
  File "<stdin>", line 2, in ?
NameError: HiThere
8.5. Исключения, определяемые пользователем
В программах можно создавать свои собственные исключения, создав новый класс исключения (см. Классы для подробной информации о классах Python). Исключения должны быть обычно получены от класса Exception (docs.python.org/3/library/exceptions.html#Exception), прямо или опосредованно.

Могут быть определены классы исключений, которые делают любое, что делают другие классы, но обычно оставляют простыми, часто только предлагающими ряд атрибутов, которые позволяют информации об ошибке быть извлеченной обработчиками исключения. При создании модуля, который может возбуждать несколько различных ошибок, обычной практикой является создание базового класса для исключений, определенных модулем, и подкласса для создания конкретных классов исключений для различных условий ошибок:

class Error(Exception):
	"""Base class for exceptions in this module.
	Базовый класс для исключений в этом модуле."""
	pass
 
class InputError(Error):
	"""Exception raised for errors in the input.
	Исключение возбуждается для ошибок в вводе.
 
	Attributes:
		expression -- input expression in which the error occurred
				   -- входное выражение, в котором произошла ошибка
		message -- explanation of the error
				-- объяснение ошибки
	"""
	def __init__(self, expression, message):
		self.expression = expression
		self.message = message
 
class TransitionError(Error):
	"""Raised when an operation attempts a state transition that's not allowed.
	Возникает при попытке операции перехода, которая не допускается.
 
	Attributes:
		previous -- state at beginning of transition
				 -- состояние в начале перехода
		next -- attempted new state
			 -- нового состояния, к которому пытаются перейти
		message -- explanation of why the specific transition is not allowed
				-- объяснение, почему конкретный переход не допускается
	"""
	def __init__(self, previous, next, message):
		self.previous = previous
		self.next = next
		self.message = message
Большинство исключений определяются с именами, которые заканчиваются на "Error", похоже на именование стандартных исключений.

Многие стандартные модули определяют свои собственные исключения для сообщения об ошибках, которые могут возникнуть в функциях, которые в них определены. Более подробная информация о классах представлена в главе Классы.

8.6. Определение очищающих действий
Оператор try (docs.python.org/3/reference/compound_stmts.html#try) имеет другую дополнительную ветку, которая предназначена для определения clean-up (очищающих - прим. пер.) действий, которые должны быть выполнены при любых обстоятельствах. Например:

>>> try:
...     raise KeyboardInterrupt
... finally:
...     print('Goodbye, world!')
...
Goodbye, world!
KeyboardInterrupt
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
Содержимое finally всегда выполняется перед выходом из конструкции try, независимо от того произошло исключение или нет. Когда исключение произошло в ветке try и не было обработано в ветке except (или оно произошло в ветках except или else), оно будет вызвано снова после того, как выполнится содержимое finally. Ветка finally также выполняется "на выходе", когда из любой ветки всего оператора try выход осуществляется через операторы break, continue или return. Более сложный пример:

>>> def divide(x, y):
...     try:
...         result = x / y
...     except ZeroDivisionError:
...         print("division by zero!")
...     else:
...         print("result is", result)
...     finally:
...         print("executing finally clause")
...
>>> divide(2, 1)
result is 2.0
executing finally clause
>>> divide(2, 0)
division by zero!
executing finally clause
>>> divide("2", "1")
executing finally clause
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "<stdin>", line 3, in divide
TypeError: unsupported operand type(s) for /: 'str' and 'str'
Как вы можете видеть, ветка finally выполняется в любом случае. TypeError возникшее из-за деления двух строк не обрабатывается веткой except и поэтому перевызывается после того, как ветка finally была выполнена.

В реальных приложениях, ветка finally полезна для освобождения внешних ресурсов (таких как файлы или сетевые соединения), независимо от того, было ли использование ресурса успешным.

8.7. Предопределенные очищающие действия
Для некоторых объектов определены стандартные завершающие действия, которые должны быть предприняты, когда объект больше не нужен, независимо от того, прошли ли операции, использующие объект, успешно или возникла ошибка. Посмотрите на следующий пример, где происходит открытие файла и вывод его содержимого на экран.

for line in open("myfile.txt"):
    print(line, end="")
Проблема, связанная с этим кодом заключается в том, что файл остается открытым на неопределенное количество времени уже после того, как эта часть кода завершит выполнение. Это не является проблемой в простых скриптах, но может быть проблемой для больших приложений. Оператор with (docs.python.org/3/reference/compound_stmts.html#with) позволяет таким объектам как файлы быть использованными таким образом, что всегда обеспечит завершающие действия с ними сразу и корректно.

with open("myfile.txt") as f:
    for line in f:
        print(line, end="")
После того как оператор выполнится, файл f всегда закрывается, даже если возникла проблема при обработке строк. Для объектов, которые, как и файлы, имеют предопределенные очищающие действия, это указывается в их документации.

9. Классы
9.1. Несколько слов об именах и объектах
9.2. Области видимости и пространства имен в Python
9.2.1. Примеры областей видимости и пространств имен
9.3. Первый взгляд на классы
9.3.1. Синтаксис определения класса
9.3.2. Объекты класса
9.3.3. Экземплярные объекты
9.3.4. Методы объектов
9.3.5. Переменные класса и экземпляра
9.4. Некоторые замечания
9.5. Наследование
9.5.1. Множественное наследование
9.6. Приватные переменные
9.7. Различные заметки
9.8. Итераторы
9.9. Генераторы
9.10. Выражения генераторов
По сравнению с другими языками программирования, механизм классов Python добавляет классы с минимумом нового синтаксиса и семантики. Это смесь механизмов класса похожая на C++ и Modula-3. Классы Python предоставляют все стандартные возможности объектно-ориентированного программирования: механизм наследования классов позволяет использовать несколько базовых классов, производный класс может переопределить любые методы своего базового класса или классов, а метод может вызвать метод базового класса с тем же именем. Объекты могут содержать произвольные количество и типы данных. Как и в случае модулей, классы используют динамическую природу Python: они создаются во время выполнения и могут быть изменены в дальнейшем после создания.

В терминологии C++ обычно члены класса (в том числе данные) являются public (кроме см. ниже Приватные переменные), а все функции-члены являются virtual. Как и в Modula-3 отсутствуют сокращения для привязок (referencing) членов объекта из его методов: метод-функция объявляется с явным первым аргументом, представляющим объект, который неявно предоставляется вызовом. Как и в Smalltalk, классы сами являются объектами. Это обеспечивает семантику для импортирования и переименования. В отличие от C++ и Modula-3, встроенные типы могут быть использованы как базовые классы для расширения их пользователем. Также как и в C++ большинство встроенных операторов со специальным синтаксисом (арифметические операторы, индексирование и т.д.) могут быть переопределены для экземпляров класса.

(Из-за отсутствия общепринятой терминологии при разговоре о классах, я буду время от времени использовать термины Smalltalk и C++. Я хотел бы использовать терминологию Modula-3, так как его объектно-ориентированная семантика ближе к Python, чем C++, но мне кажется, что только некоторые читатели слышали о нем.)

9.1. Несколько слов об именах и объектах
У объектов есть индивидуальность, и несколько имен (в несколько областях видимости) могут быть связаны с одним и тем же объектом. Это известно как использование псевдонимов (aliasing) в других языках. Обычно это не принимается во внимание при первом знакомстве с Python, и это можно спокойно игнорировать при работе с неизменными основными типами (числами, строками, кортежами). С другой стороны, использование псевдонимов предоставляет возможность неожиданного эффекта от семантики кода Python с участием изменяемых объектов, таких как списки, словари и множества других типов. Это обычно несет пользу для программы, так как псевдонимы в некоторых отношениях ведут себя как указатели. Например, передать объект легче, так как реализацией передается только указатель; и если функция изменяет объект, переданный в качестве аргумента, в вызывающей части кода будут наблюдаться изменения - это устраняет необходимость для двух различных механизмов передачи параметров как в Pascal.

9.2. Области видимости и пространства имен в Python
Перед введением в классы, сначала необходимо кое-что сказать о правилах областей видимости в Python. Определения классов выполняют небольшие аккуратные трюки с пространствами имен, и вы должны знать, как работают области видимости и пространства имен, чтобы хорошо понимать, что происходит. Кстати, знания в этой области полезны для любого продвинутого программиста на Python.

Давайте начнем с некоторых определений.

namespace (пространство имен) представляет собой отображение имен на объекты. Большинство пространств имен в настоящее время реализованы как словари Python, но в любом случае это обычно не заметно (за исключением производительности), и это может измениться в будущем. Примеры пространств имен: множество встроенных имен (содержащие такие функции, как abs() (docs.python.org/3/library/functions.html#abs) и встроенные имена исключений); глобальные имена в модуле и локальные имена в вызове функции. В определенном смысле набор атрибутов объекта также образует пространство имен. Важная деталь в знаниях о пространствах имен заключается в том, что нет абсолютно никакой связи между именами в разных пространствах; например, в двух различных модулях может быть определена функция maximize, и это не создаст путаницы - пользователи модулей должны использовать префикс в виде имени модуля перед именем функции.

Кстати, слово attribute я использую для любого имени после точки - например, в выражении z.real, real является атрибутом объекта z. Строго говоря, ссылки на имена в модулях - это ссылки атрибутов: в выражении modname.funcname, modname - это объект модуля, а funcname является его атрибутом. В этом случае существует простое отображение между атрибутами модуля и глобальными именами, определенными в модуле: они разделяют одно и то же пространство имен! [1]

Атрибуты могут быть только для чтения или изменяемыми. В последнем случае, возможно присвоение атрибутов. Атрибуты модуля доступны для записи: вы можете написать modname.the_answer = 42. Записываемые атрибуты могут также быть удалены с помощью оператора del (docs.python.org/3/reference/simple_stmts.html#del). Например, del modname.the_answer удалит атрибут the_answer у объекта modname.

Пространства имен создаются в различные моменты времени и имеют разные периоды жизни. Пространство, содержащее встроенные имена, создается, когда запускается интерпретатор Python, и никогда не удаляется. Глобальное пространство имен для модуля создается, когда определение модуля считывается; обычно пространство имен модуля также существует до выхода из интерпретатора. Операторы, выполняющиеся на высшем уровне вызова интерпретатора, либо читающиеся из файла скрипта или интерактивно, рассматриваются как часть модуля под названием __main__ (docs.python.org/3/library/__main__.html#module-__main__), поэтому они имеют свое собственные глобального пространство имен. (Встроенные имен на самом деле находятся в модуле, который называется builtins (docs.python.org/3/library/builtins.html#module-builtins).)

Локальное пространство имен функции создается при ее вызове и удаляется, когда функция возвращает управление или вызывает исключение, которое не обрабатывается внутри нее. (Действительно, забывчивость была бы лучшим способом описать то, что происходит на самом деле.) Конечно, рекурсивные вызовы имеют свои собственные локальные имена.

scope (область видимости) является буквальной областью Python-программы, где непосредственно доступно пространство имен. "Непосредственно доступно" здесь означает, что "неспецифическая" ссылка на имя пытается найти имя в пространстве имен.

Хотя области (scopes) определяются статически, но используются динамически. В любое время выполнения есть по крайней мере три вложенные области видимости, чьи пространства имен доступны сразу:

внутренняя область видимости, которая просматривается в первую очередь, содержит локальные имена
область любых ограждающих функций, которая просматривается, начиная с ближайшей области видимости, содержит нелокальные, но и неглобальные имена
предпоследняя область видимости включает глобальные имена текущего модуля
внешняя область (исследуется последней) является пространством имен, содержащем встроенные имена
Если имя объявлено как глобальное, то все ссылки и присвоения переходят непосредственно к средней области видимости, содержащей глобальные имена модуля. Для переназначения переменных, находящихся вне внутренней области видимости, может быть использован оператор nonlocal (docs.python.org/3/reference/simple_stmts.html#nonlocal); если такого объявления нет, эти переменные доступны только для чтения (попытка записи в такую переменную будет просто создавать новую локальную переменную в самой внутренней области видимости, в результате чего внешняя переменная с таким же именем остается без изменений).

Обычно локальная область ссылается на локальные имена (текстуально) текущей функции. Вне функций ссылки локальной области - то же самое, что пространство имен глобальной области: пространство имен модуля. Определения классов размещают еще одно пространство имен в локальной области.

Важно понимать, что области видимости определяются текстуально: глобальная область функции, определенной в модуле, есть пространство имен этого модуля, независимо от того, где и под каким псевдонимом вызывается функция. С другой стороны, фактический поиск имен производится динамически, во время выполнения. Тем не менее, определение языка развивается в сторону статического разрешения имен, ко времени "компиляции", так что не полагайтесь на динамическое разрешение имен! (На самом деле, локальные переменные уже определены статически.)

Специальная причуда Python - если нет оператора global, присвоения имен всегда идут в самые внутренние области. Присваивания не копируют данные - они просто связывают имена с объектами. То же самое верно для удалений: оператор del x убирает привязку х из пространства имен, на которые ссылается локальная область видимости. На самом деле все операции, которые вводят новые имена используют локальную область: в частности, оператор import (docs.python.org/3/reference/simple_stmts.html#import) и определения функций связывают модуль или имя функции в локальной области видимости.

Оператор global может быть использован для указания, какие определенные переменные находятся в глобальной области и должны быть отосланы туда; оператор nonlocal указывает, что некоторые переменные находятся в огражденной области видимости и должны быть отосланы туда.

9.2.1. Пример областей видимости (scopes) и пространств имен (namespaces)
Это пример демонстрирует, как ссылаться на различные области и пространства имен, и как global и nonlocal влияют на связывание переменных:

def scope_test():
    def do_local():
        spam = "local spam"
    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"
    def do_global():
        global spam
        spam = "global spam"
 
    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)
 
scope_test()
print("In global scope:", spam)
Вывод данного примера будет таким:

After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
Заметьте, что присвоение local (которое происходит по умолчанию) не изменило связывания spam в scope_test. Присвоение nonlocal изменило связывание spam в scope_test, и присвоение global изменило связывание до уровня модуля.

Вы также можете видеть, что не было никакого предварительного связывания spam до присваивания global.

9.3. Первый взгляд на классы
Классы вводят немного нового синтаксиса, три новых объектных типа и некоторую новую семантику.

9.3.1. Синтаксис определения класса
Простейшая форма определения класса выглядит следующим образом:

class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
Определения классов, как и определения функций (операторы def (docs.python.org/3/reference/compound_stmts.html#def)), должны быть выполнены до их вызова. (Предположительно вы может поместить определение класса в ветке оператора if (docs.python.org/3/reference/compound_stmts.html#if) или внутри функции.)

На практике операторы внутри определения класса, как правило, будут определениями функций, но другие выражения разрешены также, а иногда и полезны - мы вернемся к этому позже. Определения функций внутри класса обычно имеют своеобразную форму списка аргументов, продиктованную соглашениями по вызову методов - опять же, это объясняется позже.

Когда определение класса введено, создается новое пространство имен и используется в качестве локальной области видимости - поэтому все присваивания локальным переменным происходят в этом новом пространстве имен. В частности определения функций связываются с именем новой функции здесь.

Когда определение класса остается обычным (через завершение), создается объект класса. В основном это обертка вокруг содержимого пространства имен, созданного определением класса; мы узнаем больше об объектах класса в следующем разделе. Первоначальная локальная область видимости (в действительности она была введена как раз перед определением класса) будет восстановлена​​, и объект класса связан здесь с именем класса, данным в заголовке определения класса (ClassName в примере).

9.3.2. Объекты класса
Объекты класса поддерживают два вида операций: ссылки на атрибуты и экземпляры.

Ссылки на атрибуты используют стандартный синтаксис, используемый для всех ссылок на атрибуты в Python: obj.name. Допустимыми именами атрибутов являются все имена, которые были в пространстве имен класса, когда был создан объект класса. Таким образом, если определение класса выглядит так:

class MyClass:
    """A simple example class"""
    i = 12345
    def f(self):
        return 'hello world'
тогда MyClass.i и MyClass.f правильные ссылки на атрибуты, возвращающие целое число и объект-функцию соответственно. Атрибуты класса также могут быть назначены, так что вы можете изменить значение MyClass.i с помощью присвоения. __doc__ также является доступным атрибутом, возвращающим строку документации, принадлежащей классу: "A simple example class".

Экземпляр класса использует нотацию в виде функции. Просто делается вид, что объект класса - это функция без параметров, которая возвращает новый экземпляр класса. Например (предполагая, класс выше):

x = MyClass()
создается новый экземпляр класса, и этот объект присваивается локальной переменной х.

Операция создания экземпляра (вызов объекта класса) создает пустой объект. Многие классы при создании экземпляров настроены на определенное исходное состояние. Поэтому в классе может быть определен специальный метод с именем __init__() (docs.python.org/3/reference/datamodel.html#object.__init__), например:

def __init__(self):
    self.data = []
Если класс определяет метод __init__(), он автоматически вызывается при создании экземпляра класса. В данном примере новый инициализированный экземпляр может быть получен так:

x = MyClass()
Конечно, для большей гибкости метод  __init__() может иметь аргументы. В этом случае аргументы, переданные оператору создания экземпляра класса, передаются в __init__(). Пример:

>>> class Complex:
...     def __init__(self, realpart, imagpart):
...         self.r = realpart
...         self.i = imagpart
...
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)
9.3.3. Объекты экземпляров
Теперь что мы можем делать с объектами экземпляров? Допустимы только операции, представляющие собой ссылки на атрибуты объекта. Есть два вида допустимых имен атрибутов, атрибуты данных и методы.

data attributes (атрибуты данных) соответствуют "переменным экземпляра" в Smalltalk, а также "элементам данных" в C++. Нет необходимости объявлять атрибуты данных; как локальные переменные, они начинают существовать, когда им впервые происходит присваивание. Например, если х является экземпляром MyClass, созданного выше, следующий фрагмент кода выведет значение 16:

x.counter = 1
while x.counter < 10:
    x.counter = x.counter * 2
print(x.counter)
del x.counter
Другой вид ссылки на атрибут экземпляра - это method. Метод является функцией, которая "принадлежит" объекту. (В Python, термин метод не является уникальным для экземпляров класса: другие типы объектов также могут иметь методы. Например, объекты списка имеют методы, называемые append, insert, remove, sort (добавление, вставка, удаление, сортировка) и т. д. Тем не менее в последующем обсуждении мы будем использовать термин метод исключительно для обозначения методов объектов-экземпляров класса, если явно не указано иное.)

Допустимые имена методов объекта-экземпляра зависят от его класса. По определению, все атрибуты класса, которые являются объектами-функциями, определяют соответствующие методы его экземпляров. Так в нашем примере, x.f является допустимой ссылкой-методом, так как MyClass.f является функцией, но не x.i, так как MyClass.i не является. Но x.f - это не то же самое, что и MyClass.f - это метод-объект, а не функция-объект.

9.3.4. Объекты метода
Обычно метод вызывается сразу после точки:

x.f()
В MyClass, например, такой вызов вернет строку 'hello world'. Тем не менее, нет необходимости вызывать метод сразу: x.f является методом- объектом, и может быть сохранен в "стороне" и вызываться позже. Например:

xf = x.f
while True:
    print(xf())
будет продолжать выводить hello world до конца времени.

Что именно происходит, когда вызывается метод? Вы могли заметить, выше x.f() был вызван без аргумента, при том, что в определении функции f() указывается аргумент. Что случилось с аргументом? Конечно Python генерирует исключение, когда функция, которая требует аргумент вызывается без него - даже если аргумент фактически не используется...

На самом деле, вы могли уже догадаться: особенность метода в том, что объект передается в качестве первого аргумента функции. В нашем примере вызов x.f() в точности эквивалентно MyClass.f(х). В общем, вызов метода со списком n аргументов эквивалентен вызову соответствующей функции со списком аргументов, который создается путем введения объекта метода перед первым аргументом.

Если вы все еще не понимаете, как работают методы, взгляд на реализацию, возможно прояснит ситуацию. Когда ссылаются на атрибут экземпляра, который не является атрибутом данных, ищется его класс. Если имя обозначает действительный атрибут класса, который является объектом-функцией, метод-объект создается упаковкой (указателями на) объект-экземпляр и объект-функцию только что вошедших вместе в абстрактный объект: это метод-объект. Когда объект метода вызывается со списком аргументов, новый список аргументов строится из объекта-экземпляра и списка аргументов, и объект-функция вызывается с этим новым списком аргументов.

9.3.5. Переменные класса и экземпляра
Вообще говоря, данные переменных экземпляра уникальны для каждого экземпляра, а атрибуты и функции переменных класса разделяются всеми экземплярами класса:

class Dog:

    kind = 'canine'         # переменная класса разделяется всеми экземплярами

    def __init__(self, name):
        self.name = name    # переменная экземпляра уникальна для каждого

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.kind                  # разделяется всеми собаками
'canine'
>>> e.kind                  # разделяется всеми собаками
'canine'
>>> d.name                  # уникальна для d
'Fido'
>>> e.name                  # уникальна для e
'Buddy
Как уже говорилось в разделе 9.1., разделяемые данные могут иметь возможно неожиданные эффекты в случае привлечения изменяемых (docs.python.org/3/glossary.html#term-mutable) объектов, таких как списки и словари. Например, список tricks в следующем коде не должен быть использован как переменная класса просто потому, что единственный список будет разделяться всеми экземплярами Dog:

class Dog:

    tricks = []             # ошибочное использование переменной класса

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks                # неожиданно разделяется всеми собаками
['roll over', 'play dead']
Вместо этого в корректной разработке класса следует использовать переменную экземпляра:

class Dog:

    def __init__(self, name):
        self.name = name
        self.tricks = []    # создает новый пустой список для каждой собаки

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']
9.4. Некоторые замечания
Атрибуты данных переопределяют атрибуты метода с тем же именем; чтобы избежать случайных конфликтов имен, которые могут привести к трудно обнаруживаемым ошибкам в больших программах, имеет смысл использовать какое-либо соглашение, которое свело бы к минимуму вероятность подобных конфликтов. Это может быть использование большой первой буквы для имен методов, предварение имен атрибутов данных небольшой уникальной строкой (возможно, просто подчеркивание), или использование глаголов для методов и существительных для атрибутов данных.

На атрибуты данных могут ссылаться методы, а также обычные пользовательские ("клиенты") объекты. Другими словами, классы не могут быть использованы для реализации чисто абстрактных типов данных. На самом деле ничто в Python не позволяет обеспечить соблюдение сокрытия данных - все что есть основано лишь на соглашениях. (С другой стороны, реализация Python, написанная на C, может полностью скрыть детали реализации и контроль доступа к объекту при необходимости; это может быть использовано расширениями Python, написанными на C.)

Клиенты должны использовать атрибуты данных с осторожностью - клиенты могут испортить постоянные, поддерживаемые методами, "штампуя" на их атрибуты данных. Обратите внимание, что клиенты могут добавить свои атрибуты данных экземплярному объекту без использования существующих методов до тех пор, пока не возникает конфликта имен; - опять же, соглашение об именах позволит избежать головной боли.

Не существует сокращений для того, чтобы сослаться на атрибуты данных (или другие методы!) изнутри методов. Я считаю, что это на самом деле повышает удобство чтения методов: нет шансов запутаться в локальных переменных и переменных экземпляра, когда просматриваешь методы.

Часто первый аргумент метода называется self. Это не более, чем соглашение: имя self не имеет абсолютно никакого особого значение для Python. Однако следует отметить, что если не следовать соглашению, то ваш код может быть менее читаемым для других программистов Python, и также возможно, что класс browser программы может быть написан, полагаясь на такое соглашение.

Любой объект-функция, которая является атрибутом класса, определяет метод для экземпляров этого класса. Не обязательно, чтобы определение функции текстуально заключалось в определении класса: присваивание объекта-функции локальной переменной в классе также возможно. Например:

# Функция определяется вне класса
def f1(self, x, y):
    return min(x, x+y)
 
class C:
    f = f1
    def g(self):
        return 'hello world'
    h = g
Теперь и f, и g, и h являются атрибутами класса C, который ссылается на функции-объекты, и, следовательно, все они являются методами экземпляров класса C - h есть точный эквивалент g. Обратите внимание, что эта практика, как правило, способна лишь запутать читателя программы.

Методы могут вызывать другие методы путем использования аргумента self:

class Bag:
    def __init__(self):
        self.data = []
    def add(self, x):
        self.data.append(x)
    def addtwice(self, x):
        self.add(x)
        self.add(x)
Методы могут ссылаться на глобальные имена также, как и обычные функции. Глобальная область видимости, ассоциированная с методом, есть модуль, содержащий его определение. (Класс никогда не используется как глобальная область). Поскольку это редко встречается, то это хороший повод для использования глобальных данных в методе, есть много уместных использований глобальной области: с одной стороны, функции и модули, импортированные в глобальную область видимости, могут использоваться методами также как функциями и классами, определенными здесь. Как правило, класс, содержащий метод, сам по себе определяется в этой глобальной области видимости, и в следующем разделе мы найдем несколько хороших причин, почему метод хотел бы ссылаться на свой собственный класс.

Каждое значение является объектом, и поэтому имеет класс (также называемый его типом). Он хранится как object.__class__.

9.5. Наследование
Несомненно свойство языка не имела бы право называться "классом" без поддержки наследования. Синтаксис для определения производного класса выглядит следующим образом:

class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
Имя BaseClassName должны быть определено в пределах области видимости производного класса. На месте имени базового класса также допускается иные произвольные выражения. Это может быть использовано, например, когда базовый класс определен в другом модуле:

class DerivedClassName(modname.BaseClassName):
Выполнение определения производного класса протекает так же, как для базового класса. Когда объект класса создается, базовый класс запоминается. Это используется для выяснения ссылок на атрибуты: если запрошенный атрибут не найден в классе, поиск продолжается в базовом классе. Это правило применяется рекурсивно, если сам базовый класс является производным от другого класса.

Нет ничего особенного в экземплярах производных классов: DerivedClassName() создает новый экземпляр класса. Ссылки на методы разрешаются следующим образом: требуемый атрибут класса ищется по убыванию вниз по цепочке базовых классов, если это необходимо, и ссылка на метод работает, если она дает объект функции.

Производные классы могут переопределить методы их базовых классов. Потому как методы не имеют особых привилегий при вызове других методов того же объекта, так метод базового класса, что вызывает другой метод, определенный в том же базовом классе, может в конечном итоге вызвать метод производного класса, который переопределяет его. (Для программистов на C++: все методы в Python фактически являются virtual.)

Переопределенный метод в производном классе на самом деле может потребоваться расширить, а не просто заменить метод базового класса с тем же именем. Существует простой способ вызвать метод базового класса напрямую: просто напишите BaseClassName.methodname(self, arguments). Это также иногда полезно для клиентов. (Заметим, что это работает только если базовый класс доступен как BaseClassName в глобальной области видимости.)

У Python есть две встроенные функции, которые работают с наследованием:

Используйте isinstance(), чтобы проверить тип экземпляра: isinstance(obj, int) вернет True, если только obj.__class__ является int или некоторый класс, производный от int.
Используйте issubclass() для проверки наследования классов: issubclass(bool, int) есть True, поскольку bool - это подкласс int. Однако, issubclass(float, int) ложно, так как float не является подклассом int.
9.5.1. Множественное наследование
Python также поддерживает форму множественного наследования. Определение класса с несколькими базовыми классами выглядит следующим образом:

class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
Для большинства целей, в простейших случаях, вы можете думать о поиске атрибутов, унаследованных от родительского класса, как сначала в глубину, затем слева-направо, не ищет дважды в том же классе, где есть совпадение в иерархии. Таким образом, если атрибут не найден в DerivedClassName, он ищется в Base1, затем (рекурсивно) в базовых классах Base1, и если не был найден там, поиск будет продолжен в Base2 и так далее.

На самом деле все немного сложнее; порядок выбора метода динамически изменяется для поддержки совместных вызовов к super(). Такой подход известен в некоторых других языках с множественным наследованием как "вызов следующего метода" и является более мощным, чем вызов super, присутствующего в языках с одиночным наследованием.

Динамическое следование необходимо потому, что все случаи множественного наследования обладают одним или несколькими взаимосвязанными отношениями (где по крайней мере один из родительских классов может быть доступен через множество путей от самого нижнего класса). Например, все классы унаследованы от object, так что любой случай множественного наследования обеспечивает более одного пути, чтобы добраться до object. Чтобы сохранить базовые классы от доступа более одного раза, динамический алгоритм делает линейным порядок поиска таким образом, чтобы сохранить порядок слева-направо, указанный в каждом классе, который вызывает каждого родителя только один раз (это означает, что от класса можно создать подкласс не затрагивая порядок приоритетов его родителей). Взятые вместе эти свойства делают возможным создание надежных и расширяемых классов с множественным наследованием. Более подробно см. python.org/download/releases/2.3/mro/.

9.6. Приватные переменные
В Python не существует "частных" (приватных) переменных экземпляра, т.е. тех, которые не могут быть доступны, кроме как изнутри объекта. Тем не менее есть соглашение, которое поддерживается большей частью кода Python: идентификатор с префиксом нижней черты (например _spam) должны рассматриваться как непубличная часть API (будь то функция, метод или элемент данных). Следует учитывать, детали реализации и предмет могут быть изменены без предварительного уведомления.

Поскольку есть действительные прецеденты для приватных членов класса (а именно, чтобы избежать конфликтов имен с именами, определенными подклассами), есть ограниченная поддержка такого механизма, называемого корректировкой имен (name mangling). Любой идентификатор вида __spam (по крайней мере с двумя первыми подчеркиваниями и не более чем одним завершающим) текстуально заменяются на _classname__spam, где classname - это текущее имя класса с начальным символом(ами) подчеркивания. Эта корректировка делается безотносительно к синтаксической позиции идентификатора до тех пор, пока это происходит в определении класса.

Корректировка имен полезна для того, чтобы позволить подклассам переопределять методы, не нарушая внутриклассовых вызовов методов. Например:

class Mapping:
    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)
 
    def update(self, iterable):
        for item in iterable:
            self.items_list.append(item)
 
    __update = update   # приватная копия оригинального метода update()
 
class MappingSubclass(Mapping):
 
    def update(self, keys, values):
        # предоставляет новую подпись для update()
        # но не ломает __init__()
        for item in zip(keys, values):
            self.items_list.append(item)
Хотя в основном правила корректировки предназначены для избежания несчастных случаев, но все равно можно получить доступ или изменить переменную, которая считается приватной. Это даже может быть полезно при особых обстоятельствах, например, в отладчике.

Обратите внимание, что код, передающийся exec() или eval(), не учитывает имя класса вызывающего класса к текущему классу; это похоже на эффект оператора global, эффект, который также ограничивается кодом, который байт-скомпилированный вместе. То же ограничение применяется к getattr(), setattr() и delattr(), а также при обращении к __dict__ напрямую.

9.7. Различные заметки
Иногда бывает полезно иметь тип данных похожий на запись в Паскале или структуру в C, связав вместе несколько именованных элементов данных. Определение пустого класса превосходно представит такую возможность:

class Employee:
    pass
 
john = Employee() # Создает пустую запись employee
 
# Заполняются поля записи
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
Часть кода Python, который ожидает определенного абстрактного типа данных, часто может быть передан классу, который эмулирует методы вместо этого типа данных. Например, если у вас есть функция, которая форматирует некоторые данные из файлового объекта, вы можете определить класс с методами read() и readline(), которые вместо этого получают данные из буфера строки, и передают их в качестве аргумента.

Объекты методов экземпляра имеют атрибуты также: m.__self__ является объектом экземпляра с методом m(), и m.__func__ является объектом функцией, соответствующей этому методу.

9.8. Итераторы
К этому моменту вы возможно заметили, что большинство контейнерных объектов позволяют совершить по ним циклический проход с помощью оператора for (docs.python.org/3/reference/compound_stmts.html#for):

for element in [1, 2, 3]:
    print(element)
for element in (1, 2, 3):
    print(element)
for key in {'one':1, 'two':2}:
    print(key)
for char in "123":
    print(char)
for line in open("myfile.txt"):
    print(line, end='')
Этот стиль доступа является ясным, кратким, и удобным. Использование итераторов пронизывает и объединяет Python. За сценой оператор for вызывает iter() на объект-контейнер. Эта функция возвращает объект-итератор, который определяет метод __next__(), который выбирает элементы контейнера по одному за раз. Когда больше элементов нет, __next__() вызывает исключение StopIteration (docs.python.org/3/library/exceptions.html#StopIteration), которое заставляет цикл for завершиться. Вы можете вызвать метод __next__() с помощью встроенной функции next(); этот пример показывает, как все это работает:

>>> s = 'abc'
>>> it = iter(s)
>>> it
<iterator object at 0x00A1DB50>
>>> next(it)
'a'
>>> next(it)
'b'
>>> next(it)
'c'
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
    next(it)
StopIteration
Увидев как работает механизм протокола итератора, легко добавить поведение итератора в классы. Определите метод __iter__(), который возвращает объект с методом __next__(). Если класс определяет __next__(), затем __iter__(), то можно просто вернуть self:

class Reverse:
    """Итератор для обхода последовательности наоборот."""
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
>>> rev = Reverse('spam')
>>> iter(rev)
<__main__.Reverse object at 0x00A1DB50>
>>> for char in rev:
...     print(char)
...
m
a
p
s
9.9. Генераторы
Генераторы (docs.python.org/3/glossary.html#term-generator) представляют собой простой и мощный инструмент для создания итераторов. Они написаны как обычные функции, но используют оператор yield (docs.python.org/3/reference/simple_stmts.html#yield), всякий раз когда требуется вернуть данные. Каждый раз next() вызывается на это, генератор возвращается туда, где был до этого (он запоминает все значения и какой оператор был выполнен последним). Пример показывает, как можно легко создать генератор:

def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
>>> for char in reverse('golf'):
...     print(char)
...
f
l
o
g
Все, что может быть сделано с помощью генераторов, также может быть сделано с итераторами на основе классов, как описано в предыдущем разделе. То, что делает генераторы настолько компактными, это методы __iter__() и __next__(), которые создаются автоматически.

Еще одной ключевой особенностью является то, что локальные переменные и состояние выполнения автоматически сохраняются между вызовами. Это сделало функцию легче для написания и гораздо яснее, чем подход с использованием переменных экземпляра, как self.index и self.data.

В дополнение к автоматическому созданию метода и сохранению состояния программы, когда генераторы прекращают работу, они автоматически возбуждают StopIteration (docs.python.org/3/library/exceptions.html#StopIteration). В сочетании эти особенности позволяют легко создавать итераторы с не большими усилиями, чем писать обычные функции.

9.10. Выражения с использованием генераторов
Некоторые простые генераторы могут быть закодированы лаконично как выражения, используя синтаксис, аналогичный списку, но с круглыми скобками вместо квадратных. Эти выражения предназначены для ситуаций, когда генератор используется сразу же включающей функцией. Выражения с генератором более компактные, но менее универсальные, чем полные определения генераторов и, как правило, быть более дружелюбны, чем эквивалентное использование списков.

Примеры:

>>> sum(i*i for i in range(10))                 # сумма квадратов
285
 
>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x*y for x,y in zip(xvec, yvec))         # dot product
260
 
>>> from math import pi, sin
>>> sine_table = {x: sin(x*pi/180) for x in range(0, 91)}
 
>>> unique_words = set(word  for line in page  for word in line.split())
 
>>> valedictorian = max((student.gpa, student.name) for student in graduates)
 
>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))
['f', 'l', 'o', 'g']
Примечания

[1] За исключением одной вещи. У объектов модуля есть секретный атрибут только для чтения атрибут __dict__, который возвращает словарь, используемый для реализации пространства имен модуля; имя __dict__ является атрибутом, но не глобальным именем. Очевидно, что его использование нарушает абстракцию реализации пространства имен, и должно быть ограничена к вещам, как завершающие действия отладчиков.

10. Краткий обзор стандартной библиотеки
10.1. Интерфейс операционной системы
10.2. Файловые шаблоны
10.3. Аргументы командной строки
10.4. Вывод перенаправленных ошибок и завершение программы
10.5. Согласование строкового шаблона
10.6. Математика
10.7. Доступ в Интернет
10.8. Даты и время
10.9. Сжатие данных
10.10. Измерение производительности
10.11. Контроль качества
10.12. Батарейки включены
10.1. Интерфейс операционной системы
Модуль os (docs.python.org/3/library/os.html#module-os) предоставляет множество функций для взаимодействия с операционной системой:

>>> import os
>>> os.getcwd()      # Возвращает текущую рабочую директорию
'C:\\Python36'
>>> os.chdir('/server/accesslogs')   # Изменяет текущую рабочую директорию
>>> os.system('mkdir today')   # Запускает команду mkdir в системной оболочке
0
Обязательно используйте стиль import os вместо from os import *. Это сохранит os.open() (docs.python.org/3/library/os.html#os.open) от перекрытия встроенной функции open(), которая совсем по-другому работает.

Встроенные функции dir() и help() полезны как интерактивные пособия для работы с большими модулями, как os:

>>> import os
>>> dir(os)
<returns a list of all module functions>
>>> help(os)
<returns an extensive manual page created from the module's docstrings>
Для ежедневных задач по управлению файлами и каталогами модуль shutil (docs.python.org/3/library/shutil.html#module-shutil) предоставляет интерфейс более высокого уровня, который проще в использовании:

>>> import shutil
>>> shutil.copyfile('data.db', 'archive.db')
>>> shutil.move('/build/executables', 'installdir')
10.2. Файловые шаблоны
Модуль glob (docs.python.org/3/library/glob.html#module-glob) предоставляет функцию для создания списков файлов по шаблону из найденных в каталоге:

>>> import glob
>>> glob.glob('*.py')
['primes.py', 'random.py', 'quote.py']
10.3. Аргументы командной строки
В обычных скриптах-утилитах часто нужно обрабатывать аргументы командной строки. Эти аргументы хранятся в атрибуте argv модуля sys (docs.python.org/3/library/sys.html#module-sys) в виде списка. Например следующие выходные результаты будут получены от выполнения команды python demo.py one two three в командной строке:

>>> import sys
>>> print(sys.argv)
['demo.py', 'one', 'two', 'three']
Модуль getopt (docs.python.org/3/library/getopt.html#module-getopt) обрабатывает sys.argv, используя соглашения Unix по функции getopt(). Более мощная и гибкая обработка командной строки обеспечивается модулем argparse (docs.python.org/3/library/argparse.html#module-argparse).

10.4. Вывод перенаправленных ошибок и завершение программы
Модуль sys также имеет атрибуты для stdin (стандартный ввод), stdout (стандартный вывод) и stderr (стандартный вывод ошибок). Последний полезен для генерации предупреждений и сообщений об ошибках, чтобы сделать их видимыми, даже когда stdout (стандартный вывод) был перенаправлен:

>>> sys.stderr.write('Warning, log file not found starting a new one\n')
Warning, log file not found starting a new one
Самый очевидный способ завершить сценарий заключается в использовании sys.exit().

10.5. Строковый шаблон
Модуль re (docs.python.org/3/library/re.html#module-re) предоставляет инструменты регулярных выражений для более глубокой обработки строк. Для комплексного сопоставления и управления регулярные выражения предлагают краткие, оптимизированные решения:

>>> import re
>>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
['foot', 'fell', 'fastest']
>>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
'cat in the hat'
Когда необходимы только простые возможности, методы строк являются предпочтительными, поскольку они являются более удобными для чтения и отладки:

>>> 'tea for too'.replace('too', 'two')
'tea for two'
10.6. Математика
Модуль math (docs.python.org/3/library/math.html#module-math) предоставляет доступ к базовым функциям библиотеки C для математики с плавающей точкой:

>>> import math
>>> math.cos(math.pi / 4)
0.70710678118654757
>>> math.log(1024, 2)
10.0
Модуль random (docs.python.org/3/library/random.html#module-random) предоставляет инструменты для создания случайного выбора:

>>> import random
>>> random.choice(['apple', 'pear', 'banana'])
'apple'
>>> random.sample(range(100), 10)   # выборка без замены
[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
>>> random.random()    # случайное вещественное число
0.17970987693706186
>>> random.randrange(6)    # случайное целое, выбранное из  range(6)
4
Модуль statistics (docs.python.org/3/library/statistics.html#module-statistics) вычисляет основные статистические свойства (среднее, медиану, расхождение и т. д.) числовых данных:

>>> import statistics
>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
>>> statistics.mean(data)
1.6071428571428572
>>> statistics.median(data)
1.25
>>> statistics.variance(data)
1.3720238095238095
Проект SciPy имеет много других модулей для численных расчетов.

10.7. Доступ в Интернет
Существует целый ряд модулей для доступа в Интернет и обработки интернет-протоколов. Два из простейших - это urllib.request (docs.python.org/3/library/urllib.request.html#module-urllib.request) для извлечения данных из URL-адресов и smtplib (docs.python.org/3/library/smtplib.html#module-smtplib) для отправки почты:

>>> from urllib.request import urlopen
>>> for line in urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'):
...     line = line.decode('utf-8')  # Декодирование бинарных данных в текст.
...     if 'EST' in line or 'EDT' in line:  # искать Eastern Time
...         print(line)
 
<BR>Nov. 25, 09:43:32 PM EST
 
>>> import smtplib
>>> server = smtplib.SMTP('localhost')
>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
... """To: jcaesar@example.org
... From: soothsayer@example.org
...
... Beware the Ides of March.
... """)
>>> server.quit()
(Заметьте, что во втором примере необходим почтовый сервер, работающий на локальном хосте.)

10.8. Даты и время
Модуль datetime (docs.python.org/3/library/datetime.html#module-datetime) поставляет классы для управления датой и временем различной степени сложности. Пока вычисления даты и времени поддерживаются, в центре внимания реализации - на эффективное извлечение члена для форматирования вывода и манипуляции. Модуль также поддерживает объекты, "осведомленные" о часовом поясе.

>>> # даты легко конструируются и форматируются
>>> from datetime import date
>>> now = date.today()
>>> now
datetime.date(2003, 12, 2)
>>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'
 
>>> # даты поддерживают календарную арифметику
>>> birthday = date(1964, 7, 31)
>>> age = now - birthday
>>> age.days
14368
10.9. Сжатие данный
Обычные форматы архивирования и сжатия данных напрямую поддерживаются модулями включая:
zlib (docs.python.org/3/library/zlib.html#module-zlib), gzip (docs.python.org/3/library/gzip.html#module-gzip), bz2 (docs.python.org/3/library/bz2.html#module-bz2), lzma (docs.python.org/3/library/lzma.html#module-lzma), zipfile (docs.python.org/3/library/zipfile.html#module-zipfile) и tarfile (docs.python.org/3/library/tarfile.html#module-tarfile).

>>> import zlib
>>> s = b'witch which has which witches wrist watch'
>>> len(s)
41
>>> t = zlib.compress(s)
>>> len(t)
37
>>> zlib.decompress(t)
b'witch which has which witches wrist watch'
>>> zlib.crc32(s)
226805979
10.10. Измерение производительности
Некоторым пользователям Python важно знать относительную производительность различных подходов к решению одной проблемы. Python предоставляет инструмент измерения, который сразу отвечает на эти вопросы.

Например, может быть заманчивым использовать возможность упаковки и распаковки кортежа вместо традиционного подхода к обмену аргументов. Модуль timeit (docs.python.org/3/library/timeit.html#module-timeit) быстро демонстрирует скромное преимущество в производительности:

>>> from timeit import Timer
>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
0.57535828626024577
>>> Timer('a,b = b,a', 'a=1; b=2').timeit()
0.54962537085770791
В отличие от хорошего уровня детализации timeit, модули profile (docs.python.org/3/library/profile.html#module-profile) и pstats (docs.python.org/3/library/profile.html#module-pstats) модули предоставляют средства для идентификации времени критических секций в крупных блоках кода.

10.11. Контроль качества
Один из подходов к разработке высококачественного программного обеспечения - это создание тестов для каждой функции, когда она будет разработана, и часто выполнять эти тесты в процессе разработки.

Модуль doctest (docs.python.org/3/library/doctest.html#module-doctest) предоставляет инструмент для сканирования модуля и проверки тестов, встроенных в строки документации программы. Создать тест так же просто, как вырезать и вставить типичный вызов вместе с его результатом в строку документации. Это улучшает документацию, показывая пользователю пример, и это позволяет модулю doctest убедиться, что код остается верен документации:

def average(values):
    """Вычисляет среднее арифметическое списка чисел.
 
    >>> print(average([20, 30, 70]))
    40.0
    """
    return sum(values) / len(values)
 
import doctest
doctest.testmod()   # автоматически подтверждает встроенные тесты
Модуль unittest (docs.python.org/3/library/unittest.html#module-unittest) не такой легкий, как модуль doctest, но он позволяет провести более полный набор тестов, чтобы поддерживаться в отдельном файле:

import unittest
 
class TestStatisticalFunctions(unittest.TestCase):
 
    def test_average(self):
        self.assertEqual(average([20, 30, 70]), 40.0)
        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
        with self.assertRaises(ZeroDivisionError):
            average([])
        with self.assertRaises(TypeError):
            average(20, 30, 70)
 
unittest.main() # Запуск из командной строки запускает все тексты
10.12. Батарейки включены
Философия Python - "батарейки включены". Это лучше всего видно на утонченных и мощных возможностях его более крупных пакетов. Например:

Модули xmlrpc.client и xmlrpc.server делают тривиальной задачей реализацию удаленных вызовов процедур. Несмотря на имена модулей, никакого непосредственного знания или обращения к XML не требуется.
Пакет email представляет собой библиотеку для управления сообщениями электронной почты, в том числе MIME и другими RFC 2822-based сообщениями. В отличие от smtplib и poplib, которые фактически отправляют и получают сообщения, пакет email имеет полный набор инструментов для создания или декодирования сложной структуры сообщений (включая вложения) и для реализации интернет-кодирования и протоколов заголовков.
Пакет json обеспечивает мощную поддержку для анализа этого популярного формата обмена данными. Модуль csv поддерживает прямое чтение и запись файлов в формате Comma-Separated Value (значения, разделенные запятыми), обычно поддерживаемые базами данных и электронными таблицами. Обработка XML поддерживается пакетами xml.etree.ElementTree, xml.dom и xml.sax. Вместе эти пакеты чрезвычайно упрощают обмен данными между приложениями Python и другими инструментами.
Модуль sqlite3 - обертка для библиотеки SQLite базы данных, предоставляющей постоянную базу данных, которая может быть обновлена и к которой можно получить доступ немного нестандартным синтаксисом SQL.
Интернационализация поддерживается рядом модулей, включая gettext, locale и пакет codecs.

11. Краткий обзор стандартной библиотеки - Часть II
11.1. Форматирование вывода
11.2. Использование шаблонов
11.3. Работа с форматами записи двоичных данных
11.4. Многопоточность
11.5. Регистрация
11.6. Слабые ссылки
11.7. Инструменты для работы со списками
11.8. Арифметика десятичных чисел с плавающей точкой
Этот второй тур охватывает более продвинутые модули, которые поддерживают профессиональные потребности программирования. Эти модули редко встречаются в небольших скриптах.

11.1. Форматирование вывода
Модуль reprlib предоставляет версию repr(), настроенную для укороченных отображений больших или глубоко вложенных контейнеров:

>>> import reprlib
>>> reprlib.repr(set('supercalifragilisticexpialidocious'))
"set(['a', 'c', 'd', 'e', 'f', 'g', ...])"
Модуль pprint предлагает более тонкий контроль над выводом как встроенных, так и пользовательских объектов таким образом, что интерпретатор выводит их в более читаемом виде. Когда результат больше длины строки, то "приятный вывод" добавляет разрывы строк и отступы, чтобы более четко показать структуру данных:

>>> import pprint
>>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
...     'yellow'], 'blue']]]
...
>>> pprint.pprint(t, width=30)
[[[['black', 'cyan'],
   'white',
   ['green', 'red']],
  [['magenta', 'yellow'],
   'blue']]]
Модуль textwrap форматирует абзацы текста, чтобы соответствовать заданной ширине экрана:

>>> import textwrap
>>> doc = """The wrap() method is just like fill() except that it returns
... a list of strings instead of one big string with newlines to separate
... the wrapped lines."""
...
>>> print(textwrap.fill(doc, width=40))
The wrap() method is just like fill()
except that it returns a list of strings
instead of one big string with newlines
to separate the wrapped lines.
Модуль locale обращается к базе данных определенных культур. Сгруппированный атрибут формата функции locale обеспечивает прямой путь форматирования чисел с групповыми сепараторами:

>>> import locale
>>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
'English_United States.1252'
>>> conv = locale.localeconv()          # get a mapping of conventions
>>> x = 1234567.8
>>> locale.format("%d", x, grouping=True)
'1,234,567'
>>> locale.format_string("%s%.*f", (conv['currency_symbol'],
...                      conv['frac_digits'], x), grouping=True)
'$1,234,567.80'
11.2. Использование шаблонов
Модуль string включает в себя универсальный класс Template с упрощенным синтаксисом, подходящий для использования конечными пользователями. Он позволяет пользователям настраивать их приложения без необходимости изменять само приложение.

Формат использует "заполняющие" имена, образованные $ с допустимыми идентификаторами Python (буквенно-цифровые символы и знак подчеркивания). Если "заполнитель" ограничивается фигурными скобками, то это позволяет после него писать еще буквенно-цифровые символы без пробелов. Написание $$ создает вывод одного $:

>>> from string import Template
>>> t = Template('${village}folk send $$10 to $cause.')
>>> t.substitute(village='Nottingham', cause='the ditch fund')
'Nottinghamfolk send $10 to the ditch fund.'
Метод substitute() возбуждает KeyError, когда заполнитель не поставляется в словаре или аргументе ключевого слова. Для приложений в стиле стандартных писем подставляемые пользовательские данные могут быть неполными и метод safe_substitute() может быть более подходящим - он оставляет заполнители без изменений, если данные отсутствуют:

>>> t = Template('Return the $item to $owner.')
>>> d = dict(item='unladen swallow')
>>> t.substitute(d)
Traceback (most recent call last):
  ...
KeyError: 'owner'
>>> t.safe_substitute(d)
'Return the unladen swallow to $owner.'
Подклассы template могут устанавливать пользовательский разделитель. Например, утилита пакетного переименования для просмотра фото может выбрать использование знака процента для заполнителей, таких как формат текущей даты, порядкового номера изображения или формата файла:

>>> import time, os.path
>>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
>>> class BatchRename(Template):
...     delimiter = '%'
>>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')
Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f
 
>>> t = BatchRename(fmt)
>>> date = time.strftime('%d%b%y')
>>> for i, filename in enumerate(photofiles):
...     base, ext = os.path.splitext(filename)
...     newname = t.substitute(d=date, n=i, f=ext)
...     print('{0} --> {1}'.format(filename, newname))
 
img_1074.jpg --> Ashley_0.jpg
img_1076.jpg --> Ashley_1.jpg
img_1077.jpg --> Ashley_2.jpg
Еще одно применение шаблонов - это разделение логики программы от деталей множества форматов вывода. Это дает возможность заменить пользовательские шаблоны для XML файлов, простых текстовых отчетов и HTML веб-отчетов.

11.3. Работа с форматами записи двоичных данных
Модуль struct предоставляет функции pack() и unpack() для работы с форматами бинарных записей переменной длины. В следующем примере показано, как цикл проходит по информации заголовка в ZIP-файле без использования модуля zipfile. Упаковка кодов "H" и "I" представляет собой двух- и четырех байтовые числа без знака соответственно. Знак "<" указывает, что они стандартных размеров и в немного обратном порядке байтов:

import struct
 
with open('myfile.zip', 'rb') as f:
    data = f.read()
 
start = 0
for i in range(3):                      # показывает первые 3 файловых заголовка
    start += 14
    fields = struct.unpack('<IIIHH', data[start:start+16])
    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields
 
    start += 16
    filename = data[start:start+filenamesize]
    start += filenamesize
    extra = data[start:start+extra_size]
    print(filename, hex(crc32), comp_size, uncomp_size)
 
    start += extra_size + comp_size     # пропускает следующий заголовок
11.4. Многопоточность
Поточность представляет собой метод разъединения задач, которые можно выполнять не последовательно. Потоки могут быть использованы для улучшения быстродействия приложений, которые принимают пользовательский ввод, в то время как другие задачи выполняются в фоновом режиме. С этим связан случай использования запущенного ввода/вывода параллельно с вычислениями в другом потоке.

Следующий код показывает, как высокоуровневый модуль threading может выполнять задачи в фоновом режиме во время того, как продолжает работать основная программа:

import threading, zipfile
 
class AsyncZip(threading.Thread):
    def __init__(self, infile, outfile):
        threading.Thread.__init__(self)
        self.infile = infile
        self.outfile = outfile
    def run(self):
        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
        f.write(self.infile)
        f.close()
        print('Finished background zip of:', self.infile)
 
background = AsyncZip('mydata.txt', 'myarchive.zip')
background.start()
print('The main program continues to run in foreground.')
 
background.join()    # Ждет окончания работы фоновой задачи
print('Main program waited until background was done.')
Основная задача многопоточных приложений - это координация потоков, которые разделяют данные или другие ресурсы. С этой целью, модуль threading предоставляет ряд примитивов синхронизации, включая замки, события, переменные условия и семафоры.

В то время как эти инструменты являются мощным, незначительные ошибки разработки могут привести к проблемам, которые трудно воспроизвести. Таким образом, предпочтительный подход к координации задач - сосредоточить весь доступ к ресурсу в одном потоке, а затем использовать модуль queue, чтобы обеспечить ресурсами этот поток от других потоков. Приложения, использующие объекты Queue для межпотоковых коммуникаций и координации легче проектировать, более удобны для чтения и надежнее.

11.5. Регистрация
Модуль logging предлагает полнофункциональную и гибкую систему регистрации. В самом простом случае, log-сообщения отправляются в файл или в sys.stderr:

import logging
logging.debug('Debugging information')
logging.info('Informational message')
logging.warning('Warning:config file %s not found', 'server.conf')
logging.error('Error occurred')
logging.critical('Critical error -- shutting down')
Получается следующий результат:

WARNING:root:Warning:config file server.conf not found
ERROR:root:Error occurred
CRITICAL:root:Critical error -- shutting down
По умолчанию информационные и отладочные сообщения подавляются и вывод направляется в стандартный поток ошибок. Другие параметры вывода включают маршрутизацию сообщений по электронной почте, дейтаграммам, сокетам или к HTTP-серверу. Новые фильтры могут выбрать различную маршрутизацию на основе приоритета сообщения: DEBUG, INFO, WARNING, ERROR и CRITICAL.

Система регистрации может быть сконфигурирована непосредственно из Python или может быть загружена из редактируемого пользователем файла конфигурации индивидуальных настроек без изменения приложения.

11.6. Слабые ссылки
Python автоматически управляет памятью (подсчет ссылок для большинства объектов и сборка мусора для ликвидации циклов). Память освобождается вскоре после того, как последняя ссылка на нее была устранена.

Этот подход хорошо работает для большинства приложений, но иногда есть необходимость отслеживать объекты только до тех пор, как они используются чем-то еще. К сожалению, только отслеживание их создает ссылку, что делает их постоянными. Модуль weakref предоставляет инструменты для отслеживания объектов, не создавая ссылку. Когда объект больше не нужен, он автоматически удаляется из таблицы weakref и обратный вызов срабатывает для weakref объектов. Обычные приложения включают кэшированные объекты, которые являются слишком ресурсоемкими, чтобы их создавать каждый раз:

>>> import weakref, gc
>>> class A:
...     def __init__(self, value):
...         self.value = value
...     def __repr__(self):
...         return str(self.value)
...
>>> a = A(10)                   # создает ссылку
>>> d = weakref.WeakValueDictionary()
>>> d['primary'] = a            # не создает ссылку
>>> d['primary']                # приносит объект, если он все еще живой
10
>>> del a                       # удаляет одну ссылку
>>> gc.collect()                # сразу запускает сборку мусора
0
>>> d['primary']                # запись была автоматически удалена
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    d['primary']                # запись была автоматически удалена
  File "C:/python33/lib/weakref.py", line 46, in __getitem__
    o = self.data[key]()
KeyError: 'primary'
11.7. Инструменты для работы со списками
Многие потребности структуры данных могут быть удовлетворены с помощью встроенного спискового типа. Тем не менее, иногда возникает потребность в альтернативных реализациях с учетом различных компромиссов производительности.

Модуль array предоставляет объект array(), который подобен списку, хранящему только однородные данные, и сохраняет их более компактно. В следующем примере показан массив чисел, хранящихся в виде беззнаковых двухбайтовых двоичных чисел (typecode "H"), а не обычных 16-байтовых как их записывает обычных список в Python в объекты типа int:

>>> from array import array
>>> a = array('H', [4000, 10, 700, 22222])
>>> sum(a)
26932
>>> a[1:3]
array('H', [10, 700])
Модуль collections предоставляет объект deque(), который, как список, более быстро добавляет и извлекает с левой стороны, но медленнее осуществляет поиск в середине. Эти объекты хорошо подходят для реализации очередей и широкого первого дерева поиска:

>>> from collections import deque
>>> d = deque(["task1", "task2", "task3"])
>>> d.append("task4")
>>> print("Handling", d.popleft())
Handling task1
unsearched = deque([starting_node])
def breadth_first_search(unsearched):
    node = unsearched.popleft()
    for m in gen_moves(node):
        if is_goal(m):
            return m
        unsearched.append(m)
В дополнение к альтернативным реализациям списка библиотека также предлагает и другие инструменты, такие как модуль bisect с функциями для манипулирования упорядоченными списками:

>>> import bisect
>>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
>>> bisect.insort(scores, (300, 'ruby'))
>>> scores
[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]
Модуль heapq предоставляет функции для реализации куч, основанных на обычных списках. Самая низкая по значению запись всегда держится в нулевой позиции. Это полезно для приложений, которые неоднократно обращаются к наименьшему элементу, но не хотят запускать полную сортировку списка:

>>> from heapq import heapify, heappop, heappush
>>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
>>> heapify(data)                      # переделывание списка в порядок кучи
>>> heappush(data, -5)                 # добавляет новую запись
>>> [heappop(data) for i in range(3)]  # приносит три наименьшие записи
[-5, 0, 1]
11.8. Десятичная арифметика с плавающей точкой
Модуль decimal (docs.python.org/3/library/decimal.html#module-decimal) предлагает тип данных Decimal для десятичной арифметики с плавающей точкой. По сравнению с встроенной реализацией бинарного с плавающей точкой типа float, класс особенно полезен для

финансовых приложений и другого использования, которое требует точного десятичного представления,
контроля за точностью,
контроля за округлением для обеспечения юридических или нормативных требований,
отслеживания значимых знаков после запятой, или
приложений, где пользователь ожидает, что результаты совпадут с расчетами сделанными вручную.
Например, вычисление 5%-ого налога на 70 центов дает разные результаты с десятичной плавающей точкой и двоичной плавающей точкой. Разница становится заметной, если результаты округляются до ближайшего цента:

>>> from decimal import *
>>> round(Decimal('0.70') * Decimal('1.05'), 2)
Decimal('0.74')
>>> round(.70 * 1.05, 2)
0.73
Результат Decimal сохраняет конечный нуль, автоматически выводя четырехместное значение от сомножителей с двухместным значением. Decimal воспроизводит подсчеты как сделанные вручную и позволяет избежать проблем, которые могут возникнуть, когда двоичная плавающая точка не может точно представить десятичные величины.

Точное представление позволяет классу Decimal находить остаток от деления и выполнять сравнения, которые невозможны для бинарной плавающей точки:

>>> Decimal('1.00') % Decimal('.10')
Decimal('0.00')
>>> 1.00 % 0.10
0.09999999999999995
 
>>> sum([Decimal('0.1')]*10) == Decimal('1.0')
True
>>> sum([0.1]*10) == 1.0
False
Модуль decimal позволяет вычислять с той точностью, которая необходима:

>>> getcontext().prec = 36
>>> Decimal(1) / Decimal(7)
Decimal('0.142857142857142857142857142857142857')

12. Виртуальное окружение и пакеты
12.1. Введение
12.2. Создание виртуального окружения
12.3. Управление пакетами с помощью pip
12.1. Введение
Приложения Python часто используют пакеты и модули, которые не поставляются как часть стандартной библиотеки. Приложениям иногда будут необходимы специфические версии библиотеки, потому что приложение может требовать, чтобы конкретный баг был исправлен или само приложение может быть написано, используя устаревшую версию интерфейса библиотеки.

Это означает, что может отсутствовать возможность для одной установки Python удовлетворить требования каждого приложения. Если приложению A нужна версия 1.0 конкретного модуля, но приложение B нуждается в версии 2.0, то требования конфликтуют и установка любой версии 1.0 или 2.0 оставит одно приложении неспособным запуститься.

Решением этой проблемы является создание virtual environment (docs.python.org/3/glossary.html#term-virtual-environment), автономного дерева директорий, которое содержит инсталляцию Python для конкретной версии Python, плюс ряд дополнительных пакетов.

Различные приложения могут потом использовать разные виртуальные окружения (virtual environments). В примере выше, чтобы разрешить конфликт требований, приложение A может иметь свою собственную виртуальную среду с установленной версией 1.0, в то время как у приложения B будет другое виртуальное окружение с версией 2.0. Если B требует библиотеку, которая должна быть обновлена до версии 3.0, это не касается окружения приложения A.

12.2. Создание виртуального окружения
Модуль, используемый для создания и управления виртуальными средами, называется venv (docs.python.org/3/library/venv.html#module-venv). Он обычно будет установлен большинством новых версий Python, которые вам доступны. Если вы имеете разные версии Python в вашей системы, то можете выбрать конкретную версию Python, выполнив команду python3 или какую версию захотите.

Чтобы создать виртуальную среду, выберите каталог для ее размещения и запустите модуль venv как скрипт с адресом директории:

python3 -m venv tutorial-env
Это создаст каталог tutorial-env, если он не существует, и также создаст директории внутри него, содержащие копию интерпретатора Python, стандартную библиотеку и различные вспомогательные файлы.

Создав виртуальную среду, вы можете ее активировать.

В Windows командой:

tutorial-env\Scripts\activate.bat
В Unix или MacOS:

source tutorial-env/bin/activate
(Этот скрипт записан для оболочки bash. Если вы используете оболочки csh или fish, вместо этого вам следует использовать альтернативные скрипты activate.csh и activate.fish.)

Активация виртуального окружения изменит приглашение оболочки, показывая, что вы используете виртуальную среду, и изменит среду так, что запуск python даст вам конкретную версию и установку Python. Например:

$ source ~/envs/tutorial-env/bin/activate
(tutorial-env) $ python
Python 3.5.1 (default, May  6 2016, 10:59:36)
  ...
>>> import sys
>>> sys.path
['', '/usr/local/lib/python35.zip', ...,
'~/envs/tutorial-env/lib/python3.5/site-packages']
>>>
12.3. Управление пакетами с помощью pip
Вы можете устанавливать, обновлять и удалять пакеты, используя программу под названием pip. По умолчанию pip будет устанавливать пакеты из Индекса пакетов Python. Вы можете просматривать Python Packege Index с помощью браузера или можете использовать ограниченную функцию поиска pip:

(tutorial-env) $ pip search astronomy
skyfield               - Elegant astronomy for Python
gary                   - Galactic astronomy and gravitational dynamics.
novas                  - The United States Naval Observatory NOVAS astronomy library
astroobs               - Provides astronomy ephemeris to plan telescope observations
PyAstronomy            - A collection of astronomy related tools for Python.
...
У pip есть ряд подкоманд: "search", "install", "freeze" и др. (Проконсультируйтесь с руководством Installing Python Modules (docs.python.org/3/installing/index.html#installing-index) для полной документации для pip.)

Вы можете установить последнюю версию пакета, указав его имя:

(tutorial-env) $ pip install novas
Collecting novas
  Downloading novas-3.1.1.3.tar.gz (136kB)
Installing collected packages: novas
  Running setup.py install for novas
Successfully installed novas-3.1.1.3
Также вы можете установить конкретную версию пакета, задав имя пакета с последующим == и номером версии:

(tutorial-env) $ pip install requests==2.6.0
Collecting requests==2.6.0
  Using cached requests-2.6.0-py2.py3-none-any.whl
Installing collected packages: requests
Successfully installed requests-2.6.0
Если вы перезапустите эту команду, pip заметит, что требуемая версия уже установлена и ничего не сделает. Вы можете указать другой номер версии, чтобы получить эту версию, или можете запустить pip install --upgrade для обновления пакета до последней версии:

(tutorial-env) $ pip install --upgrade requests
Collecting requests
Installing collected packages: requests
  Found existing installation: requests 2.6.0
    Uninstalling requests-2.6.0:
      Successfully uninstalled requests-2.6.0
Successfully installed requests-2.7.0
pip uninstall с последующим одним или более именами пакетов удалит пакеты из виртуального окружения.

pip show выведет информацию о конкретном пакете:

(tutorial-env) $ pip show requests
---
Metadata-Version: 2.0
Name: requests
Version: 2.7.0
Summary: Python HTTP for Humans.
Home-page: http://python-requests.org
Author: Kenneth Reitz
Author-email: me@kennethreitz.com
License: Apache 2.0
Location: /Users/akuchling/envs/tutorial-env/lib/python3.4/site-packages
Requires:
pip list выведет все пакеты, установленные в виртуальном окружении:

(tutorial-env) $ pip list
novas (3.1.1.3)
numpy (1.9.2)
pip (7.0.3)
requests (2.7.0)
setuptools (16.0)
pip freeze произведет похожий список установленных пакетов, но вывод использует формат, который ожидает pip install. Общее соглашение состоит в том, чтобы поместить этот список в файл requirements.txt:

(tutorial-env) $ pip freeze > requirements.txt
(tutorial-env) $ cat requirements.txt
novas==3.1.1.3
numpy==1.9.2
requests==2.7.0
Затем файл requirements.txt может быть привязан к управлению версиями и отправлен как часть приложения. Потом пользователи могут установить все необходимые пакеты с помощью install -r.

(tutorial-env) $ pip install -r requirements.txt
Collecting novas==3.1.1.3 (from -r requirements.txt (line 1))
  ...
Collecting numpy==1.9.2 (from -r requirements.txt (line 2))
  ...
Collecting requests==2.7.0 (from -r requirements.txt (line 3))
  ...
Installing collected packages: novas, numpy, requests
  Running setup.py install for novas
Successfully installed novas-3.1.1.3 numpy-1.9.2 requests-2.7.0
У pip есть больше опций. Проконсультируйтесь с руководством Установка модулей Python для полной документации для pip. Если вы написали пакет и хотите сделать его доступным на Python Packege Index, проконсультируйтесь с руководством Distributing Python Modules (docs.python.org/3/distributing/index.html#distributing-index).

13. Что теперь?
Чтение этого учебника вероятно усилило ваш интерес к Python - вы должно быть в нетерпении применить его для решения ваших практических задач. Куда следует обратиться, чтобы узнать больше?

Данный учебник лишь часть набора документации Python. Некоторая другая документация:

Стандартная библиотека Python:
Вам следует сделать обзор этого руководства, которое дает полное (хотя краткое) упоминание материала о типах, функциях и модулях стандартной библиотеки. Стандартная поставка Python включает множество дополнительного кода. Там есть модули для чтения почтовых ящиков Unix, извлечения документов через HTTP, генерации случайных чисел, анализа опций командной строки, написания CGI-программ, сжатия данных и многих других задач. Беглое прочтение справочной библиотеки даст вам понимание того, что доступно.
Installing Python Modules (docs.python.org/3/installing/index.html#installing-index) объясняет, как установить дополнительные модули, написанные другими пользователями Python.
Справочник по языку Python: Детальное объяснение синтаксиса и семантики Python. Это тяжелое чтение, но полезное как полное руководство по самому языку.
Дополнительные ресурсы по Python:

https://www.python.org: Главный веб-сайт о Python. Содержит код, документацию, указатели на связанные с Python страницы по всему Web. Этот сайт имеет зеркала в различных частях мира, таких как Европа, Япония и Австралия; зеркало может быть быстрее, чем главный сайт, это зависит от вашего географического положения.
https://docs.python.org: Быстрый доступ к документации Python.
https://pypi.python.org/pypi: Индекс пакетов Python, ранее также названный Cheese Shop, представляет собой индекс созданных пользователями модулей, которые доступны для загрузки. Если вы когда-нибудь создадите код, вы можете зарегистрировать его здесь, так что другие пользователи найдут его.
https://code.activestate.com/recipes/langs/python/: Поваренная книга Python представляет собой большую коллекцию примеров кода, больше модулей и полезных скриптов. Особенно выдающийся вклад собирается в книге также названной Python Cookbook (O’Reilly & Associates, ISBN 0-596-00797-3.)
http://www.pyvideo.org собирает ссылки на связанное с Python видео конференций и встреч групп пользователей.
https://scipy.org: Проект научного Питона включает модули для быстрых множественных вычислений и манипуляций плюс множество пакетов для таких вещей как линейная алгебра, преобразования Фурье, нелинейные вычислители, раздачи случайных чисел, статистический анализ и тому подобное.
Связанные с Python вопросы и отчеты по проблемам вы можете отправлять новостной группе comp.lang.python или послать их списком рассылки python-list@python.org. Новостная группа и список рассылки - шлюз. Поэтому сообщения будут автоматически перенаправлены другим. Приходят сотни сообщений в день, спрашивающих (и отвечающих) вопросов, предложений новых возможностей и анонса новых модулей. Архивы списка рассылки доступны на https://mail.python.org/pipermail/.

Прежде чем писать сообщение, проверьте список Часто Спрашиваемых Вопросов (docs.python.org/3/faq/index.html#faq-index) (также называемый FAQ). Он отвечает на многие вопросы, которые приходят снова и снова. Они могут уже содержать решение вашей проблемы.

14. Редактирование интерактивного ввода и подстановка истории
Некоторые версии интерпретатора Python поддерживают редактирование текущей строки ввода и замещение истории, что похоже на возможности, обнаруживаемые в оболочках Korn и GNU Bash. Это реализуется с помощью библиотеки GNU Readline, которая поддерживает различные стили редактирования. Эта библиотека имеет ее собственную документацию, которую мы не будем здесь дублировать.

14.1. Завершение по табуляции и редактирование истории
Завершение имен переменной и модуля автоматически доступно (docs.python.org/3/library/site.html#rlcompleter-config), исходя из начальной идеи интерпретатора, так что клавиша Tab запускает функцию завершения. Она просматривает операторы имен, текущие локальные переменные и доступные имена модулей. Для выражений с точкой, таких как string.a, она будет оценивать выражение до финальной точки '.' и затем предлагать завершения из атрибутов результирующего объекта. Заметьте, что это может выполнить определенный приложением код, если объект с методом __getattr__() (docs.python.org/3/reference/datamodel.html#object.__getattr__) является частью выражения. По умолчанию конфигурация также сохраняет вашу историю в файле с именем .python_history в вашей пользовательской директории. История будет доступна снова во время следующей интерактивной сессии интерпретатора.

14.2. Альтернативы интерактивного интерпретатора
Эта возможность есть огромный шаг вперед по-сравнению с ранними версиями интерпретатора; однако, некоторые желания оставлены: было бы прекрасно, если бы правильный отступ был предложен на следующих строках (парсер знает, требуется ли отступ). Механизм завершения мог бы использовать символьную таблицу интерпретатора. Команда проверки (или даже предложения) согласования скобок, кавычек и др. могла бы быть также полезной.

Один альтернативный расширенный интерактивный интерпретатор, который существует давно, есть IPython, включающий tab-завершение, выявление объектов и продвинутое управление историей. Также он может быть тщательно настроен и встроен в другие приложения. Другое похожее расширенное интерактивное окружение - это bpython.

15. Арифметика чисел с плавающей точкой: проблемы и ограничения
Ошибки представления
Числа с плавающей точкой представлены в компьютерном железе как дроби с основанием 2 (двоичная система счисления). Например, десятичная дробь

0.125
имеет значение 1/10 + 2/100 + 5/1000, и таким же образом двоичная дробь

0.001
имеет значение 0/2 + 0/4 + 1/8. Эти две дроби имеют одинаковые значения, отличаются только тем, что первая записана в дробной нотации по основанию 10, а вторая по основанию 2.

К сожалению, большинство десятичных дробей не могут быть точно представлены в двоичной записи. Следствием этого является то, что в основном десятичные дробные числа вы вводите только приближенными к двоичным, которые и сохраняются в компьютере.

Проблему легче понять сначала в десятичной системе счисления. Рассмотрим дробь 1/3. Вы можете приблизительно представить ее десятичной дробью:

0.3
или лучше

0.33
еще лучше

0.333
и так далее. Независимо от того, как много цифр вы запишите, результат никогда не будет точно 1/3, но будет все более лучшим приближением к 1/3.

Точно также не важно, как много цифр с основанием 2 вы будете использовать, десятичное значение 0.1 не может быть представлено точно в двоичной записи дроби. По основанию 2 дробь 1/10 - это бесконечно повторяющаяся дробь

0.0001100110011001100110011001100110011001100110011...
Остановка при любом конечном количестве бит приведет к получению приближения. Сегодня на большинстве компьютеров вещественные числа приближены с использованием бинарных дробей, чей числитель использует первые 53 бита, начиная с самого значимого  бита, и чей знаменатель является степенью двойки. В случае 1/10, бинарная дробь есть 3602879701896397 / 2 ** 55, которая близка, но не точно равна действительному значению 1/10.

Многие пользователи не осведомлены о приближении из-за способа отображения значений. Python выводит только десятичное приближение настоящего десятичного значения от двоичного приближения, хранимого на компьютере. На большинстве машин, если бы Python выводил настоящее десятичное значение двоичного приближения 0.1, то тогда бы отобразилось следующее

>>> 0.1
0.1000000000000000055511151231257827021181583404541015625
Здесь больше цифр, чем большинство людей найдут полезными, поэтому, вместо этого, Python позволяет управлять количеством цифр, отображая округленное значение

>>> 1 / 10
0.1
Просто помните, даже если отображенный результат выглядит как точное значение 1/10, на самом деле хранимое значение - самое близкое представление бинарной дроби.

Примечательно, что есть множество различных десятичных чисел, которые разделяют одинаковую самую близкую приблизительную двоичную дробь. Например, число  0.1 и 0.10000000000000001 и 0.1000000000000000055511151231257827021181583404541015625 являются все приближенными к 3602879701896397 / 2 ** 55. Поскольку все эти десятичные значения разделяют одно и тоже приближение, любой один из них мог бы быть отображен при сохранении инварианта eval(repr(x)) == x.

Исторически, приглашение Python и встроенная функция repr() выбрали бы одну из 17 значащих цифр, 0.10000000000000001. Начиная с Python 3.1, на большинстве систем теперь Python способен выбрать самую короткую из них и просто отобразить 0.1.

Заметьте, что это очень естественно для двоичного вещественного числа: это не баг в Python и также не баг в вашем коде. Вы увидите то же самое во всех языках, которые поддерживают арифметику с плавающей точкой вашего железа (хотя некоторые языки могут не отображать различия по-умолчанию, или во всех режимах вывода).

Для более приятного вывода вы можете пожелать использовать строковое форматирование для создания ограниченного числа значащих цифр:

>>> format(math.pi, '.12g')  # задает 12 значащих цифр
'3.14159265359'

>>> format(math.pi, '.2f')   # задает 2 цифры после запятой
'3.14'

>>> repr(math.pi)
'3.141592653589793'
Важно осознавать, что в реальном понимании это иллюзия: вы просто округляете вывод действительного машинного значения.

Одна иллюзия может порождать другую. Например, поскольку 0.1 не точно 1/10, суммирование трех значений 0.1 может не произвести точно 0.3, либо:

>>> .1 + .1 + .1 == .3
False
Также, поскольку 0.1 не может приблизиться к точному значению 1/10 и 0.3 не может приблизиться к точной величине 3/10, то предварительное округление с помощью функции round() не может помочь:

>>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
False
Хотя цифры не могут быть приближены к их предназначенным точным значениям, функция round() может быть полезна для пост-округления, так что результаты с неточными значениями становятся сопоставимы друг с другом:

>>> round(.1 + .1 + .1, 10) == round(.3, 10)
True
Двоичная арифметика чисел с плавающей точкой содержит много сюрпризов подобных этому. Проблема с "0.1" объяснена в точных деталях ниже, в разделе "Представление ошибок". См. The Perils of Floating Point, где более полный отчет о других обычных сюрпризах.

Как говорится ближе к концу: "нет легких ответов". Но спокойно, не будьте чрезмерно осторожны насчет вещественных чисел! Ошибки в операциях с вещественными числами в Python унаследованы от чисел с плавающей точкой железа, и на большинстве машин составляет не более 1 части в 2**53 за операцию. Это более чем адекватно для большинства задач, но вам нужно иметь в виду, что это не десятичная арифметика и что каждая вещественная операция может претерпевать новую ошибку округления.

Хотя патологические случаи действительно существуют, в повседневности, используя арифметику чисел с плавающей точкой, в конце вы будете видеть тот результат, который ожидали, если вы просто округляете финальные результаты к определенному количеству десятичных чисел. str() обычно достаточно, а для более тонкого контроля см. str.format() спецификаторы формата метода в Format String Syntax (docs.python.org/3/library/string.html#formatstrings).

Для случаев, которые требуют точного десятичного представления, попробуйте использовать модуль decimal (docs.python.org/3/library/decimal.html#module-decimal), который реализует десятичную арифметику, подходящую для бухгалтерских приложений и высокоточных приложений.

Другая форма точной арифметики поддерживается модулем fractions (docs.python.org/3/library/fractions.html#module-fractions), который реализует арифметику, основанную на рациональных числах (так числа подобные 1/3 могут быть представлены точно).

Если вы сильно используете операции с плавающей точкой, вам следует взглянуть на пакет Numerical Python и множество других пакетов для математических и статистических операций, предоставляемых проектом SciPy. См. <scipy.org>.

Python предоставляет инструменты, которые могут помочь в тех редких случаях, когда вы действительно хотите знать точное значение вещественного числа. Метод float.as_integer_ratio() выражает значение вещественного числа как дробь:

>>> x = 3.14159
>>> x.as_integer_ratio()
(3537115888337719, 1125899906842624)
Поскольку это соотношение точное, оно может быть использовано, чтобы без потерь воссоздать первоначальное значение:

>>> x == 3537115888337719 / 1125899906842624
True
Метод float.hex() выражает вещественное число в шестнадцатеричной (с основанием 16) системе счисления, снова давая точное значение, хранимое вашим компьютером:

>>> x == float.fromhex('0x1.921f9f01b866ep+1')
True
Поскольку представление точно, это полезно для надежного переноса значений через различные версии Python (платформенная независимость) и обмена данными с другими языками, которые поддерживают такой же формат (такие как Java и C99).

Другой полезный инструмент - функция math.fsum() (docs.python.org/3/library/math.html#math.fsum), которая помогает смягчить потерю точности во время суммирования. Она отслеживает "потерянные цифры" как значения, добавляемые к текущему итогу. Это может повлиять на общую точность, так что ошибки не накапливались до такой степени, чтобы влиять на итоговое значение:

>>> sum([0.1] * 10) == 1.0
False
>>> math.fsum([0.1] * 10) == 1.0
True
15.1. Ошибки представления
Этот раздел разъясняет "0.1" пример в деталях и показывает, как вы можете представить точный анализ таких случаев. Предполагается базовое знакомство с двоичным представлением чисел с плавающей точкой.

Ошибки представления относятся к тому факту, что некоторые (большинство, на самом деле) десятичные дроби не могут быть представлены точно как двоичные (с основанием 2) дроби. Это главная причина, почему Python (или Perl, C, C++, Java, Fortran и многие другие) обычно не будут отображать точное десятичное число, которое вы ожидаете.

Почему это так? 1/10 нельзя точно представить в виде двоичной дроби. Почти все компьютеры сегодня (ноябрь 2000) используют IEEE-754 арифметику вещественных чисел, и почти все платформы отображают вещественные числа Python в IEEE-754 "двойной точности". Двойные 754 содержат 53 бита точности, так при вводе компьютер стремится преобразовать 0,1 в ближайшую дробь, это может иметь вид J/2** N, где J - целое число, содержащее ровно 53 бита. Перезаписывая

1 / 10 ~= J / (2**N)
как

J ~= 2**N / 10
и вспоминая, что J имело точно 53 бита (является >= 2**52, но < 2**53), наилучшее значение для N - это 56:

>>> 2**52 <=  2**56 // 10  < 2**53
True
То есть 56 - единственное значение для N, которое оставляет J с точно 53 битами. Наилучшее возможное значение для J тогда есть округленное частное:

>>> q, r = divmod(2**56, 10)
>>> r
6
Поскольку остаток больше, чем половина от 10, наилучшее приближение получается путем округления в большую сторону:

>>> q+1
7205759403792794
Поэтому лучшее возможное приближение к 1/10 в двойной 754 точности:

7205759403792794 / 2 ** 56
Деление числителя и знаменателя на два сокращает дробь к:

3602879701896397 / 2 ** 55
Заметьте, что поскольку мы округлили в большую сторону, это в действительности немного больше, чем 1/10; если мы бы так не округляли, частное было бы немного меньше, чем 1/10. Но в любом случае оно не может быть точно равно 1/10!

Так компьютер никогда не "видит" 1/10: что он видит - это точная дробь, данная выше, наилучшее 754 двойное приближение, которое можно получить:

>>> 0.1 * 2 ** 55
3602879701896397.0
Если мы умножим ту дробь на 10**55, мы можем увидеть значение до 55 десятичных цифр:

>>> 3602879701896397 * 10 ** 55 // 2 ** 55
1000000000000000055511151231257827021181583404541015625
обозначаемое, что точное число, хранимое в компьютере, приравнено к десятичному значению 0.1000000000000000055511151231257827021181583404541015625. Вместо отображения полного десятичного значения, многие языки (включая более старые версии Python) округляют результат до 17 значащих цифр:

>>> format(0.1, '.17f')
'0.10000000000000001'
Модули fractions (docs.python.org/3/library/fractions.html#module-fractions) и decimal (docs.python.org/3/library/decimal.html#module-decimal) легко выполняют эти вычисления:

>>> from decimal import Decimal
>>> from fractions import Fraction

>>> Fraction.from_float(0.1)
Fraction(3602879701896397, 36028797018963968)

>>> (0.1).as_integer_ratio()
(3602879701896397, 36028797018963968)

>>> Decimal.from_float(0.1)
Decimal('0.1000000000000000055511151231257827021181583404541015625')

>>> format(Decimal.from_float(0.1), '.17')
'0.10000000000000001'

16. Дополнение
16.1. Интерактивный режим
16.1.1. Обработка ошибок
Когда происходит ошибка, интерпретатор выводит сообщение о ней и трассировку стека. В интерактивном режиме он затем возвращается к первичному приглашению; когда ввод поступает из файла, он выходит с ненулевым выходным статусом после печати трассировки стека. (Исключения, обработанные разделом except (docs.python.org/3/reference/compound_stmts.html#except)  оператора try (docs.python.org/3/reference/compound_stmts.html#try), не являются ошибками в этом случае.) Некоторые ошибки безусловно фатальны и являются причиной ненулевого выхода; это применяется для внутренних несоответствий и ряда случаев нехватки памяти. Все сообщения об ошибках записываются в стандартный поток ошибок; в обычный вывод выполненных команд записывается стандартный вывод.

Ввод прерывающего символа (обычно Control-C или Delete) в первичном или вторичном приглашении отменяет ввод и возвращает к первичному приглашению. [1] Ввод прерывания в то время как команда выполняется возбуждает исключение KeyboardInterrupt (docs.python.org/3/library/exceptions.html#KeyboardInterrupt), которое может быть обработано оператором try.

16.1.2. Исполняемые скрипты Python
На BSD-подобных Unix-системах скрипты Python можно сделать сразу выполняемыми подобно shell-скриптам, введя строку

#!/usr/bin/env python3.5
(предполагая, что интерпретатор есть на PATH пользователя) в начале скрипта и задав файлу исполняемый режим. #! должны быть первыми двумя символами файла. На некоторых платформах эта первая строка должна заканчиваться окончанием строки в Unix-стиле ('\n'), не окончанием строки Windows ('\r\n'). Заметьте, что символ хэша, '#', используется для обозначения начала комментария в Python.

Скрипту может быть передан исполняемый режим, или разрешения, с помощью команды chmod.

$ chmod +x myscript.py
В системах Windows нет понятия "исполняемый режим". Установщик Python автоматически ассоциирует файлы .py с python.exe, так что двойной клик на Python-файле запустит его как скрипт. Расширение может быть .pyw, в этом случае окно консоли, которое обычно появляется, подавляется.

16.1.3. Интерактивный загрузочный файл
Когда вы используете Python интерактивно, часто удобно иметь некоторые стандартные команды, выполняемые каждый раз при запуске интерпретатора. Вы можете сделать это, связав переменную окружения PYTHONSTARTUP (docs.python.org/3/using/cmdline.html#envvar-PYTHONSTARTUP) с именем файла, содержащем загрузочные команды. Это похоже на возможности .profile оболочек Unix.

Этот файл читается только в интерактивных сессиях, не когда Python читает команды из скрипта и не когда /dev/tty задан как явный источник команд (который иначе ведет себя как интерактивная сессия). Он выполняется в том же пространстве имен, котором выполняются интерактивные команды, так что объекты, которые он определяет или импортирует, могут быть использованы без квалификации в интерактивном сеансе. Вы также можете изменить в этом файле приглашения sys.ps1 и sys.ps2.

Если вы хотите прочитать дополнительный загрузочный файл из текущей директории, то можете запрограммировать это в глобальном загрузочном файле, используя код наподобие if os.path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').read()). Если вы хотите использовать загрузочный файл в скрипте, то должны сделать это явно в скрипте:

import os
filename = os.environ.get('PYTHONSTARTUP')
if filename and os.path.isfile(filename):
    with open(filename) as fobj:
        startup_file = fobj.read()
    exec(startup_file)
16.1.4. Настройка модулей
Python предоставляет два хука, чтобы позволить вам настроить это: sitecustomize и usercustomize. Чтобы увидеть, как это работает, вам сначала надо найти местонахождение вашей пользовательской директории site-пакетов. Запустите Python и выполните этот код:

>>> import site
>>> site.getusersitepackages()
'/home/user/.local/lib/python3.5/site-packages'
Теперь вы можете создать файл под именем usercustomize.py в той директории и положить в нее что-нибудь, что вы хотите. Оно будет влиять на каждый вызов Python, если только он не запущен с опцией -s, чтобы отключить автоматический импорт.

sitecustomize работает похожим образом, но обычно создается администратором компьютера в глобальной директории site-пакетов и импортируется перед usercustomize. См. документацию по модулю site (docs.python.org/3/library/site.html#module-site) для более полной информации.

Примечания

[1] Проблема с пакетом GNU Readline может помешать этому.

