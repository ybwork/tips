/*
	Создание проекта.

	file -> new -> new project

	Задаём название и выбираем empty activity. (всё остальное по умолчанию)
*/

/*
	Структура.

	app > java > com.example.nameapp > MainActivity.java - точка входа приложения

	app > res > layout > activity_main.xml - xml вид activity

	app > manifests > AndroidManifest.xml - писывает основные характеристики приложения (файл конфигурации)

	Gradle Scripts > build.gradle - инструменты Gradle собирают и создают ваше приложение (один для проекта и по одному для модуля «приложения)
*/

/*
	Настройка рабочего окружения.

	Открыть app > res > layout > activity_main.xml

	Выбрать View > Tool Windows > Project

	Выбрать Design в нижней части панели.

	Выбрать bluprint в панели чуть ниже вкладок с открытыми файлами.

	Включить Turn On Autoconnect (подкова возле глаза).

	Выставить Default Margins в 16 (справа от подковы).

	Выбрать модель телефона для разработки (выше Default Margins) 

	Component Three -> ConstraitLayout (нажать правой кнопкой мыши) -> Constrait Layout -> Infer Contraints или выбрать Turn on AutoConnect
*/

/*
	Позиционирование.

	widgets (View objects) - компоненты пользовательского интерфейса (кнопки, чекбоксы).

	layouts (ViewGroup objects) - невидимые контейнеры, они определяют, как их дочерние представления располагаются на экране.

	Component Tree - окно в программе, которое показывает иерархию представлений макета.

	ConstraintLayout - общий контейнер, который находится внутри окна Component Tree. В нём могут лежать другие контейнер/контейнеры (определение придуманное мной на основе описанного в документации). Например выставим ConstraintLayout 16dp. Внутри этого контейнера лежит 2 других контейнера (контейнер а и контейнер б). Теперь контейнер а будет отсупать от верха на 16dp и от ConstraintLayout слева на 16dp, в свою очеред контейнер б будет отсупать от контейнера а на 16dp и от верха на 16dp.

	В меню pallete, которое ниже вкладок с открытыми файлами можно выбрать нужный виджет (представление).

	При клике на виджет вокру него появляется рамка с кругляшками по периметру. Нажимаем на кругляшок и тянем к нужной стороне, должна появиться стрелка с хвостом. Когда притянули куда нужно, отпускаем - установка якоря относительно ConstraintLayout.

	При клике на виджет ниже него появляются 2 иконки. Нажимаем на правую и видим в центре виджета появилась полоска. Зажимаем правой кнопкой полоску и тянем к нужному элементу, должна появиться стрелка с хвостом. Когда притянули куда нужно, отпускаем - горизонтальное выравнивание.

	Выбрали один виджет, зажали Shift и выбрали остальные, затем нажали правую кнопку мыши и выбрали center horizontaly. (выравнивание по горизонтали)

	Для редактирование отступов используем панель справа, должна выезжать при нажатии на виджет.

	Чтобы поместить один виджет по центру нужно взять его и перетащить к верхнему краю
*/

/*
	Работа с текстом.

	app > res > values > strings.xml - файл для с текстом для всех пользовательских представлений приложения.

	В правом углу окна нажали open editor, во вкладках файла открылось Translations Editor.
	
	Найти и нажать зелёный плюс, откроется окно, где можно задать ключ и текст, а потом связать поле по ключу и у этого поля появиться заданный текст. (edit_message - ключ, Enter a messabe - текст, app/src/main/res - место хранения)

	Для привязки текста к полю нажимаем на нужное поле, справа должна открыться панель, если не открылась, нажать на вкладку properties. Затем находим нужное поле и нажимаем рядом с ним кнопку с тремя точками. В открывшемся окне выбираем нужный нам ключ теста.
*/

/*
	Запуск на эмуляторе.

	Установили и открыли genymotion.

	Нажали кнопку run.
*/

/*
	Работа с кодом.

	Если подсвечивает красным, ставим курсор на красный кусок кода и нажимаем alt + enter или красную лампочку.
*/

/*
	Работа с виджетами (представлениями).

	Для того чтобы повесить на виджет событие onClick, нужно открыть activity_main.xml, выбрать нужный виджет (например кнопку), найти в панели справа поле onClick и выбрать в селекте нужную функцию, которая отработает по клику. При этом функция должна иметь публичный доступ, возвращать занчение void, иметь единственный входной параметр View.
*/

/*
	Работа с activity.

	В левой панели на папке app кликаем правой кнопкой, выбираем new -> activity -> empty activity. В открывшемся окне задаём имя activity, например DisplayMessageActivity.

	Для передачи данных и связи одного activity с другим нужно использовать класс Intent. Он может переносить данные в виде ключ -> значение и это хорошая практика.

	Для создания стрелки назад в хэдере приложения нужно открыть app > manifests > AndroidManifest.xml и внутрь тега activity DisplayMessageActivity вставить код и добавить мета тэг. Всё вместе:
        <activity android:name=".DisplayMessageActivity"
            android:parentActivityName=".MainActivity">
            <meta-data
                android:name="android.support.PARENT_ACTIVITY"
                android:value=".MainActivity"/>
        </activity>
*/

/*
	Локализация.

	Хорошей практикой является сохранение файлов локализации отдельно от приложения.

	Локализация даёт нам дополнительное преимущество, если пользователь запустит приложение на телефоне с английской локалью, то он увидит текст на знакомом ему языке. Если приложение запустит русский пользователь, то он увидит текст на русском языке.

	Локализация создаётся в папке res.

	Щёлкаем правой кнопкой мыши на папке res и выбираем res > new > android resource directory. В диалоговом окне в левой части Available qualifiers: выбираем пункт Locale и переносим его в правую часть Chosen qualifiers: с помощью кнопки с двумя стрелками вправо. В появившейся третьей колонке выбираем нужные языки, например, русский. Вы увидите, что в поле Directory name автоматически появится нужное название папки.

	values-b+es - содержит строковые ресурсы для локалей с кодом языка

	Создаём русурсный файл (для каждого языка свой). values-b+es > new > name resource file > string.xml

	Добавлем в string.xml текст в зависимости от языка

	Открываем приложение в эмуляторе или на устройстве и получаем перевод в зависимости от выбраного языка на устройстве

	В Android 7.0 (API 24) пользователь может установить несколько локалей. В этом случае, если не будут найдены ресурсы для первой локали, то будут искаться ресурсы для второй локали.
*/

/*
	Работа с фрагментами.

	Объединить два отдельных экрана из смартфона в один экран на планшете. Это самый классический пример применения фрагмента.

	Сейчас существуют два класса Fragment: для новых устройств и для старых устройств. Названия методов и классов очень похожи, но не стоит смешивать в одном проекте два разных класса.

	Считайте, что фрагмент - это тот же компонент как Button, TextView или LinearLayout с дополнительными возможностями. Фрагмент, как и кнопку, нужно поместить на экран активности. Но фрагмент является модульным компонентом и один и тот же фрагмент можно встроить в две разные активности. С кнопкой такой номер не пройдёт. Для каждой активности вы должны создать свою отдельную кнопку, даже если их нельзя будет отличить друг от друга. Фрагменты существуют только в составе активностей.

	В составе активности есть специальный менеджер фрагментов, который может контролировать все классы фрагментов и управлять ими.

	Фрагмент может иметь свою разметку, а может обойтись без неё. Также у фрагмента есть свой жизненный цикл, во многом совпадающий с жизненным циклом активности. Пожалуй, это единственное сходство с активностью.

	фрагменты были придуманы для того, чтобы обеспечить быстрое написание приложения под разные типы экранов - для смартфонов и планшетов. Часто бывает так, что на смартфоне на первом экране находится список, а когда пользователь нажимает на отдельный элемент списка, то запускается отдельная активность. А на планшете можно уместить список и дополнительные данные на одном экране, как можно увидеть на нашем последнем примере с альбомной ориентацией.

	Есть два варианта использования фрагментов в приложении (при желании можно использовать сразу оба варианта). Первый вариант заключается в том, что вы в разметке сразу указываете фрагмент с помощью тега fragment, так же как и с другими компонентами. Второй вариант использует динамическое подключение фрагмента. Принцип следующий - в разметку помещается макет из группы ViewGroup, который становится контейнером для фрагмента. Обычно, для этой цели используют FrameLayout, но это не обязательное условие. И в нужный момент фрагмент замещает контейнер и становится частью разметки.

	Фрагмент, как и активность, состоит из разметки и класса.

	v4 appcompat - библиотека для Android начиная с версии 1.6 (класс activity должен расширять AppCompatActivity)

	v7 appcompat - библиотека для Android начиная с версии 2.1

	Создание файла фрагмента. Правой кнопкой мыши на папке res/layout > new > layout resource file или правой кнопкой мыши на папке res/layout > new > fragment

	Создание класса фрагмента. new > java class

	В панели Palette находим в разделе Layout элемент <fragment>. Перетащив сам его на активити, мы вызовем диалоговое окно, в котором нужно найти свой созданный фрагмент и выбрать его. Если не получилось, то пишем код вручную.

	Поговорим о важном моменте. Вы можете установить связь между двумя фрагментами напрямую, чтобы при нажатии кнопки в первом фрагменте менялось содержимое во втором фрагменте. Но это неправильный подход, так как теряется смысл модульности фрагментов. Фрагменты ничего не должны знать о существовании друг друга. Любой фрагмент существует только в активности и только активность через свой специальный менеджер фрагментов должна управлять ими. А сами фрагменты должны реализовать необходимые интерфейсы, которые активность будет использовать в своих целях.

	Класс FragmentManager предоставляет методы, позволяющие добавлять, удалять и заменять фрагменты на активность во время выполнения. Таким образом можно добавить фрагмент к активности во время выполнения операции.

	Если активити позволяет удалять или изменять фрагмент, то он должен добавляться во время действия метода onCreate()
*/

/*
	Работа с другим приложением.

	Одна из наиболее важных возможностей системы Android – способность приложений направлять пользователя в другое приложение в зависимости от желаемого действия. Например, если ваше приложение содержит адрес компании, который нужно показать на карте, вам не нужно встраивать в приложение операцию вывода карты. Вместо этого можно создать запрос на просмотр адреса с помощью Intent.

	Объекты Intent нужно использовать для навигации между операциями в собственном приложении. Обычно для этого используются явные объекты Intent. Однако если вы хотите, чтобы действие (например просмотр карты) выполнялось отдельным приложением, следует использовать неявный объект Intent.

	Неявные объекты Intent устанавливают запуск определённого действия. Действие указывает задачу, которую вы хотите выполнить, например просмотр, правка, отправка или получение чего-либо.

	Бывает так, что выполняемое действие может быть обработано несколькими приложениями, и пользователь каждый раз может использовать разные приложения — например, действие "Поделиться", для которого пользователи могут использовать разные приложения, — и в этом случае ваше приложение должно отображать диалоговое окно выбора приложения. В диалоговом окне выбора приложения пользователь должен при каждом запуске выбирать, какое приложение использовать для действия.

	В результате отобразится диалоговое окно со списком приложений, которые могут отреагировать на объект Intent, переданный методу createChooser()

	Запуск другой операции не обязательно должен быть односторонним действием. Вы можете запустить другую операцию и получить от нее результат. Для получения результата нужно вызвать метод startActivityForResult() вместо startActivity(). Например, ваше приложение может запустить приложение для камеры и получить в качестве результата фотографию.

	Чтобы разрешить другим приложениям запускать ваши операции, вам нужно добавить в ваш файл манифеста элемент <intent-filter> для соответствующего элемента <activity>.
*/

/*
	Работа с permission (разрешениями).

	Если приложение должно использовать ресурсы или информацию вне своей песочницы, приложение должно запросить соответствующее разрешение. Например, если приложение должно получить доступ к Интернету, использовать камеру устройства или включить или отключить Wi-Fi, приложение нуждается в соответствующем разрешении.

	В зависимости от того, насколько чувствительным является разрешение, система может предоставить разрешение автоматически. Например, если ваше приложение запрашивает разрешение на включение фонарика устройства, система автоматически предоставляет это разрешение.

	В зависимости от версии платформы пользователь предоставляет разрешение либо при установке приложения, либо во время запуска приложения.

	Чтобы сказать android о том, что моему приложению требуется разрешение нужно в файле manifest.xml (app > manifests > AndroidManifest.xml) Пример:

		<manifest xmlns:android="http://schemas.android.com/apk/res/android"
	        package="com.example.snazzyapp">

	    	<uses-permission android:name="android.permission.SEND_SMS"/>

		</manifest>

	Если вашему приложению требуется опасное разрешение, вы должны проверить, имеете ли вы это разрешение каждый раз, когда выполняете операцию, требующую этого разрешения. Пользователь всегда может отменить разрешение, поэтому, даже если приложение вчера использовало камеру, оно не может считать, что оно все еще имеет это разрешение сегодня.

	Если приложение имеет разрешение возвращается PackageManager.PERMISSION_GRANTED, и приложение может продолжить операцию. Если нет, метод возвращает PERMISSION_DENIED.

	Если разрешение опасно, то для его активации нужно спросить пользователя, готов он предоставить его или нет.

	Если мы запрашиваем у пользователя сильно опасные разрешения (например контакты) или пользователь отклонил разрешение ранее, то нужно показывать ему объеяснения зачем нам нужны эти данные.

	На мой взгляд лучше запрашивать все разрешения перед установкой и больше не беспокоить пользователю по этому поводу. При этом если он ограничил какое то разрешение, то пожно перед выполнением действия, где это разрешения необходимо спросить его у пользователя снова.

	Довольно часто ваше приложение может избежать запроса разрешения, используя вместо этого намерение. Если функция не является основной частью функциональности вашего приложения, вам следует рассмотреть возможность передачи работы другому приложению.

	Обычный пользователь может не понимать, что фотография может содержать информацию о местоположении, и было бы озадачено, почему их приложение для фотосъемки хочет узнать местоположение. Таким образом, в этом случае приложение лучше сообщить пользователю об этой функции перед вызовом requestPermissions().
*/

/*
	Отладка через android monitor.

	android monitor > logcat

	Открываем файл build.gradle file и пишем туда:

		android {
		    buildTypes {
		        customDebugType {
		            debuggable true
		            ...
		        }
		    }
		}

	В коде пишем Log.d() 
*/