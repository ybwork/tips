<?php

/*
    Предисловие.

        - Мелочи важны

        - Профессионалы выделяют некоторое время на обдумывание и планироване проекта

        - Рассматривайте свой код, как красивое воплощение благородных усилий по проектированию, как процесса, а не конечной статической точки
*/

/*
    Глава 1. Чистый код.

    Более того, они - и все остальные участники группы - находятся под страшным давлением со стороны начальства. В спешке они работают все небрежнее, отчего производительность только продолжает падать.

    Но постойте! - скажете вы. Если я не сделаю то, что говорит мой начальник, меня уволят. Скорее всего нет. Обычно начальники хотят знать правду, даже если по их поведению этого не скажешь. Они могут страстно защищать график и требования, но это их работа. А ваша работа - так же страстно защищать код.

    Единственный способ выдержать график и работать быстро - постоянно поддерживать чистоту в коде.

    Суть в том, что чистый код уделяет пристальное внимание мелочам.

    Не язык делает программы простыми. Программа выглядит простой благодаря работе программиста.

    Когда вы в следующий раз напишите строку кода, вспомните, что вы - автор, и пишите для читателей, которые будут оценивать плоды вашей работы.

    Соотношение времени чтения и написания кода превышает 10:1, поэтому наш код должен легко читаться, даже если это затрудняет его написание.

    Хорошо написать код недостаточно. Нобходимо поддерживать чистоту кода с течением времени. "Оставь место стоянки чище, чем оно было до твоего прихода". Чистка не обязана быть глобальной. Можно присвоить более понятное имя переменной, разбить слишком большую функцию или устранить сложную цепочку if.
*/

/*
    Глава 2. Содержательные имена.

    Имена переменных должны передавать намерения программиста. Они должны отвечать на все главные вопросы. Например, что измеряется и в каких единицах - $days_since_creation (дни со времени создания)

    Не использовать слова со скрытыми значениями. Например $hp, aix и т.д.

    Остерегаться малозаметных различий в именах. Например XyzControllerHandlingOfString и XyzControllerStorageOfString

    Не создавать имена, которые не несут полезной иформации. Например Product, ProductInfo, ProductData. В данном примере Info и Data не несут полезной информации.

    Проблема возникает тогда, когда вы называете переменную theZork, потому что в программе уже есть другая переменная с именем zork. Пример:

        getActiveAccount()
        getActiveAccounts()
        getActiveAccountInfo()

    Как участвующему в проекте программисту понять, какую из этих функций вызывать в конкретном случае? Поэтому записывайте так, чтобы читатель кода понимал различия.

    Используйте удобопроизносимые имена. Сравним два имени:

        - private $genymdns;

        - private $generationTimestamp;

    Второе имена можно легко произнести и сразу понять что лежит в данной переменной.

    Выбирайте имена удобные для поиска. Для лёгкого поиска не желательно использовать в названии переменной числа.

    Избегайте схем кодирования имён. (например IProduct, то есть интерфейс продукта)

    Префиксы стали ненужны.

    При создании файлов интерфейска и реализации Роберт предпочитает при необходимости, кодировать реализацию Shop (интерфейс) - ShopImp (реализация), нежели интерфейс IShop (интерфейс) - Shop (реализация). Проверить возможность создания и работы двух файлов с одинаковыми названиями.

    Имена классов должны представлять из себя существительные и их комбинации, если это необходимо. Например AddressParser, Product и т.д.

    Имена методов должны быть глаголами или глагольными сочетаниями. Например: getName, save и т.д.

    Избегайте остроумия и сленга в именовании.

    Выберите одно слово для каждой концепции. Например если в разных классах есть методы fetch, get, retrieve, которые обозначают одно и то же - получать. Соответственно это несёт путаницу, поэтому выбираем одно название метода для получения чего-либо и используем его везде. При этом не следует делать это везде и бездумно. Например мы создаём новый класс, где есть фунция, которая добавляет один элемент в коллекцию. Если подумать, то данная функция не создаёт, а добавляет, поэтому её можно назвать append.

    Короткие имена лучше длинных, если только их смысл понятен читателю.
*/

/*
    Глава 3. Функции.

    Первое правило - функции должны быть компактными, второе правило - функции должны быть ещё компактней. "Мой практический опыт научил меня, что функции должны быть очень маленькими".

    "Однако каждая функция Кента занимала всего 3-4 строки". Этого можно достигнуть например с помощью вызова дополнительной функции в конструкциях if, while.

    Код в структурах if, while и т.д. желательно вынести в отдельную функцию и желательно чтобы в условии эта функция была одна.

    Функции не должны содержать ВЛОЖЕННЫХ друг в дурга структур типа if, while.

    Функция должна выполнять только одну операцию и ничего другого она делать не должна. Но как быть если в функции идёт проверка входного параметра, потом вызвается другая функция и происходит третье действие? Ответ такой: если функция выполняет только те действия, которые находятся на одном уровне под объявленной фунцией, то всё верно.

        Не на одном уровне абстракции:

            void sendRequest(Request request)
            {
                if (server->error() != Server::errorOk)
                {
                        // handle
                }

                if (request.userName.empty())
                {
                        // handle
                }

                // ещё 100 if-ов

                client.send(request, server);
            }

            В данном случае Server::errorOk и request.userName.empty() находятся на другом уровне абстракции нежели функция sendRequest(Request request)

        На одном уровне абстракции:

            void sendRequest(Request request)
            {
                if (!isServerReady())
                {
                        // handle
                }

                if (!isRequestValid(request))
                {
                        // handle
                }

                // больше нет if'ов

                client.send(request, server);
            }

            Всё что мы сделали это перенесли проверку методов Server::errorOk и request.userName.empty() в отдельные функции и таким образом мы вернули единую абстракцию.

    Функцию выполняющую только одну операцию, невозможно осмысленно разделить на секции. Под секциями здесь понимается разделение функции на такие операции, как (инициализирует, отбирает, объявляет и т.п.)

    Код должен читаться, как разссказ - сверху вниз. За каждой функции должна следовать функция следующей абстракции.

    Если функция выполняет только те действия, которые находятся на одном уровне под объявленным именем функции, то эта функция выполняет одну операцию.

    К сожаление без команд if и switch не всегда удаётся обойтись, поэтому здесь нам может помочь полиморфизм. Если команды if и switch используются в коде однократно, то их можно оставить. Но как всегда бывают и исключения.

    Не бойтесь использовать длинные имена, потому что длинное, содержательное имя лучше короткого.

    Оставьте из придуманных слов функции только те, которые чётко описывают назначение функции.

    Используйте содержательные имена, например SetupTeardownIncluder.

    Не бойтесь тратить время на выбор имени. Опробуйте несколько разных имён и посмотрите, как код читается с каждым из них.

    В идеальном случае кол-во аргументов функции равно нулю. Функция с тремя аргументами по возможности следует избегать. Аргументы плохи тем, что читающему код нужно постоянно помнить о подробностях. Под подробностями понимается аргумент функции. Так же аргументы создают проблемы при написании тестов, потому что нужно много вариантов чтобы оттестировать функцию.

    Передача логического значения в функцию - воистину ужасная привычка. То есть, когда при ложном агрументе выполняется одно, а при истинном, другое.

    Если функция должна принимать более двух или трёх агрументов стоит упаковать их в класс и передать - public function set_product(new Product(), $params)

    Функция что то должна делать или отвечать на какой то вопрос, но не одновременно!

    Либо функция возвращает информацию об объекте, либо изменяет его, но не одновременно!

    Использовать исключения вместо возвращения кодов ошибок
    Возвращение кода ошибки обычно подразуменвает наличие класса или функция в котором определяются все коды ошибок.

    Не повторяйтесь.

    Как научиться писать функции описанные в этой главе? - писать код, а потом его причёсывать.

    "Искусство прораммирования является и всегда было искусством языкового проектирования". Опытные программисты рассматривают систему, как историю, которую они должны рассказать, а не как программу, которую можно написать.
*/

/*
    Глава 4. Комментарии.

    "Не комментируйте плохой код - перепишите его". 

    Если вы оказались в ситуации, когда нужно написать комментарий, подумайте о возможности переписать код так, чтобы не пришлось оставлять комментарий.

    Комментарии - зло, потому что код изменяется и эволюционирует, при этом не всегда программист вспоминает о поддержке комментариев. В итоге они становятся устаревшими и дизенформируют других читателей кода.

    Чтобы объяснить намерение кодом, а не комментарием можно написать функцию.

    Но всё же есть полезные комментарии:

        - которые обычно помещают для описания работы модуля в общем

        - которые описывают функцию в общем и рассказывают о её аргументах

        - комментирование кусков из инородных модулей, изменить код которых нет возможности

        - предупреждение о последствиях (запускайте данный метод только для тестирования)

        - заметки на будущее или TODO комментарии (на данный момент не используется, но ситуация измениться при переходе к отладке)

        - усиление значения (вызов данной функции очень важен, потому что)

        - если идёт разработки api

    Если вы всё же решили написать комментарий, то потратьте на это время и сделайте самый лучший комментарий на сколько это возможно.

    Любой комментарий смысл которого приходится искать в других модулей, не несёт полезной информации.

    Не создавайте журнальных комментариев - это когда в начале модуля формируется лист из записей по каждому апдейту.

    Использовать функции или переменные вместо комментированя.

    Не использовать комментарии после фигурных скобок.

    Не включайте в комментарии исторические дискуссии.
*/

/*
    Глава 5. Форматирование.

    Если вы работаете в группе, то нужно разработать набор правил форматирования.

    Маленькие файлы обычно более понятны, чем большие.

    Имя файла должно быть простым, но содержательным.

    Каждая группа строк должна представлять собой законченную мысль и отделяться от другой группы пустой строкой.

    Концепции связанные друг с другом, должны находиться рядом друг с другом. Например внутри класса контроллера есть метод обрабатывающий роут и рядом с ним объявленны функции, которые он использует.

    Переменные следует объявлять, как можно ближе к месту использования.

    Функция, которая вызывает другую, должна находиться выше вызываемой.

    Строки по возможности должны быть короткими.

    Работая в группе нужно согласовать единый стиль форматирования и его должен придерживаться каждый программист. "Это были не правила, которые предпочитал лично я, это были правила выбранные группой. И я, как участник группы неуклонно соблюдал их"

    Не усложняйте код, допуская его оформление в разных стилях.   
*/

/*
    Глава 6. Объекты и структуры данных.

    Опытные программисты хорошо знают: представление о том, что все данные должны представляться в виде объектов - миф.

    Закон Деметры гласит: модуль не должен знать внутреннее устройство объектов с которыми он работает. Это означает, что метод не должен расскрывать свою внутреннюю структуру через методы доступа.
*/

/*
    Глава 7. Обработка ошибок.

    Обработка ошибок важна, но если она засоряет логику программы, значит она реализованна неверно.

    Используйте исключени вместо кодов ошибок, потому что если мы возвращаем код ошибки, то вызывающая сторона должна проверить ответ, а это ведёт к условным оператрам и загромождению кода, плюс можно забыть проверить ответ.

    Создавайте содержательные сообщения об ошибках и передавайте их со своими исключениями.

    Не возвращайте null, потому что это загромождает клиентский код условными операторами if. Если вы работаете с сторонним api и он возвращает null, то можно создать метод, который будет обрабатывать ответ api и вместо null выбрасывать исключение.

    Не передавать в функцию null.
*/

/*
    Глава 8. Границы.

    В этой главе идёт речь о внедрении чужого кода, например использование сторонней библиотеки. Для успешной работы этого кода его нужно проверить, автор предлагает учебные тесты. (beckTDD)

    Класс адаптер инкапсулировал взаимодействие с api.
*/

/*
    Глава 9. Модульные тесты.

    По требованиям методологии TDD модульный тест должен писаться до написания кода продукта. Но есть ещё 3 важных закона:

        1. Не пишите код продукта пока не напишите отказной модульный тест

        2. Не пишите модульный тест в объёме большем, чем необходимо для отказа

        3. Не пишите код продукта в объёме большем, чем необходимо для прохождения написанного для него теста

        При этом тесты пишутся вместе с кодом, но немного опережают его. То есть написали тест для данного куска, затем написали кусок. Потому ещё написали тест на следующий кусок и написали код для этого куска и т.д.

    Тесты на скорую руку равнозначны, если не хуже отсутствию тестов.

    Без тестов нельзя понять, влияет ли внесение изменений в одну часть программы на изменения в других?

    Тестовый код не менее важен, чем код продукта.

    В каждой тестовой функции должна тестироваться одна концепция

    Помимо этого тесты должны обладать следующими характеристиками:

        - должны выполняться быстро чтобы их хотелось запускать

        - не должны зависеть друг от друга

        - должны выдавать повторяемые результаты в любой среде

        - результатом теста должен быть логический признак, то есть прошёл тест или не прошёл
*/

/*
    Глава 10. Классы.

    По стандартам Java класс должен начинаться со списка переменных. Открытых переменных обычно нет.

    За списком переменных обычно следуют открытые функции. Если открытая функция использует вспомогательную функцию, то её делают закрытой и размещают сразу за основной.

    Если для тестов необходим доступ к приватному св-ву или методу, то их можно открыть, но всегда следует проектировать класс с поиска способа, сохраняющего приватность.

    Классы должны быть компактными.

    Использовать:

        Имя класса должно описывать его ответственности. Чтобы понять использует класс одну ответственность или нет нужно описать то, что он делает. Если описание больше 25 слов и в нём присутствуют слова: "и", "или", "если", "но", то указывает на то, что класс имеет много ответственностей.

    Система должна состоять из множества мелких классов, а не из большого числа больших. Каждый класс имеет одну ответственность и взаимодействует с другими классами для достижения нужной функциональности программы.

    Разбивайте большие классы и функции на более маленькие.

    Использовать (возможно и только в нужных ситуациях):

        Для каждого метода интерфейса используем отдельный класс

        abstract class Sql
        {
            public function sql(string $table_name, array table_columns);
            abstract public function generate();
        }

        class Insert extends Sql
        {
            code...
        }

    Классы должны быть открыты для расширений, но закрыты для модификации. В идеале новая функциональность должна реализовываться расширением системы, а не внесением изменений в уже существующий код.

    Классы системы должны зависеть от абстракций, а не от конкретных подробностей.
*/

/*
    Глава 11. Системы.

    Прежде всего необходимо понять, что конструирование и использование системы - два совершенно разных процесса.

    Например такой код создаёт зависимости и его следует избегать:

    public function get()
    {
        $model = new User();
        $model->get();
    }

    Исправить ситуацию может внедрение зависимостей

    public function get(User $user)
    {
        $user->get();
    }

    BDUF - привычка проектировать заранее всё без исключения, до написания какого-либо кода реализации.

    Принятие решений лучше всего откладывать до последнего, потому что это позволяет собрать всю информацию о проекте и принять правильное, информативное решение.

    Чистым должен быть не только код, но и архитектура системы.

    Используйте самое простое решение из всех возможных. 
*/

/*
    Глава 12. Формирование архитектуры.

    Согласно Кенту Беку архитектура может считаться "простой" если она:

        - обеспечивает прохождение всех тестов

        - не содержить дублирующегося кода

        - выражает намерения программиста

        - использует минимальное колличество классов и методов

    Паттерн "Шаблонный метод" может помочь в устранении дублирования.
*/

/*
    Глава 13. Многопоточность.

    Многопоточность устраняет привязки, помогая отделить выполняемую операцию от момента её выполнения.

    Многопоточность хорошо выручает там, где время отклика системы должно быть быстрым. Например есть сайт на котором собирается информация с других сайтов. Если это однопоточное приложение, то пока вся информация с каждого сайта не будет собрана, приложение не покажет пользователю результат или не запишет его в базу. Но что если на это требуется больше 24 часов, а ждать пользователь может только 23. Именно в такой ситуации на сцену выходит многопоточность, которая может паралельно собирать информацию с нескольких сайтов.

    Для правильной реализации многопоточности серьёзно отнеситесь к инкапсуляции данных и жётско ограничьте доступ к общим данным.

    Использовать:

        Постарайтесь писать многопоточный код так, чтобы каждый поток существовал в собственном замкнутом пространстве и не использовал данные совместно с другими процессами. Каждый поток обрабатывает один клиентский запрос, все его данные берутся из отдельного источника и хроняться в локальных переменных.

    После создания многопоточность нужно протестировать на разных платформах, потому что её реализация отличается в windows и os x

    Если понадобиться реализовать многопоточность прочитать данную главу ещё раз.
*/

/*
    Глава 14. Последовательное очищение.

    Чтобы написать чистый код, мы сначала пишем грязный код, а затем очищаем его.

    Писать программу лишь бы она заработала равносильно самоубийству.

    Согласно TDD система должна работать в любой момент в процессе внесения изменений. Иначе говоря, нельзя вносить изменения, которые нарушат её работоспособность. Для этого нужно тестировать каждый новый шаг.

    Иногда лучше перестроить систему, чем добавлять изменения.
*/

/*
    Глава 15. Внутреннее строение JUnit.

    JUnit - это библиотека для модульного тестирования.

    Не читаю дальше, так как эта информация пока ненужна.
*/

/*
    Глава 16. Переработка SerialDate.

    Здесь разбор кода библиотеки JCommon. (изучить потом, если понадобится)
*/

/*
    Глава 17. Запахи и эвристические правила.

    Список того, что "дурно пахнет" при чтении кода:

        - в комментариях не уместно хранить информацию о истории изменений, авторах и т.п.

        - не пишите комментарии, которые с течением времени устареют

        - избыточным считается комментарий, который описывает то, что и так очевидно (например эта переменная возрастает $i++;)

        - комментарии должны говорить то, что не может сказать сам код

        - увидев закомментированный код, удалите его

        - все модульные тесты должны выполняться одной командой и должны быть быстрыми

        - желательно делать функции без аргументов, но в пределе 3-х аргументов это терпимо

        - выходные аргументы функции противоестественны

        - избегать флаги в аргументах, потому что это как минимум говорит о том, что функция делает не одно действие

        - не бойтесь удалять функции, которые не используются

        - свести к минимуму использование разных языков в одном файле

        - на этапе разработки не отключать вывод ошибок

        - не повторяйтесь

        - хорошо определённый интерфейс имеет небольшое кол-во функций

        - скрывайте вспомогательные функции, константы и переменные класса

        - переменные и функции должны объявляться вблизи от места их использования

        - когда метод одного класса использует метод другого класса, пусть и через внедрение зависимостей, то это плохо (проверить)

        - функция не должна вызываться с аргументами типа true/false

        - лучше использовать нестатические функции, но если вы уверены, что не понадобиться полиморфное поведение, то можно и статические

        - используйте пояснительные переменные

        - имена функций должны описывать выполняемые действия (если приходится читать функцию, чтобы понять, что она делает, её лучше переназвать)

        - Правило одной команды if/switch

        - Общие стандарты кодирования

        - числа стоит скрыть в константах с содержательными названиями

        - передавать в функцию аргументы в виде переменных, а не волшебные числа и строки - show(1, 'John');

        - архитектура важнее кода

        - инкапсулируйте условные инструкции

        - избегать отрицательных условий в if, потому что они сложнее для понимания

        - Функция должна выполнять одну операцию. Пример неправильной функции:
                
        public void pay()
        {
            for (Employe $e as $employes) {
                if (e.isPayDay()) {
                    Money pay = e.calculatePay();
                    e.deliverPay(pay);
                }
            }
        }

        Эта функция выполняет сразу три операции: перебирает всех работников, проверяет начисленны ли работнику какие-то выплаты и наконец производит оплату. Поэтому её лучше разбить на 3 отдельных.

        - модуль не должен обладать знаниями о других компонентах с которыми он работает

        - используйте содержательные имена

        - не используйте имена, передающие информацию о реализации

        - используйте в именах переменных стандартные имена, наприме для шаблона декоратор - decorator, для работы со строкой - toString()
*/