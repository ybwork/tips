Развёртывание django на боевом сервере.

    1. Файл с зависимостями проекта от модулей

        Данная фича работает в виртуальном окружении. Чтобы посмотреть установленные модули для данного проекта, пишите :  pip freeze Чтобы сохранить их в файл, то: pip freeze > requirements.txt А для того, чтобы установить все необходимые зависимости для уже готового проекта, нужно набрать pip install -r requirements.txt , при этом файл должен находится в корне, т.е. там же, где и manage.py

    2. 

Развертывание на боевом (деплой):

Советую почитать про WSGI - что это такое, как устроено и как джанга
выполняется на сервере; будет время - как-нибудь постараюсь описать, а
пока - немного ссылок:

     http://citforum.ck.ua/programming/python/wsgi/ WSGI, введение
     http://hlabs.org/development/python/wsgi.html            WSGI -
протокол связи Web-сервера с Python приложением
     https://ru.wikipedia.org/wiki/WSGI
     http://djbook.ru/rel1.8/howto/deployment/wsgi/index.html


Сильно вкратце: есть веб-сервер, типа nginx или apache, который напрямую
отдает статику и проксирует все запросы к скриптам тем, кто умеет их
выполнять (mod_php, mod_python, php-fpm, gunicorn, ... - имя им легион);
есть разные стандарты (CGI, к примеру), описывающие, как эта вся ерунда
должна выполняться; и для питона разработали стандарт WSGI, по которому
сделали разные реализаци серверов - uWSGI, mod_wsgi, gunicorn, flup,
FastCGI; и на продакшене ты ставишь что-нибудь из этого и связываешь с
nginx-ом (тут еще можно рассказать про трехзвенную архитектуру, вот это
все, но это уже в другой раз); все это можно ставить в разных
комбинациях - apache + mod_python, apache + gunicorn, nginx + gunicorn,
nginx + uWSGI, ...

Как-то так:
     http://habrahabr.ru/post/159575/            Боевой сервер для
Django-приложения: Ubuntu Server 10.04 LTS + django 1.4 + nginx + gunicorn

Джанга тут старая, но сам подход в целом верен, выбранные решения вполне
хороши, описывает достаточно подробно;

Короче, для примера на продакшене ставим как внешний сервер - nginx, как
веб-сервер, обрабатывающий питон - gunicorn;

И еще отличная штука на боевом сервере - supervisor; служит для
демонизации процессов (программ) с определенными параметрами и
отслеживания их состояния; к примеру, он будет следить за запущенным
процессом и если тот упадет - сам его перезапустит; можно настроить логи
и их ротацию (тоже важный момент - если лог пишется постоянно, он может
легко постепенно забить хоть все место на сервере)

Ставим:

sudo apt-get install supervisor

И настраиваем как-то так:
     http://docs.mirocow.com/doku.php?id=python:supervisor        
Supervisor by python - Python


Все, раскатали проект на продакшене;


Развертывание проекта на джанго с нуля:

В командах:

# ставим все нужное (pip3 для python3):
sudo pip install virtualenv virtualenvwrapper

# разворачиваем проект
mkvirtualenv myproject
workon myproject
pip install django<1.11 django-debug-toolbar fabric gunicorn
cd ~/my_projects/
django-admin startproject core
mv core myproject
cd myproject/            # запускать manage.py нужно в каталоге, где он
находится, иначе пути создания приложений будут другие
# ...настраиваем settings.py (и при желании settings_local.py)...
./manage.py startapp main
./manage.py makemigrations
./manage.py migrate
./manage.py createsuperuser

# все готово, запускаем для разработки:
./manage.py runserver

---------

для запуска как "на боевом":

# собираем статику
./manage.py collectstatic -l

# настраиваем nginx или другой веб-сервер, как-то так:

server {
     listen 80;
     server_name myproject.local;
     access_log  /var/log/nginx/myproject.log;

     location /static/ {
         root /home/myuser/myproject/;
         expires 30d;
     }

     location / {
         proxy_pass http://127.0.0.1:8000;
         proxy_set_header Host $server_name;
         proxy_set_header X-Real-IP $remote_addr;
         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
     }
   }

# именно из папки проекта (там, где лежит manage.py) запускаем gunicorn:

gunicorn myproject.wsgi:application  --bind 127.0.0.1:8000

Переходишь на:

myproject.local/

и должен загрузиться сайт;

Если разворачиваешь по-настоящему, еще хорошо бы много чего сделать:
настроить БД проекта, статику, нгинкс, supervisord, балансировщики и т.п.

Вкратце - вот так она и разворачивается )

------------------

Тут подробнее;

Сразу важный нюанс - схема развертывания может меняться, лучше
справляться в доке (к примеру, в старых версиях джанги не было миграций,
какие-то вещи могли работать немного не так, шаблоны могли быть другими,
подходы к статике (css, js) - да и вообще - все течет, все меняется);

По большей части тут рассказывать буду про собственно развертывание, pip
и пакеты, грамотную структуру проекта; про то, как создавать приложения,
настраивать админку и т.п. - отдельно (ну и отчасти ты это уже пробовал
и смотрел/читал другие руководства);

Сначала небольшое отступление, про пакеты и организацию кода:

Обычно код пакуют в библиотеки, в данном случае - в пакеты; обычно это
запакованный файл определенного формата (или просто набор файлов), с
которым умеет работать менеджер пакетов; такое есть практически во всех
языках - CPAN - архив модулей Perl (как PyPI в питоне), менджер npm для
яваскрипта (обычно NodeJS, но, в принципе, там очень много и для
фронтенда), даже для PHP - Phar, Pear и че там еще придумали,
управляемое через Composer; в компилируемых языках код библиотек обычно
объектный, в скриптовых - обычно тупо файлы с исходным кодом;

Пакеты в питоне ставятся с помощью pip (не буду отвлекаться еще на
богатую историю систем управления пакетами в питоне - существуют
distutils, setuptools, distribute, distutils2 в качестве базовых
механизмов распространения и virtualenv, buildout, easy_install и pip в
качестве высокоуровневых инструментов управления всем этим беспорядком);
Прикоснуться к богатой истории можно, например, тут:
     https://habrahabr.ru/post/210450/                Python на колёсах
/ Хабрахабр

Короче, сейчас как система управления пакетами используется pip;
Сами питоньи пакеты хранятся в репозитории PyPI - Python Package Index;

С помощью pip их легко ставить так:

pip install numpy
pip install lxml
pip install gunicorn

Он знает, что такое "numpy" или "lxml" как раз потому, что ищет в этом
большом архиве - PyPI;
Для третьего питона пакеты ставят через pip3 - та же фигня, но для
третьего питона; начиная с 3.4 он входит в состав питона по умолчанию;
до этого его нужно было ставить;

Если хочешь поставить пакет не из индекса, а свой - то он может скачать
пакет откуда скажешь:

# по протоколу git, с гитхаба:
pip install
git+https://github.com/yourlabs/django-autocomplete-light.git#egg=django-autocomplete-light

# по протоколу ssh, со своего репозитория (ну там как настроишь, еще
некоторые нюансы есть):
pip install git+ssh://github.com/USER_NAME/REPO_NAME.git


Обновить pip можно с помощью него же:
pip install --upgrade pip

Можно перечислить все пакеты:
pip install pyflakes pep8 pylint

Можно указать версии пакетов:
pip install django<1.10
pip install django-redis==4.7.0

Иногда бывают проблемы с установкой, т.к. пакет требует каких-нибудь
сишных библиотек в системе, на которые он опирается, а сам их установить
не может (предполагает, что в системе они есть, часто автор пишет это в
README своего пакета):

для lxml, к примеру, нужно доустановить (в зависимости от системы):
sudo apt-get install libxml2-dev libxslt-dev

К слову, джанго - это тоже всего лишь пакет, хотя и большой )

Как самому собирать пакеты и подключать их в dev- и prod- режиме,
расскажу как-нибудь в другой раз (только напомни);

Если просто писать pip install ..., то ставится оно в систему, там, где
определено место, куда он кладет библиотеки (что-то вроде
/usr/local/lib/python2.7/dist-packages/ в линуксе); прав может не
хватать, и если ставишь пакеты вот так, глобально, то он потребует
написать sudo pip install ...; часто, если не получается установить
пакет,  не хватает прав записать в системные директории;

Статья, где вообще питон ищет пакеты (бурж.):
https://leemendelowitz.github.io/blog/how-does-python-find-packages.html
             How does python find packages? // Lee On Coding // My blog
about coding and stuff.

После установки всех пакетов можно записать все пакеты с их версиями в
файлик requirements.txt (напоминаю, находимся в виртуальном окружении):

pip freeze -l > requirements.txt

К примеру, включаем виртуальное окружение и ставим пакеты:

source ~/myproject-env/bin/activate
# или так (ниже расскажу):
# workon myproject
pip install django<1.11
pip install django-debug-toolbar
pip install gunicorn

И потом запишем наши установленные пакеты:

pip freeze -l > requirements.txt

файлик requirements.txt будет примерно такого содержания - пакеты и их
фиксированные версии:

django<1.10
django-debug-toolbar<1.6
gunicorn==19.4.5

Файлик можно поправить, но так его удобно создавать - чтобы не
вспоминать, какие пакеты и каких версий у тебя сейчас есть в приложении;
Важно! Версии крайне желательно фиксировать - можно написать и просто
django, но после обновления пакетов проект может и не заработать!

Пример: ты создал проект на джанге 1.8, в requirements.txt записал
просто "django" и "django-tinymce"; пишешь-пишешь-пишешь, проверяешь,
все замечательно работает; переносишь на хостинг (или разворачиваешь
дома, короче - разворачиваешь проект еще где-нибудь), и ставишь все
зависимости, что есть в файле:

pip install -r requirements.txt

Система ставит самую новую джангу, и у тебя уже может что-то не работать
(банальный пример - не помню точно номера версий, но в какой-то джанге
было @property queryset, а в новой версии заменили методом get_queryset
- и оно не работало при переводе на новую версию джанги, надо было все
тщательно тестировать); или, к примеру, только что вышла новая джанга, а
т.к. ты не указал версию, она и поставилась; а пакет django-tinymce еще
не успел обновиться, и на продакшене приолжение посыпалось (причем
ошибки зачастую будут совсем неинформативными); вот чтобы такого не было
- фиксируем все версии и меняем только руками - тогда гарантируем, что
когда ты деплоишь проект, все полностью корректно соберется;

Можно провести параллель между питоньим pip и requirements.txt и
яваскриптовым npm и packages.json:

# поставить пакеты и сохранить че поставил с версиями в файл package.json
npm install browserify vue vueify vue-template-compiler watchify --save

Поставятся пакеты и создастся файлик package.json, в котором будет в
нужном формате стоять установленные пакеты и их версии:

# package.json
{
   "name": "vueify-tutorial",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "browserify -t vueify -e main.js -o build.js",
     "watch": "watchify -t vueify -e main.js -o build.js"
   },
   "devDependencies": {
     "browserify": "*",
     "vue": "^1.0.24",
     "vue-template-compiler": "^2.1.6",
     "vueify": "^8.4.1",
     "watchify": "^3.7.0"
   },
   "keywords": [],
   "author": "",
   "license": "ISC"
}

Ну, либо написать такой файлик вручную и набрать:

npm install

тогда поставит все, что написано в файле (пакеты нужных версий) локально;



Полезные команды pip:

----------------------
pip freeze -l                                посмотреть пакеты (-l -
локальные)
pip show django                                посмотреть версию пакета
django
pip install -r requirements.txt                установить пакеты
pip install -U -r requirements.txt            обновить (переустановить)
пакеты
pip install --upgrade pip                    обновить сам pip
pip install -e <path>                        установить пакет для
разработки (создает симлинк)

создаем requirements.txt в корне проекта (для всех установленных уже
библиотек; находимся в виртуальном окружении при выполнении команды,
иначе создаст список из питоньих библиотек, стоящих в системе):

pip freeze -l > requirements.txt
----------------------


Рекомендую доку по пипу (да и вообще дока - завсегда полезная штука,
особенно в питоньих проектах, зачастую написана очень хорошо):
     https://pip.pypa.io/en/latest/user_guide/


В питоне еще есть такая штука, как виртуальные окружения - такая
изолированная среда, в которую можно ставить любые пакеты;

Когда ты ставишь пакеты через sudo pip install - они ставятся глобально
в систему; что-то, безусловно, удобно ставить в систему глобально - к
примеру, fabric, ipython; но ставить глобвально все пакеты - неудобно,
если у тебя больше одного проекта, либо в разных версиях проекта нужны
разные версии пакетов;

К примеру, у тебя есть три проекта - на джанге 1.8, джанге 1.5 и ты
хочешь еще замутить новый, на джанге 2.0; если у тебя джанго (пакет)
стоит глобально, то версия у тебя всего одна, и для того, чтобы
переключиться на другой проект, надо все снести и переставить (это
только джанга, а обычно в проекте еще штук 20 пакетов еще может быть);
вот тогда и приходит на помощь виртуальное окружение - такая отдельная
папка с питоном, где ты можешь ставить пакеты отдельно - по умолчанию
там только питон и все, чистенький;

Примерно так же все и в npm - можно ставить глобально:

npm install -g gulp

или локально в проект:

npm install gulp


Ставим утиль для виртуального окружения (тоже пакет):

sudo pip install virtualenv

Имеем три папки с проектами:
     myproject_18/
     myproject_15/
     myproject_20/

Создаем рядом с каждым проектом свое виртуальное окружение:

virtualenv myproject_18-env
virtualenv myproject_15-env

-env добавлять не обязательно, но так обычно делают; короче, пишешь
virtualenv <путь-где-я-хочу-развернуть-окружение>; если просто указать
myproj - создаст папку myproj в текущем каталоге (где запускаешь
команду) и виртуальное окружение в ней; с -env лучше будет видно, где
проект, а где окружение: myproj-env/;

Для джанги 2.0 ставим виртуальное окружение для третьего питона:

virtualenv -p /usr/bin/python3 myproject_20-env

После этого появятся папки с виртуальными окружениями, рядом с проектами
(вообще можно делать их где угодно, эти папки):
     myproject_18-env/
     myproject_15-env/
     myproject_20-env/

И теперь все наши каталоги:
     myproject_18/
     myproject_15/
     myproject_20/
     myproject_18-env/
     myproject_15-env/
     myproject_20-env/

После этого можно активировать виртуальное окружение:

source myproject_18-env/bin/activate

И пока ты в этом терминале и слева написано (myproject_18-env) $ ..., то
теперь питон используется не системный, а из этого виртуального
окружения - из этой папки; теперь, когда ты пишешь

pip install django==1.8

джанга как пакет поставится в папку myproject_18-env/, а не в систему
(/usr/local/lib/python2.7/site-packages/ или куда там еще);

Виртуальное окружение - просто папка с питоном и установленными тобой в
эту папку пакетами, и пара скриптов, которые позволяют подменять в путях
системный питон на тот, что в виртуальном окружении;

После того, как поставил все, что нужно в виртуальном окружении - оно
сохранится в этой папке; если выйти, а потом зайти снова в это окружение
- все останется;

Чтобы выйти из виртуального окружения - надо либо закрыть шелл
(виртуальное окружение просто подменяет тебе питон в текущем шелле),
либо написать

deactivate

Потом зайти в другие окружения, поставить пакеты там; после чего будут
три независимых папки с питонами (две со вторым и одна с третьим) и
разными пакетами, которые совершенно никак не пересекаются;

Теперь можно спокойно переключаться между проектами - заходить с помощью
команды source и выходить с помощью deactivate; можно даже работать
одновременно с несколькими проектами - открыл один шелл, активировал
окружение, и запустил runserver джанги; затем открыл еще один шелл,
активировал второе окружение и запустил runserver второй джанги; открыл
еще шелл, активировал окружение опять для первого проекта, и запустил
там шелл;

Опять же, это не только для джанги, для питоньих проектов вообще; кроме
того, можно создать себе окружение как набор нужных пакетов и работать в
одном окружении с несколькими проектами (для научных вычислений и
графики к примеру - numpy, skite, mathplotlib, pandas - нужны для многих
вычислений) чтобы не замусоривать глобальные системные пакеты - ставим
только сюда и активируем; система всегда чистенькая, а окружение
отдельное и даже переносимое; в винде вообще портабл получается - можно
скопировать всю папку с виртуальным окружением, да и перенести на другой
диск или даже комп; в линуксе наверняка тоже (но ни разу с таким не
заморачивался);

IDE типа пайчарама очень хорошо умеют с ними работать из коробки -
указал окружение, и он автоматически тебе его включит, даже заботиться
ни о чем больше не надо; и проекты полностью изолированы друг от друга,
и хлопот никаких с переключением;

Если ты на линуксе, есть такая хорошая штука по управлению виртуальными
окружениями - virtualenvwrapper (под виндой не тестировал, мб тоже
работает);

virtualenvwrapper предоставляет немного более удобный интерфейс к
virtualenv;

Самое забавное, что и утилита по управлению виртуальными окржениями -
тоже пакет:

sudo pip install virtualenvwrapper
# обычно ставят вместе с virtualenv (pip умный, если virtualenv уже
есть, второй раз не поставит);
# sudo pip install virtualenv virtualenvwrapper

Он просто позволяет запускать виртуальное окружение чуть удобнее:

без virtualenvwrapper-а:

source ~/myproject-env/bin/activate

с ним:

workon myproject

Все окружения лежат в ~/.virtualenvs, запускаются из любого места; так
просто организованнее и проще;

Полезные комнады virtualenvwrapper:

----------------------
workon                без параметров - напечатать список виртуальных
окружений
workon my_env        включить виртуальное окружение my_env
deactivate            выключить виртуальное окружение

mkvirtualenv        создать виртуальное окружение (в ~/.virtualenvs)
mktmpenv            создать TEMP виртуальное окружение (со случайным именем)

rmvirtualenv        удалить виртуальное окружение (до этого сделать
deactivate)
cpvirtualenv        скопировать -//-

lsvirtualenv        список всех виртуальных окружений
showvirtualenv        показать детально виртуальные окружения


cdvirtualenv        сменить директорию в виртуальное окружение
cdsitepackages        cd site-packages
lssitepackages        ls site-packages

setvirtualenvproject        связывает виртуальное окружение и проект

mkproject            создает виртуальное окружение в WORKON_HOME и
проект в указанной PROJECT_HOME
----------------------

Помнить чаще всего нужно только mkvirtualenv, workon и deactivate (хотя
вместо deactivate зачастую просто выходишь из шелла, и все);


Дока по virtualenvwrapper и советы по нему же:
     https://virtualenvwrapper.readthedocs.io/en/latest/
     https://virtualenvwrapper.readthedocs.io/en/latest/tips.html


По поводу структуры джанговского проекта - можно создать свой шаблон
джанги (по буржуйски подобное называется boilerplate) - свою структуру
проекта; если у тебя уже есть сложившаяся структура, как ты чаще всего
начинаешь новые проекты - проще всего при старте указать свой шаблон
приложения (принимает архивы и ссылки на гитхаб (опять же, архивы) ):

django-admin startproject
--template=https://github.com/githubuser/django-project-template/archive/master.zip
myproject

Когда Django копирует файлы шаблона проекта, он может рендерить
определенные файлы как шаблоны Django: все файлы с расширением,
указанным опцией --extension (по умолчанию py), и файлы с названием,
указанным опцией --name. При рендеринге используется template context со
следующими переменными:

Все опции, переданные при вызове команды startproject (только
поддерживаемые этой командой):
     project_name – название проекта, указанное при вызове команды
     project_directory – полный путь к созданному проекту
     secret_key – случайный ключ для настройки SECRET_KEY
     docs_version – версия документации: 'dev' или '1.x'


Ссылки, где рассказывается про это подробнее:
     https://adambard.com/blog/django-boilerplate/                    
     Django Boilerplate - Adam Bard and his magical blog
http://www.marinamele.com/2014/02/django-best-practices-ii-project.html
             Django best practices: Project structure & HTML5 Boilerplate
https://www.maykinmedia.nl/blog/2013/jun/6/customizing-django-startproject-templates/
             Blog Customizing Django startproject with templates -
Maykin Media - Python & Django webdevelopment
https://www.djbook.ru/rel1.9/ref/django-admin.html#startproject-projectname-destination
     Еще в книжке "two scoops of django", стр. 21

Примеры шаблонов:
     https://github.com/caktus/django-project-template
     https://github.com/imkevinxu/django-kevin
     https://bitbucket.org/maykinmedia/default-project     maykinmedia /
default-project — Bitbucket



Ставим джангу и настраиваем для разработки:

# ставим все нужные инструменты глобально (pip3 для python3):
sudo pip install virtualenv virtualenvwrapper

# разворачиваем проект
mkvirtualenv myproject

# запускаем виртуальное окружение проекта
workon myproject

# находясь в виртуальном окружении, ставим джангу и еще что-нибудь полезное
pip install django<1.11 fabric gunicorn

# создаем requirements.txt в корне проекта (для всех поставленных
библиотек); requirements.txt - простой текстовый файлик с описанием
установленных библиотек и их версий; можно написать и вручную, но так проще;
pip freeze -l > requirements.txt

Кстати, для удобства можно поставить ipython; причем можно поставить его
глобально: sudo pip install ipython, а затем, при установке в проект
(pip install ipython) он не будет качать его еще раз, а возьмет уже
установленный глобально ipython; единственный нюанс, что история в шелле
ipython будет общая для всех проектов, в которых он так был поставлен
(после глобальной установки);

# переходим в проект
cd ~/my_projects/

# создаем папку с проектом
mkdir myproject/

# создаем проект
django-admin startproject core

# переименовываем проект
mv core myproject

# переходим в проект
cd myproject/            # запускать manage.py нужно в каталоге, где он
находится, иначе пути создания приложений будут другие

Чистое имхо, но я чаще всего создаю проект и приложение, где лежат
конфиги, с названием core/; django создаст как-то так:

core/
     core/
     manage.py

Переименовываем верхнюю папку (core на нижнем уровне - не трогаем, он
прописывается во всяких путях и его название лучше не трогать):

myproject/
     core/
     manage.py


Получается примерно такая структура:

myproject/
     myproject/
         core
         main
         static
         db.sqlite3
         manage.py
     project_notes/
     docs/
     README.rst
     .git
     .idea
     .gitignore
     requirements.txt
     fabfile.py

Сначала папка myproject/, безо всякой джанги, там лежат:
     project_notes/            всякие заметки по проекту, схемы БД,
текст - ТЗ и заметки, всякая прочая ерунда; папка не в гите
     docs/                    документация
     README.rst                реадмишка (в принципе, вот такая
структура хороша для выкладки на github)
     .git                    весь репозиторий, именно тут, а не только в
папке с джанго-проектом
     .gitignore                где .git, там и .gitignore
     .idea                    в IDE также добавлял всю папку
     requirements.txt        зависимости проекта (опять же, по желанию -
можно разместить и в папке с джанго-проектом)
     fabfile.py                скрипт для автоматизации и деплоя (к
примеру, выполнять команды через питон на различных серверах); дальше
подробнее расскажу;
     myproject/                вот тут уже сам джанго-проект


Также к проекту можно всякие package.json, gulp и все, что душа пожелает;

myproject/ - это уже сам проект джанги, тут уже создаем все приложения;
папка core/ всегда при таком раскладе - конфиги и все, что относится ко
всему проекту; мне кажется, эстетичнее, чем имя проекта дважды:

station/
     station/
     main/
     manage.py

Выше рассказывал про шаблоны-boilerplate - можно создать свою любимую
структуру и разворачивать проект сразу в ней, без лишних телодвижений:

django-admin startproject
--template=https://github.com/githubuser/django-project-template/archive/master.zip
myproject

или локально:

django-admin startproject --template=/path/to/my/structure/file.zip

Еще, кстати, хорошо рассказывается про структуру проекта в книжке two
scoops of django (на буржуйском, но вообще must read по джанге);


# ...настраиваем settings.py (и при желании settings_local.py)...


Создаем основные файлы проекта:

Кроме файла settings.py можно создать и другие файлы настроек; есть
несколько путей:

Создаем файл core/settins_local.py - различные настройки к примеру для
сервера (продакшн) и дебага (локально у себя), его выключим из гита;

Этот файл будет переопределять некоторые настройки из settings -
например, базы данных (переопределить в этом файлике свои локальные, на
продакшене, на тестовом, на стейдж-сервере и т.п.) и все, что можно
менять без системы контроля версий; кроме того, каждый разработчик в
этом файле у себя пишет свои локальные настройки, переопределяет
переменные для тестирования, включает DEBUG=True, и т.п.; использование
такого файлика (без гита) - небольшой холивар, т.к. есть мнение, что
лучше в системе контроля версий держать все;

Чтобы он переопределял настройки, в файле settings.py в конец дописываем:

from .settings_local import *


Еще отступление по поводу баз данных - можно полностью их менять,
переопределив словарь DATABASES в settings_local, а можно переопределить
так, дописав после импорта settings_local в settings.py еще строчку:

DATABASES.update(LOCAL_DATABASES)

И в settings_local назвать переменную LOCAL_DATABASES;

Короче, суть файла - в том, чтобы часть настроек менять без коммитов;

Обычно в settings пишется все, что необходимо для запуска проекта и что
не зависит от окружения, где будет развернуто; базы данных, кеш
(редис/мемкеш/...), пути к брокеру собщений и т.п. - можно задавать в
settings_local, в общем все, что специфично для развертывания и каждый
раз может быть другим;

Если требуются вот такие параметры, которые нужно определить в
settings_local, но не стоит помещать в settings, еще можно создать файлик:

settings_local.template

куда записывать примеры того, что нужно бы записать в наш настоящий
settings_local.py

Файл settings_local.template будет в системе контроля версий, поэтому
все остальные разработчики легко поймут, что требутется добавить;

Но это в случае файлика settings_local.py, который не входит в систему
контроля версий проекта; если туда добавить все файлы, то ничего больше
и не надо;


Можно сделать несколько файлов настроек и включать джангу с любым из них:
     settings_dev.py
     settings_prod.py

Запускать с разными settings так:

python manage.py runserver --settings=core.settings_dev
python manage.py shell --settings=core.settings_prod


А то и вообще так:

settings/
     __init__.py
     base.py
     local.py
     staging.py
     test.py
     production.py

Все это добавить в git и иметь конфиги на все случаи жизни;

Запускать можно так:

python manage.py runserver --settings=core.settings.local
python manage.py runserver --settings=core.settings.production
...

Плюс этого подхода - изменения любого конфига запоминаются, поэтому не
будет ситуаций, когда проект не работает, так как у кого-то в его
локальном settings_local есть нужная переменная, а вот в основной
settings он ее добавить забыл - у него работает, у остальных нет;


Дописываем пути к media и статике в настройках:

# settings.py

import os
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')


создаем каталоги в джанговском проекте myproject/ :
     media/                медиа - загружается пользователями
     static/                статика - дизайн и скрипты


Совет: чтобы не хранить пароли к БД в settings (и вообще параметры
коннекторов), вообще коннекторы (DATABASES) можно хранить в
settings_local; но если необходимо держать их в settings, пароли и
вообще строки подключения можно хранить в файлах .cnf, которые можно
исключить из git:

.gitignore
     /conf/*.cnf

# mydb.cnf:

[client]
database = mydatabase
user = test
password = test
port = 5432


# settings.py

Вместо такого (пароль "test" в этом случае попадет в гит, что нехорошо):

DATABASES = {
     'default': {
         'ENGINE': 'django.db.backends.postgresql_psycopg2',
         'NAME': 'mydatabase',
         'PASSWORD': 'test',
         'USER': 'test',
         'HOST': 'localhost',
         'PORT': '5432'
     },
}

Написать так (CONF_PATH определить где-нибудь в settings вверху, так,
как BASE_DIR):

DATABASES = {
     'default': {
         'ENGINE': 'django.db.backends.postgresql_psycopg2',
         'NAME': 'mydatabase',
         'HOST': 'localhost',
         'PORT': '5432'
         'OPTIONS': {
             'read_default_file': os.path.join(CONF_PATH, 'mydb.cnf'),
         }
     },
}



Создаем файлик .gitignore (как-то так):
     /.idea/
     /myproject/core/settings_local.py
     /project_notes/
     /*~
     *.py[cod]
     /media/
     /static/
     /node_modules/
     ...
     и чего еще душа пожелает


Создаем основное приложение - к примеру, main;
Сайт часто разделяется на смысловые группы - каталог, комментарии, блог,
... - приложения django; вот их и создаем по мере необходимости;

./manage.py startapp main

Чтобы посмотреть миграции, есть такие команды:

# раньше была команда (до джанги 1.10)
./manage.py migrate --list

# для более новых версий так (или просто ./manage.py showmigrations)
./manage.py showmigrations --plan

Создаем миграции:

./manage.py makemigrations

Проводим миграции (базы данных же у нас настроены?)

./manage.py migrate


Создаем репозиторий и первый коммит:

git init
git add .
git commit -m 'Initial commit'

Создаем суперпользователя для админки:

./manage.py createsuperuser

Проверить, что все хорошо, можно командой

./manage.py check

В принципе, эта команда вызывается практически перед любой другой -
migrate, shell, runserver... Но иногда нужно просто проверить - все ли
корректно?

Все готово, запускаем для разработки:

./manage.py runserver

Вот так - чтобы достучаться можно было не только со своей локальной
машины (и заодно номер порта указать, особенно если одновременно пять
проектов локально запускаешь):

./manage.py runserver 0.0.0.0:8000


Чтобы работала статика на локальном runserver-е, в urls прописать что-то
вроде:

if settings.DEBUG:
     from django.conf.urls.static import static
     # чтобы работала статика
     urlpatterns +=
static(settings.STATIC_URL,document_root=settings.STATIC_ROOT)
     # чтобы работали медиа-файлы
     urlpatterns += static(settings.MEDIA_URL,
document_root=settings.MEDIA_ROOT)

Строчки эти служат для отдачи статических файлов встроенным сервером
djsngo; хз, правда, насколько это сейчас актуально;

Для того, чтобы работали пользовательские файлы, для url, в котором они
участвуют, еще вроде надо прописать как-то так:
url(r'^votes/images/(?P<path>.*)$', 'django.views.static.serve',
      {'document_root': settings.MEDIA_ROOT, 'show_indexes': True }),

Но это лучше гуглить для конкретной версии и конкретной проблемы;

Про статику в джанге:
     https://djbook.ru/rel1.9/intro/tutorial06.html Создаём своё первое
приложение с Django, часть 6 — Документация Django 1.9
     https://djbook.ru/rel1.9/howto/static-files/ Работа со статическими
файлами (например изображения, JavaScript, CSS) — Документация Django 1.9


Развертывание на боевом (деплой):

Советую почитать про WSGI - что это такое, как устроено и как джанга
выполняется на сервере; будет время - как-нибудь постараюсь описать, а
пока - немного ссылок:

     http://citforum.ck.ua/programming/python/wsgi/ WSGI, введение
     http://hlabs.org/development/python/wsgi.html            WSGI -
протокол связи Web-сервера с Python приложением
     https://ru.wikipedia.org/wiki/WSGI
     http://djbook.ru/rel1.8/howto/deployment/wsgi/index.html


Сильно вкратце: есть веб-сервер, типа nginx или apache, который напрямую
отдает статику и проксирует все запросы к скриптам тем, кто умеет их
выполнять (mod_php, mod_python, php-fpm, gunicorn, ... - имя им легион);
есть разные стандарты (CGI, к примеру), описывающие, как эта вся ерунда
должна выполняться; и для питона разработали стандарт WSGI, по которому
сделали разные реализаци серверов - uWSGI, mod_wsgi, gunicorn, flup,
FastCGI; и на продакшене ты ставишь что-нибудь из этого и связываешь с
nginx-ом (тут еще можно рассказать про трехзвенную архитектуру, вот это
все, но это уже в другой раз); все это можно ставить в разных
комбинациях - apache + mod_python, apache + gunicorn, nginx + gunicorn,
nginx + uWSGI, ...

Как-то так:
     http://habrahabr.ru/post/159575/            Боевой сервер для
Django-приложения: Ubuntu Server 10.04 LTS + django 1.4 + nginx + gunicorn

Джанга тут старая, но сам подход в целом верен, выбранные решения вполне
хороши, описывает достаточно подробно;

Короче, для примера на продакшене ставим как внешний сервер - nginx, как
веб-сервер, обрабатывающий питон - gunicorn;

И еще отличная штука на боевом сервере - supervisor; служит для
демонизации процессов (программ) с определенными параметрами и
отслеживания их состояния; к примеру, он будет следить за запущенным
процессом и если тот упадет - сам его перезапустит; можно настроить логи
и их ротацию (тоже важный момент - если лог пишется постоянно, он может
легко постепенно забить хоть все место на сервере)

Ставим:

sudo apt-get install supervisor

И настраиваем как-то так:
     http://docs.mirocow.com/doku.php?id=python:supervisor        
Supervisor by python - Python


Все, раскатали проект на продакшене;

Теперь нужно позаботиться о том, как обновлять проект;

Обновление проекта на боевом часто сводится к набору команд:

# обновляем все пакеты
pip install -U -r requirements.txt

# проводим миграции
./manage.py migrate

# собираем статику
./manage.py collectstatic -l

и какие-нибудь специфические свои команды - перезапуск gunicorn, тасков,
сигналы смежным проектам, очистка кеша и т.п.

Все это можно оформить в файлик типа apply.sh - шелл-скрипт и положить в
папку с проектом:

# apply.sh

------------------
#!/bin/bash

# комментарии в баш-скриптах тоже можно писать, после решетки
pip install -U -r requirements.txt
./manage.py migrate
./manage.py collectstatic -l
find . -name "*.pyc" -delete
------------------

# ставим права на выполнение
chmod +x ./apply.sh

И каждый раз после git push на боевом сервере запускать этот скриптик,
который будет выполнять все необходимые действия; плюсы, если однотипные
действия сразу оформить в скрипт - не надо каждый раз делать одно и то
же руками и будет меньше ошибок - в этот раз забыл миграции применить, в
другой раз - собрать статику, из-за чего новые файлики js не подтянулись
и т.п.
В общем, все что можно возложить на компьютер - надо воскладывать )

Можно пойти еще дальше - в гите есть хуки - можно настроить на
определенные события какие-нибудь действия; к примеру, на git pull на
боевом сервере поставить автоматическое выполнение apply.sh, который
применит миграции, соберет статику, почистит кеш, перезапустит проект и
т.п. - и тебе даже париться об этом не придется, все обновление сведется
к командам git push на локальном и git pull на проде;

Вот тут подробнее (эх, хотел я и в МЗ-шном проекте когда-то это
настроить...)
https://git-scm.com/book/ru/v1/Настройка-Git-Перехватчики-в-Git


Кстати, важный нюанс питона после пхп: пхпшные проекты работают по
запросу - пришел запрос, пхп начал с нуля выполнять файлы, отдал и на
следующий запрос запускается все заново; плюс в таком подходе - "горячая
замена кода", когда ты просто заменяешь файлы на сервере и проект сразу
обновлен, и работает с новым кодом; питоний (джанговский) проект
постоянно висит в памяти (как, например, приложуха на java), и его
требуется перезапустить (ну, то, что его обслуживает -
gunicorn/uwsgi/...); минус подхода - нужен перезапуск приложения, плюс
подхода - можно сначала все подготовить, а затем в нужный момент одной
командой перезапустить; в общем, об этом нужно помнить - изменения сами
собой не применятся, питоньи проекты надо перезапускать!


Чтобы пойти еще дальше, можно деплоить со своей машины, не заходя вообще
на боевой сервер лично; для этого можно воспользоваться питоньим
инструментом fabric - для автоматического развертывания; особенно
удобно, если тебе надо развернуть твое приложение (приложения) однотипно
на десяток серверов;


Скрипт может зайти на удаленную машину по ssh (проще всего настроить
доступ по ssh-ключику) и выполнять команды; очень удобно; для
js-проектов обычно используют какой-нибудь gulp, где пишут скрипты для
всевозможной автоматизации - сборки, сжатия, выкладки и т.п.

Чисто для примера - добавляем все файлы в гит, делаем коммит (commit -a
- автоматически добавить измененные файлы; новых это не коснется,
поэтому git add .) и пушим на сервер:

# fabfile.py

# coding: utf-8
import os
from fabric.api import run, env, cd, roles, lcd, local, sudo

def gitpush():
     lcd('/home/myuser/my_projects/myproject')
     local('sudo git add .')
     local("sudo git commit -a)
     local('sudo git push origin master')

Выполнение (находимся в папке с fabfile.py):
fab gitpush

lcd - "local cd", команды с префиксом l* выполняются на локальной машине;

Пример посложнее, с разными проектами и деплоем на несколько серверов:

# -*- coding: utf-8 -*-
from fabric.api import env, roles, run, cd, local

# роли  - проекты и сервера (доступ, помним, уже настроен по ключу - так
удобнее)
env.roledefs = {
     'first_project': [
         'user@server_1',
     ],
     'second_project': [
         'user@server_1',
         'user@server_2',
     ],
}

# функция стандартного автоматического обновления на продакшене
def deploy_production():
     local('fab update_project')
     local('fab migrate_databases')
     local('fab collect_static')
     local('fab restart_project')


@roles('first_project')
def update_project():
     with cd('~/first_project'):
         run('git pull')


@roles('first_project')
def restart_project():
     # команда перезапуска, специфична для проекта; в этом примере через
supervisor
     run('supervisorctl restart first_project:')


# собираем статику в проекте second_project; проект размещается на двух
серверах;
@roles('second_project')
def collect_static():
     with cd('~/second_project'):
         run('echo "yes" | bin/manage collectstatic -l')


@roles('first_project')
def install_requirements(update=False):
     with cd('~/first_project'):
         if update:
             run('bin/pip install -U -r requirements.txt')
         else:
             run('bin/pip install -r requirements.txt')


@roles('first_project')
def uninstall_requirements(packages=None):
     if packages:
         with cd('~/first_project'):
             run('bin/pip uninstall -y %s' % packages)


Запускаем обновлене статики для second_project, на двух серверах -
server1 и server2:

fab collect_static

Обновляем requirements для проекта first_project:

fab install_requirements:update=True

Деплой - командой

fab deploy_production

Скрипт выкладки приложения на один сервер будет примерно таким, если
записать все в одной функции:

# fabfile.py

# -*- coding: utf-8 -*-
from fabric.api import env, roles, run, cd, local

# роли  - проекты и сервера (доступ, помним, уже настроен по ключу - так
удобнее)
env.roledefs = {
     'myproject': [
         'user@server_1',
     ],
}

@roles('myproject')
def update_project():
     with cd('~/myproject'):
         run('git pull')
         run('source ~/myproject-env/bin/activate')
         run('pip install -U -r requirements.txt')
         run('./manage.py migrate')
         run('./manage.py collectstatic -l')
         run('find . -name "*.pyc" -delete')
         run('supervisorctl restart myproject:')


После чего можно после коммита набрать всего две команды, находясь в
папке с проектом:

git push
fab update_project

И все автоматически применится и перезапустится;

Подробнее:
     http://www.fabfile.org/                Welcome to Fabric! — Fabric
documentation


Ну а еще дальше - CI (Continuous integration), чертовски хорошая штука,
но об этом - как-нибудь в другой раз (только напомни ;) )
Это уже по-взрослому - тесты, автоматизированный деплой приложений на
разные сервера, непрерывная интеграция; все как в лучших домах Европы,
как говорится;


Как разворачивать django на хостинге, можно почитать в инструкциях
непосредственно на самом хостинге:
     https://www.jino.ru/help/faq/python/django-setup/#django-setup
http://timeweb.com/ru/help/pages/viewpage.action?pageId=4358467
     https://beget.com/ru/articles/webapp_python#2


Ну или есть облачные сервисы:
     https://ru.wikipedia.org/wiki/Heroku
     https://www.mvoronin.pro/en/blog/post-103 Использование Heroku для
развертывания веб-приложения на Django


---------------------


Что можно полезного почитать?

Изучение django:

Начать можно отсюда (поначалу наверное даже понятнее, чем в доке будет):
     https://tutorial.djangogirls.org/ru/ Введение · Django Girls Tutorial

Продолжить можно тут (туториал из официальной доки):
     https://djbook.ru/rel1.9/intro/tutorial01.html Создаём своё первое
приложение с Django, часть 1 — Документация Django 1.9

Еще есть технострим от маила, довольно грамотное использование джанги
(можно придираться, но в целом рассказывают неплохо):
     https://www.youtube.com/watch?v=Ykurlvt-VYQ Web-технологии.
MVC-фреймворки. Django
     https://www.youtube.com/watch?v=PX4PL-XSQ3Q Web-технологии. Django
(часть 2)
     https://www.youtube.com/watch?v=LX-Uyx1vfhI 7. Веб-разработка. В
глубь Django | Технострим


Важно следить за версиями (особенно для первого, обучающего, приложения)
- если ты создаешь приложение на версии 1.9, лучше и учебник/статьи
возьми по этой же версии, ибо могут быть некоторые разночтения, и проще
именно разбирать как это работает, а не тратить кучу времени сразу на
какие-нибудь неувязки, вроде того, что в какой-нибудь старой версии
миграции можно посмотреть как manage migrage --list, а в новой уже
manage showmigrations - и искать, почему же выдает ошибку; а если делать
по совсем старому туториалу по Django 1.0 - так там вообще миграций нет,
и советуют ставить сторонний south;

Развертывание django (статьи разной степени свежести):
     https://djbook.ru/examples/62/                    Django + Python3
+ Nginx + Gunicorn + DO | Recipes | Django на русском
     https://habrahabr.ru/post/159575/                Боевой сервер для
Django-приложения: Ubuntu Server 10.04 LTS + django 1.4 + nginx +
gunicorn / Хабрахабр
     https://habrahabr.ru/post/226419/                Django на
production. uWSGI + nginx. Подробное руководство / Хабрахабр
     https://habrahabr.ru/post/120363/                Настройка сервера
для django-проектов с нуля / Хабрахабр

WSGI:
     http://citforum.ck.ua/programming/python/wsgi/ WSGI, введение
     http://hlabs.org/development/python/wsgi.html            WSGI -
протокол связи Web-сервера с Python приложением
     https://ru.wikipedia.org/wiki/WSGI
     http://djbook.ru/rel1.8/howto/deployment/wsgi/index.html

fabric:
     http://www.fabfile.org/                                Welcome to
Fabric! — Fabric documentation
     https://adw0rd.com/2012/8/14/python-fabric/            Python.
Автоматизируем деплой и рутину с Fabric / Мастерская интернет-разработчика
     https://habrahabr.ru/post/141271/                    Fabric — пара
прикладных рецептов / Хабрахабр

supervisor:
     http://docs.mirocow.com/doku.php?id=python:supervisor        
Supervisor by python - Python
     http://supervisor.readthedocs.io/en/latest/         Supervisor: A
Process Control System — Supervisor 4.0.0.dev0 documentation

Про статику в джанге:
     https://djbook.ru/rel1.9/intro/tutorial06.html Создаём своё первое
приложение с Django, часть 6 — Документация Django 1.9
     https://djbook.ru/rel1.9/howto/static-files/ Работа со статическими
файлами (например изображения, JavaScript, CSS) — Документация Django 1.9


Небольшое отступление по поводу английского:

Английский в IT важен, т.к. почти вся полезная инфа на английском -
во-первых, она появляется гораздо раньше, чем это все переведут,
во-вторых, многие вещи не перевели до сих пор и даже не собираются; все
лучшие книжки по джанге в основном на английском; на русском есть две
книги по джанге 1.0 (2008 года, есличе), а уже есть версия 2.0 с кучей
новых интересных фишек; и помоему еще одна книжка есть на русском; все
самое вкусное - не переводилось;

Еще пример к этому: различие русской и английской доки, на примере джанги:

Обратите внимание, при использовании своего экземпляра AdminSite,
возможно, вы не захотите отключить автоматический поиск модулей admin и
регистрацию их в стандартной админке. Для этого укажите
'django.contrib.admin.apps.SimpleAdminConfig' вместо
'django.contrib.admin' в настройке INSTALLED_APPS.

If you are using a custom AdminSite, it is common to import all of the
ModelAdmin subclasses into your code and register them to the custom
AdminSite. In that case, in order to disable auto-discovery, you should
put 'django.contrib.admin.apps.SimpleAdminConfig' instead of
'django.contrib.admin' in your INSTALLED_APPS setting.


В русском "НЕ ЗАХОТИТЕ отключить", в английском наоборот; а потом ищи,
что не так работает )