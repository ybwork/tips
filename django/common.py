'''
	Оглавление:

		Модели

		Один ко многим

		Многие ко многим

		Один к одному

		Связь моделей из разных модулей

		Мета настройки

		Менеджер модели

		Методы модели

		Наследование моделей

		Абстрактные модели

		Multi-table наследование

		Proxy-модели

		Множественное наследование

		Переопределение полей при наследовании
'''

# Модели
'''
	Обычно одна модель представляет одну таблицу в базе данных.

	Каждая модель это класс унаследованный от models.Model.

	Атрибут модели представляет поле в базе данных.

	Команды для работы с моделями:

		python manage.py makemigrations

		python manage.py migrate

	Чтобы миграции выполнились нужно подключить приложение в INSTALLED_APPS.

	Каждое поле в вашей модели должно быть экземпляром соответствующего Field класса.

	Поле первичного ключа доступно только для чтения. Если вы поменяете значение первичного ключа для существующего объекта, а зачем сохраните его, будет создан новый объект рядом с существующим.

	Для переопределения первичного ключа просто укажите primary_key=True для одного из полей. При этом Django не добавит поле id.

	Каждое поле, кроме ForeignKey, ManyToManyField и OneToOneField, первым аргументом принимает необязательное читабельное название. Если оно не указано, Django самостоятельно создаст его, используя название поля, заменяя подчеркивание на пробел.

	ForeignKey, ManyToManyField и OneToOneField первым аргументом принимает класс модели, поэтому для того чтобы задать имя полю используется keyword аргумент verbose_name.

	Название поля не может быть слово зарезервированное Python.

	Название поля не может содержать несколько нижних подчеркиваний.

	Если ни одно существующее поле не удовлетворяет вашим потребностям, или вам необходимо использовать какие-либо особенности поля, присущие определенной базе данных - вы можете создать собственный тип поля.
'''
class Person(models.Model):
	SHIRT_SIZES = (
        ('S', 'Small'),
        ('M', 'Medium'),
        ('L', 'Large'),
    )
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES) # позволяет выбирать значение для поля и автоматически создаёт select на его основе
    first_name = models.CharField(max_length=30)
    poll = models.ForeignKey(
	    Poll,
	    on_delete=models.CASCADE,
	    verbose_name="the related poll",
	)

# Один ко многим
'''
	Для определения связи многое-к-одному используется models.ForeignKey.

	Для ForeignKey необходимо указать класс связанной модели. Желательно, но не обязательно, чтобы название ForeignKey поля было названием модели в нижнем регистре.

	Для создания рекурсивной связи – объект со связью многое-к-одному на себя или связь на модель, которая еще не определена, вы можете использовать имя модели вместо класса.
'''
class Manufacturer(models.Model):
    pass

class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)

class Car(models.Model):
    manufacturer = models.ForeignKey(
        'Manufacturer',
        on_delete=models.CASCADE,
    )

class Manufacturer(models.Model):
    pass

'''
	ForeignKey принимает дополнительные аргументы, которые определяют, как должна работать связь.

	on_delete=models.CASCADE - удаляет объекты, связанные через ForeignKey

	on_delete=models.PROTECT - препятствует удалению связанного объекта 

	on_delete=models.SET_NULL - устанавливает ForeignKey в NULL, возможно только если null равен True

	on_delete=models.SET_DEFAULT - устанавливает ForeignKey в значение по умолчанию, значение по-умолчанию должно быть указано для ForeignKey

	on_delete=models.SET - устанавливает ForeignKey в значение указанное в SET()
'''

# Многие ко многим
'''
	Для определения связи многие-ко-многим, используйте ManyToManyField.

	Для ManyToManyField необходимо указать обязательный позиционный аргумент: класс связанной модели.

	Так же, как и с ForeignKey, вы можете создать рекурсивную связь (объект со связью многие-ко-многим на себя) и связь с моделью, которая еще неопределенна.

	Обычно, ManyToManyField необходимо добавить в модель, которая будет редактироваться в форме. В примере выше, toppings добавлено в Pizza (вместо того, чтобы добавить поле pizzas типа ManyToManyField в модель Topping), потому что обычно думают о пицце с ингредиентами, а не об ингредиентах в различных пиццах. В примере выше, форма для Pizza позволит пользователям редактировать ингредиенты для пиццы.

	Django позволяет определить модель для хранения связи многие-ко-многим и дополнительной информации. Эту промежуточную модель можно указать в поле ManyToManyField используя аргумент through, который указывает на промежуточную модель. В промежуточной модели необходимо добавить внешние ключи на модели, связанные отношением многие-ко-многим. Эти ключи указывают как связаны модели.

	Промежуточная модель должна содержать только одну связь с исходной моделью
'''
class Topping(models.Model):
    pass

class Pizza(models.Model):
    toppings = models.ManyToManyField(Topping, through='History')

class History(models.Model):
	topping = models.ForeignKey(Topping, on_delete=models.CASCADE)
    pizza = models.ForeignKey(Pizza, on_delete=models.CASCADE)
	description = models.CharField(max_length=255)

# Один к одному
'''
	Для определения связи один к одному используется OneToOneField.

	Для OneToOneField необходимо указать обязательный позиционный аргумент: класс связанной модели.

	Создаются 2 таблицы. Например таблица с водителями (drivers) и таблица с машинами (cars). У одной машины может быть только один водитель. Соответственно в таблице cars будет поле driver_id.

	Или другой пример, где у ресторана может быть только одно место.
'''
class Place(models.Model):
    name = models.CharField(max_length=50)

class Restaurant(models.Model):
    place = models.OneToOneField(
        Place,
        on_delete=models.CASCADE,
        primary_key=True,
    )
    serves_pizza = models.BooleanField(default=False)

# Связь моделей из разных модулей
'''
	Для этого, импортируйте связанную модель перед определением главной модели и используйте как аргумент для поля.
'''
from geography.models import ZipCode

class Restaurant(models.Model):
    zip_code = models.ForeignKey(
        ZipCode,
        on_delete=models.SET_NULL,
    )

# Мета настройки
'''
	Дополнительные настройки для модели можно определить через class Meta.
'''
class Car(models.Model):
    number = models.IntegerField()

    class Meta:
        ordering = ['id'] # сортировка
        verbose_name_plural = 'super_cars' # переопределение названия таблицы

# Менеджер модели
'''
	Менеджер модели - это интерфейс, через который Django выполняет запросы к базе данных и получает объекты. Если собственный Manager не указан, название по умолчанию будет objects.
'''

# Методы модели
'''
	Методы модели работают с конкретной записью в таблице.

	Это хороший подход для хранения бизнес логики работы с данными в одном месте, то есть в модели.
'''
class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()

    def baby_boomer_status(self):
        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Baby boomer"
        else:
            return "Post-boomer"

'''
	Методы, которые автоматически добавляются в модель и которые можно переопределить:

	__str__ - использует для отображения объектов в интерфейсе администратора Django и в качестве значения, вставляемого в шаблон, при отображении объекта.

	__eq__ - проверяет объекты, если два объекта содержат одинаковый первичный ключ и являются экземплярами одно класса, тогда они равны.

	__hash__ - использует значение первичного ключа

	get_absolute_url - используется для вычисления урла объекта и интерфейсе администратора для указания ссылки 'показать на сайте', которая приведет к странице отображения объекта. Хорошая практика использовать get_absolute_url() в шаблонах.

	get_foo_display() - для каждого поля, которое содержит choices, объект будет иметь метод get_foo_display(), где foo имя поля. Этот метод возвращает удобное для восприятия название для значения поля.

	Также можно переопределить методы save и delete.
'''
super(Blog, self).save(*args, **kwargs)

# Наследование моделей
'''
	Базовый класс модели должен наследоваться от models.Model.

	Также нужно определить должна ли родительская модель быть независимой моделью (с собственной таблицей в базе данных), или же это просто контейнер для хранения информации, доступной только через дочерние модели.
'''

# Абстрактные модели
'''
	Абстрактные модели удобны при определении общих, для нескольких моделей, полей.

	Для этой модели не будет создана таблица в базе данных.
	
	Если дочерний класс не определяет собственный класс Meta, он унаследует родительский класс Meta. 

	Если дочерняя модель хочет расширить родительский Meta класс, она может унаследовать его. 

	Используя атрибут related_name для ForeignKey или ManyToManyField, вы должны всегда определять уникальное название для обратной связи.
'''
class CommonInfo(models.Model):
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

    class Meta:
        abstract = True

class Student(CommonInfo):
    home_group = models.CharField(max_length=5)

    class Meta(CommonInfo.Meta):
        db_table = 'student_info'

# Multi-table наследование
'''
	Каждая модель будет независимой и 

	Каждая модель имеет собственную таблицу в базе данных и может быть использована независимо. 
	
	Наследование использует связь между родительской и дочерней моделью (через автоматически созданное поле OneToOneField).

	Дочерняя модель не имеет доступа к родительскому классу Meta.
'''
class Place(models.Model):
    name = models.CharField(max_length=50)
    address = models.CharField(max_length=80)

# Все поля Place будут доступны и в Restaurant, в то время как данные будут храниться в разных таблицах
class Restaurant(Place):
    serves_hot_dogs = models.BooleanField(default=False)
    serves_pizza = models.BooleanField(default=False)

    class Meta:
    	# Если родительская модель определяет сортировку, но вы не хотите ее наследовать в дочерней модели, вы можете указать это таким способом
    	ordering = []

# Proxy-модели
'''
	Proxy-модели используются для переопределения поведения модели не меняя структуры базы данных.

	Другими словами можно изменить сортировку по-умолчанию или менеджер по умолчанию в proxy-модели, без изменения оригинальной модели.

	Proxy-модели создаются так же, как и обычная модель. Указать что это proxy-модель можно установив атрибут proxy в классе Meta в True.

	Вы не можете унаследоваться от нескольких не абстрактных моделей т.к. proxy-модель не может хранить информации о полях в нескольких таблицах базы данных.

	Proxy-модель может наследоваться от нескольких абстрактных моделей при условии, что они не определяют поля модели.

	Если вы не определите ни один менеджер для proxy-модели, он будет унаследован от родительской модели. 
'''
class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

# Модель MyPerson использует ту же таблицу в базе данных, что и класс Person. Также каждый новый экземпляр модели Person` будет доступен через модель MyPerson, и наоборот.
class MyPerson(Person):
    class Meta:
    	ordering = ['last_name']
        proxy = True

    def do_something(self):
        pass

# Множественное наследование
'''
	В большинстве случаев вам не нужно будет использовать множественное наследование. В основном множественное наследование используют для “mix-in” классов: добавление дополнительных полей и методов для каждой модели унаследованной от mix-in класса. Старайтесь содержать иерархию наследования настолько простой и понятной, насколько это возможно, чтобы не возникало проблем с определением, откуда взялась та или другая информация.
'''

# Переопределение полей при наследовании
'''
	В Python можно переопределять атрибуты класса-родителя в дочернем классе. В Django это запрещено для атрибутов, которые являются экземплярами Field. Если родительская модель имеет поле author, вы не можете создать поле с именем author в дочерних моделях.
'''