Введение в модели. (Introduction to models)

	Абстрактные модели удобны при определении общих, для нескольких моделей, полей.

	Multi-table наследование это когда каждая модель имеет собственную таблицу в базе данных и может быть использована независимо, но есть наследование, которое использует связь между родительской и дочерней моделью.

	Proxy-модели

	Так же, как и наследование в Python, можно использовать множественное наследование моделей Django.

Справочник по полям модели. (Field types)

	Избегайте использования null для строковых полей таких, как CharField и TextField, т.к. пустое значение всегда будет сохранено как пустая строка, а не NULL.

	Значение по умолчанию для поля не может быть изменяемым значением (экземпляр модели, список, множество и т.д.), т.к. все объекты модели будут ссылаться на этот объект и использовать его как значение по умолчанию. Вместо этого укажите функцию, которая возвращает нужное значение.

	Модель может содержать только один первичный ключ.

	Заметим что, при unique равном True, не нужно указывать db_index, т.к. unique создает индекс.

	DurationField поле для хранения периодов времени.

	В FileField primary_key и unique не принимаются, и вызовут исключение TypeError при использовании. Если вы используйте бэкенд по умолчанию FileSystemStorage, значение будет добавлено к MEDIA_ROOT, чтобы сформировать путь в файловой системе для сохранения файла.

	Заметим, что при загрузке файлов, вы должны обращать внимание, куда вы загружаете файлы и какие типы файлов загружаются, чтобы предотвратить возможные уязвимости в защите системы. Проверяйте все загружаемые файлы. Например, если вы разрешите загрузить файл без проверки в каталог, который обрабатывается сервером, кто-нибудь сможет загрузить CGI или PHP скрипт и выполнить его, посетив его URL на вашем сайте. Не допускайте это.

	Используете NullBooleanField вместо BooleanField с null=True. Форма использует виджет NullBooleanSelect.

	Справочник по полям модели: db_type(), get_prep_value(value), from_db_value(value, expression, connection, context), pre_save(model_instance, add)...

Настройки модели. (Meta options)

	order_with_respect_to. Объекты модели будут отсортированы относительно указанного поля. Почти всегда используется для ForeignKey.

	Сортировка не бесплатная операция. Каждое поле влияет на скорость выполнения запроса. Каждый внешний ключ добавит сортировку по умолчанию связанной модели.

Выполнение запросов. (Making queries)

	Чтобы создать и сохранить объект используйте метод create(), потому что метод save() ничего не возвращает.

	Для обновления объекта, который уже существует в базе данных, используйте save().

	Для получения объектов из базы данных, создается QuerySet через Manager модели.

	В примерах выше мы использовали фильтры, которые сравнивали поля с определенными значениями(константами). Но что, если вы хотите сравнить одно поле с другим полем одной модели? Django предоставляет класс F для таких сравнений.

	Помните о кэшировании, чтобы использовать QuerySet правильно. Например, этот код создаст два экземпляра QuerySet и вычислит их не сохраняя:

		print([e.headline for e in Entry.objects.all()])
		print([e.pub_date for e in Entry.objects.all()])

	Это означает, что один и тот же запрос будет выполнен дважды, удваивая нагрузку на базу данных. Также, есть вероятность, что списки могут содержать разные результаты, потому что запись Entry может быть добавлена или удалена в доли секунды между запросами. Чтобы избежать этой проблемы, просто сохраните QuerySet и используйте его повторно:

		queryset = Entry.objects.all()

		print([p.headline for p in queryset])
		print([p.pub_date for p in queryset])

	Queryset не всегда кэширует результаты. Например, при получении объекта по индексу несколько раз будет каждый раз выполнять запрос к базе данных. 

	Однако, если уже был загружен весь queryset, он будет использоваться для получения значения:

		queryset = Entry.objects.all()
		[entry for entry in queryset]
		print queryset[5]
		print queryset[5]

	Если вам нужны более сложные запросы (например, запросы с оператором OR), вы можете использовать объекты Q.

	Для сравнения двух экземпляров модели, используйте стандартный оператор сравнения Python, двойной знак равно: ==.

	Если вы хотите сохранить каждый объект в QuerySet и удостовериться что метод save() вызван для каждого объекта, вы не должны использовать какой-либо специальный метод. Просто используйте цикл и вызовите метод save():

		for item in my_queryset:
    		item.save()

    Все происходит при регистрации приложений. Когда запускается Django, происходит импорт всех приложений из INSTALLED_APPS, далее импорт модуля models этих приложений. Когда создается класс модели, Django добавляет обратные связи для всех связанных моделей. Если связанная модель еще не импортирована, Django запоминает эту модель и добавит связь при ее импорте. Поэтому важно, чтобы все модели, которые вы используете, находились в приложениях из INSTALLED_APPS. Иначе связи не будут работать.

Оптимизация работы БД.

	Первым делом определите какие запросы выполняются и как быстро. Вы также можете использовать сторонние приложения, например, django-debug-toolbar, или инструменты, которые мониторят непосредственно базу данных.

	Используйте стандартные техники оптимизации БД: 

		Индексы. Следует добавить индексы полям, которые используются в filter(), exclude(), order_by() и др., т.к. они ускоряют поиск по полям.

	Как и кэширование всего QuerySet, существует кэширование значения атрибутов в объектах ORM.
		
		entry = Entry.objects.get(id=1)
		entry.blog - запрос к бд
		entry.blog - нет запроса, значение из кэша

	Но обращение к вызываемым атрибутам каждый раз выполняет запрос к базе данных:

		entry = Entry.objects.get(id=1)
		entry.authors.all() - запрос к бд
		entry.authors.all() - запрос к бд

	Выполняйте задачи базы данных в базе данных, а не в Python: фильтрация, агрегация, склейка и т.д.

	Используйте QuerySet.exists() если необходимо проверить есть ли результат, вместо if queryset. Используйте QuerySet.count() вместо len() если необходимо узнать только количество записей в выборке. Но не переусердствуйте с count() и exists(). Например этот код лучше потому что делает один или ноль запросов, а если бы там была проверка с помощью count и exists, то ещё дополнительные два:

		{% if display_inbox %}
		  {% with emails=user.emails.all %}
		    {% if emails %}
		      <p>You have {{ emails|length }} email(s)</p>
		      {% for email in emails %}
		        <p>{{ email.body }}</p>
		      {% endfor %}
		    {% else %}
		      <p>No messages today.</p>
		    {% endif %}
		  {% endwith %}
		{% endif %}		

	Используйте RawSQL, который позволяет добавить SQL непосредственно в запрос.

	Используйте собственный SQL запрос для получения данных и загрузки в модели.

	Использовать поле с unique или db_index в методе get(), потому что запрос будет быстрее.

	Загружайте все данные сразу, если уверены, что будете использовать их. Обращение несколько раз к базе данных для получения различных частей одного “массива” данных обычно менее эффективно, чем получение всех данных одним запросом. Это особенно важно для запросов, выполняемых в цикле, что может привести к большому количеству запросов. 

	Не получайте данные, которые вам не нужны. Если вам нужен dict или list значений, а не объекты моделей ORM, используйте values(). Используйте defer() и only(), если есть колонки в базе данных, которые вы не будете использовать. Запомните, что если вы все же будете их использовать, ORM сделает дополнительный запрос для их получения, что уменьшит производительность.

	В шаблонах для использования кэширования в QuerySet можно использовать шаблонный тэг with. (with emails=user.emails.all) Тег with означает что мы сохраняем user.emails.all в переменной для последующего использования.

	Использовать массовое удаление и обновление через QuerySet.update() и delete()

	Если вам необходимо только значение внешнего ключа, используйте его, т.к. оно уже в объекте, который вы получили: entry.blog_id, а вот так плохо (entry.blog.id), потому что выполняется дополнительный запрос.

	Не сортируйте данные, если вам это не требуется. Сортировка требует ресурсы.

	При создании множества объектов, если возможно, используйте метод bulk_create() чтобы сократить количество SQL запросов. Это относится и к ManyToManyFields - my_band.members.add(me, my_friend).

Безопасность.
	
	XSS атаки позволяют пользователю вставить собственные JS скрипты в браузеры других пользователей. Использование шаблонов Django защищает вас от большинства XSS атак. И хотя экранирование защищает пользователя от большинства видов вредоносного ввода, оно не является панацеей. Например, оно не защитит от такого: <style class={{ var }}>...</style>

	CSRF атаки позволяют недобросовестному пользователю выполнять действия от имени другого пользователя, без ведома последнего или его согласия. Например отправлять форму от имени авторизованного пользователя. Django обладает встроенной защитой против большинства типов CSRF атак, если вы активировали и использовали её там, где это необходимо.

	Внедрение SQL — это тип атаки, когда недобросовестный пользователь имеет возможность выполнить в базе данных определённый SQL запрос. Результатом выполнения такого запроса может быть удаление или даже утечка данных. При использовании Django ORM созданный SQL запрос будет правильно экранирован соответствующим драйвером базы данных.

	Защита от скликивания. Django предоставляет защиту от этой атаки в виде модуля X-Frame-Options, который, при использовании соответствующего браузера, может предотвратить отображение сайта внутри фрейма.

	Если вам нужна защита, предоставляемая HTTPS, и на сервере произведена соответствующая настройка ПО, то надо выполнить ещё несколько шагов, чтобы быть уверенным в защите своей информации: 

		При необходимости, установите параметр конфигурации SECURE_PROXY_SSL_HEADER, чтобы показать, что вы поняли все предупреждения. Отказ от этого может привести к CSRF проблемам, а отказ сделать это правильно также может быть опасен!

		Настройте перенаправление HTTP запросов на HTTPS, указав True в SECURE_SSL_REDIRECT.

		Если браузер изначально подключается через HTTP, что характерно для большинства браузеров, есть возможность утечки существующих кук. По этой причине вам сделать установить параметры SESSION_COOKIE_SECURE и CSRF_COOKIE_SECURE в True. Это заставить браузер отправлять такие куки только через HTTPS. Следует отметить, это сделает невозможным работу сессий через HTTP, а CSRF защита не будет принимать POST данные, полученные через HTTP (это решается с помощью перенаправления HTTP трафика через HTTPS)

		HSTS является HTTP заголовком, который информирует браузер, что все следующие соединения к конкретному сайту всегда должны использовать HTTPS. Дополняя это перенаправлением HTTP запросов на HTTPS, мы получаем дополнительную защиту от использования SSL. HSTS может быть настроен с помощью настроек SECURE_HSTS_SECONDS и SECURE_HSTS_INCLUDE_SUBDOMAINS, или на web-сервере.

	Проверка заголовка хоста. Для подробностей смотрите полную документацию на параметр конфигурации ALLOWED_HOSTS.

	Если ваш сайт принимает файлы, настоятельно советуем ограничить размер таких загрузок в конфигурации веб сервера для предотвращения атак на отказ сервиса (DOS). В случае Apache это легко можно сделать с помощью директивы LimitRequestBody.

	Если вы самостоятельно раздаете статические файлы, убедитесь, что обработчики, как mod_php в Apache, который будет выполнять статические файлы в виде кода, будут отключены. Вы же не хотите, чтобы пользователи могли выполнить произвольный код путем загрузки и запроса специально созданного файла.

	Обработка загрузки медиа файлов в Django имеет некоторые уязвимости, если медиа файлы раздаются без учета некоторых правил безопасности. В частности, HTML файл может быть загружен в виде изображения, если этот файл содержит правильный заголовок PNG с последующим вредоносным HTML. Этот файл будет проходить проверку библиотеками, которые Django использует для обработки изображений (Pillow) в ImageField. Когда этот файл впоследствии отображается для пользователя, он может отображаться как HTML в зависимости от типа и конфигурации веб-сервера. Не существует идеального технического решения на уровне Django для безопасной проверки всех типов файлов, которые могут загрузить другие пользователи. Однако, можно предпринять некоторые другие способы, чтобы обезопасить себя от атаки:

		Один класс атак можно предотвратить путем раздачи медиа файлов с отдельного домена верхнего уровня или второго уровня.

		Помимо этого, приложения могут определять белый список допустимых расширений файлов для загружаемых пользователем файлов и настроить веб-сервер чтобы раздавать только такие файлы.

	Несмотря на то, что Django предоставляет защиту прямо из коробки, правильная установка вашего приложения всё ещё имеет значение. Также важно иметь правильно настроенный веб сервер, операционную систему и другие компоненты.

		Код вашего приложения должен находиться вне корня веб сервера. Это не позволит случайно отобразить его в виде текста или выполнить его.

		Будьте осторожны с любыми файлами, которые загружены пользователями.

		Django не ограничивает количество запросов при аутентификации пользователей. Для того, чтобы защититься от перебора логина/пароля, вы можете поставить дополнительное приложение для Django или модуль для веб сервера, чтобы ограничивать такие запросы.

		Храните содержимое параметра SECRET_KEY в секрете.

		Хорошей идеей будет ограничить доступ к вашей системе кэширования и к базе данных с помощью фаервола.

	Золотое правило безопасного веб приложения – это никогда не доверять данным из чужих источников. Временами передача данных через недоверенную среду может оказаться полезной. Криптографически подписанные значения могут безопасно передаваться через недоверенный канал, если известно, что любая подмена данных будет обнаружена.

	Django предоставляет низкоуровневое API для подписывания значения и высокоуровневое API для установки и чтения подписанных кук, одного из наиболее часто используемых функционалов подписи в веб приложениях.

	Вы также можете найти подпись полезной для следующего:

		Генерация URL для восстановления аккаунта пользователя, которые будут отправлены пользователю, потерявшему свой пароль.

		Проверка целостности данных, спрятанных в скрытом поле формы.

		Генерация одноразового секретного URL для обеспечения временного доступа к защищённому ресурсу, например на скачивание файла за который заплатил пользователь.

Вопросы:

	Когда использовать обратную взязь? (рекурсивную)

	Что такое связь на себя?






