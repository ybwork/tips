<?php

/*
	Структуры данных - это способы хранить и организовывать данные, чтобы эффективней решать различные задачи.

	Алгоритм — последовательность совершаемых действий.

	Структуры данных реализованы с помощью алгоритмов, алгоритмы — с помощью структур данных. Всё состоит из структур данных и алгоритмов, вплоть до работы копмьютера.

	Структуры данных позволяют производить 4 основных типа действий: доступ, поиск, вставку и удаление.

	Для сравнения производительности алгоритмов используется грубое измерение средней производительности и производительности в худшем случае, для обозначения которых используется термин «О». Значения О:

		O(1) - константная (охрененно)

		O(log N) - логарифмическая (круто)

		O(N) - линейная (нормас)

		O(N log N) - линейно-логарифмическая (блииин)

		O(N ^ 2) - полиномиальная (отстой)

		O(2 ^ N) - экспоненциальная (отвратительно)

		O(N!) - факториальная (твою ж мать)

	В языках программирования отсчёт начинается с 0 — потому, что так работает память. Чтобы прочитать первый фрагмент памяти, вы читаете с 0 до 1, второй — с 1 до 2 и т.д.

	Использование памяти — сложная задача, и для удобной работы с ней существуют дополнительные уровни абстракции. Абстракции имеют два дополнительных назначения:

		- Сохраняют данные в памяти таким образом, чтобы с ними было эффективно и быстро работать.

		- Сохраняют данные в памяти так, чтобы их было проще использовать.
*/

/*
	Standard PHP Library (SPL) — Часть 1: Структуры данных (https://habrahabr.ru/post/161987/)

	В библиотеке SPL содержатся такие структуры данных:

		SplDoublyLinkedList — Двусвязные списки.

		SplStack — Стек

		SplQueue — Очередь

		SplHeap — Куча

		SplMaxHeap — Сортировка кучи по убыванию

		SplMinHeap — Сортировка кучи по возрастанию

		SplPriorityQueue — Приоритетные очереди

		SplFixedArray — Массив с ограниченной длиной

		SplObjectStorage — Хранилище объектов 
*/


/*
	SplStack — Стек

		Стек, обычно, описывают как некий набор объектов, который сгруппирован вместе, где каждый элемент общего набора идет друг за другом — стопка книг или же подносы. 

		Последний объект, помещенный в стек, извлекается первым из общего списка. Этот метод называется LIFO (первый зашел, первый ушел).

		Первый объект, помещенный в стек, извлекается первым из общего списка. Этот метод называется FIFO (первый вошел, первый вышел).

		Базовые операции, определяющие стек:

			- Создание

			- Добавление элемента в начало

			- Извлечение и удаление элемента из вершины

			- Получить первый элемент не удаляя

			- Проверка на пустоту 
		
		Когда стек больше не может принимать элементы, то стек является переполненным и он возвращает сообщение об этом (stack overflow). Ну и обратная ситуация — изъятие элемента из пустого стека (stack underflow).
*/
$stack = new SplStack();

$stack->push('1');
$stack->push('2');
$stack->push('3');

$stack->count();
$stack->top();
$stack->bottom();
$stack->serialize();

$stack->pop();

/*
	SplQueue — Очередь.

	Очередь - это абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел». Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди), при этом выбранный элемент из очереди удаляется.

	Очередь в программировании используется, как и в реальной жизни, когда нужно совершить какие-то действия в порядке их поступления, выполнив их последовательно. Примером может служить организация событий в Windows. Когда пользователь оказывает какое-то действие на приложение, то в приложении не вызывается соответствующая процедура (ведь в этот момент приложение может совершать другие действия), а ему присылается сообщение, содержащее информацию о совершенном действии, это сообщение ставится в очередь, и только когда будут обработаны сообщения, пришедшие ранее, приложение выполнит необходимое действие.

	Базовые операции:

		- Создание

		- Добавление элемента в конец (хвост очереди)

		- Удаление элемента из начала (голова) 

		- Получить первый элемент не удаляя

		- Проверка на пустоту 
*/
$queue = new SplQueue();

$queue->setIteratorMode(SplQueue::IT_MODE_DELETE);

$queue->enqueue('one');
$queue->enqueue('two');
$queue->enqueue('qwerty');

$queue->dequeue();
$queue->dequeue();

$queue->top();

/*
	SplHeap - куча.

	Куча - это специализированная структура данных типа дерево.

	Кучи обычно реализуются в виде массивов.

	От SplHeap наследуются два класса: SplMaxHeap – для сортировки массива по убыванию его значений, SplMinHeap – для сортировки массива по возрастанию.

	Над кучами обычно проводятся следующие операции:

		- найти максимум или найти минимум

		- удалить максимум или удалить минимум

		- увеличить ключ или уменьшить ключ

		- добавление нового ключа в кучу

		- соединение двух куч с целью создания новой кучи
*/
$heap = new SplMaxHeap();

$heap->insert('111');
$heap->insert('666');
$heap->insert('777');

// 777
$heap->extract();
// 666
$heap->extract();
// 111
$heap->extract();

$heap = new SplMinHeap();

$heap->insert('111');
$heap->insert('666');
$heap->insert('777');

// 111
$heap->extract();
// 666
$heap->extract();
// 777
$heap->extract();

/*
	SplPriorityQueue — очередь с приоритетом.

	Очередь с приоритетом - абстрактный тип данных в программировании, поддерживающий две обязательные операции — добавить элемент и извлечь максимум.

	В качестве примера очереди с приоритетом можно рассмотреть список задач работника. Когда он заканчивает одну задачу, он переходит к очередной — самой приоритетной (ключ будет величиной, обратной приоритету) — то есть выполняет операцию извлечения максимума. Начальник добавляет задачи в список, указывая их приоритет, то есть выполняет операцию добавления элемента.

	Основные методы, реализуемые очередью с приоритетом, следующие:

		- Добавить элемент

		- Извлечь пару с максимальным значением ключа и удалить её из хранилища
*/
$queue = new SplPriorityQueue();

$queue->insert('Q', 1);
$queue->insert('W', 2);
$queue->insert('E', 3);
$queue->insert('R', 4);
$queue->insert('T', 5);
$queue->insert('Y', 6);

$queue->top();

/*
	FixedArray - массив с ограниченной длиной.

	Это массив с фиксированным количеством элементов. Данный вид массива работает быстрее, чем обычные массивы, но существуют некоторые ограничении: 

		- в качестве ключей могут быть только целые числа > 0
		
		- длина может быть изменена, но это затратная операция

	Данная структура хорошо подходит для нумерованных списков.
*/
$a = new SplFixedArray(10000);

$count = 10000;

for ($i = 0; $i < $count; $i++) {
	$a[$i] = $i;

	if ($i === 9999) {
		$a->setSize(100000);
	}
}

/*
	SplObjectStorage — Хранилище объектов.

	Данная структура представляет собой хранилище объектов. Объекты можно прикреплять к хранилищу, удалять, получать текущий объект.
*/
$storage = new SplObjectStorage();

$o1 = new StdClass();
$o2 = new StdClass();
$o3 = new StdClass();

// прикрепляем к хранилищу объект
$storage->attach($o1); 
$storage->attach($o2);

// проверяет, содержит ли контейнер заданный объект
var_dump($storage->contains($o1));

// открепляем объект от хранилища
$storage->detach($o2);


/*
	Структуры данных в PHP 7.

	PHP имеет всего одну структуру данных для управления всем - это массив.

	Эффективные структуры данных для PHP 7, представленные как альтернативы для типа array.

	php-ds — расширение для PHP7, добавляющее структуры данных.

	Ссылка из официальной документации - http://php.net/manual/ru/book.ds.php

	Виды:

		- Collection (Коллекция)

			Collection — это базовый интерфейс, охватывающий общую функциональность: foreach, echo, count, print_r, var_dump, serialize, json_encode, и clone.

		- Sequence (Последовательность)

			В некоторых языках такая структура назвается List (список). Подобен array, который использует инкрементальные ключи, за исключением некоторых особенностей:

				- Значения всегда должны быть индексированы как [0, 1, 2, …, size - 1]

				- Извлечение или добавление приводит к обновление индекса всех последовательных значений

				- Поддерживает доступ к значениям только из индекса [0, size - 1]

			Данную структура можно использовать везде, где вы бы хотели использовать array как список (без ключей). Так же это более эффективная альтернатива SplDoublyLinkedList и SplFixedArray.

		- Vector (Вектор)

			Vector представляет собой последовательность, объединяющую значения в непрерывный буфер, увеличивающийся и уменьшающийся автоматически. Это наиболее эффективная последовательная структура данных, поскольку индекс элемента является прямым отражением его индекса в буфере, и увеличение вектора никак не повлияет на производительность.

			Если вы точно знаете, что не будете использовать shift и unshift, используйте Vector.

			Сильные стороны:

				- Очень маленькое потребление памяти

				- Очень быстрые итерации

				- get, set, push и pop имеют сложность O(1)

			Слабые стороны:

				- insert, remove, shift and unshift имеют сложность O(n)

		- Deque (Двусвязная очередь, произноситься как deck) 

			Это последовательность значений, объединенных в непрерывный буфер, увеличивающийся и уменьшающийся автоматически.

			Два указателя используется для отслеживания головы и хвоста. Наличие указателей позволяет изменять конец и начало буфера без необходимости перемещать другие элементы для освобождения места. Это делает shift и unshift настолько быстрым, что даже Vector не может конкурировать с этим.

			Сильные стороны:

				- Очень маленькое потребление памяти

				- get, set, push, pop, shift и unshift имеют сложность O(1)

			Слабые стороны:

				- insert, remove имеют сложность O(n)

				- Емкость буфера должна иметь степень двойки

		- Stack (Стек)

			Стек — является коллекцией, организованной по принципу «последним пришёл — первым вышел» или «LIFO».

		- Queue (Очередь)

			Очередь — тип данных с парадигмой доступа к элементам «первый пришел — первый вышел» («FIFO», «First In — First Out»). Такая коллекция позволяет получить доступ к элементам в порядке их добавления.

		- PriorityQueue (Очередь с приоритетом)

			Очередь с приоритетом очень похожа на простую очередь. Элементы помещаются в очередь с указанным приоритетом и значение с наивысшим приоритетом всегда будет в передней части.

			Работает более чем в два раза быстрее чем SplPriorityQueue и использует только 5% от его памяти.

		- Hashable

			Интерфейс, позволяющий объектам быть использованными в качестве ключей. Это альтернатива spl_object_hash, который детерминирует объект в хэш, базирующийся на его handle:. Это означает, что два объекта, которые считались бы равными при сравнении, не имели бы равный хэш, т.к. они не являются одним и тем же экземпляром.

			Hashable вводит только два метода: hash и equals.

		- Map (Ассоциативный массив)

			Map является последовательной коллекцией пар ключ-значение, практически идентичной array в аналогичном контексте. Ключи могут быть любого типа, единственное условие — уникальность. При повторном добавлении ключа значения заменяются.

			Сильные стороны:

				- Производительность и эффективность использования памяти практически идентичны array

				- Автоматическое освобождение памяти при уменьшении размера

				- Ключи и значения могут быть любого типа, включая объекты

				- Поддерживает работу с объектами, реализующими интерфейс Hashable

				- put, get, remove и containsKey имеют сложность O(1)

			Слабые стороны:

				- Не может быть преобразован в array при наличии ключей-объектов

				- Нет возможности получить доступ к значениям по индексу (позиции)

		- Set (Множество)

			Set — коллекция уникальных значений.

			Сильные стороны:

				- add, remove и contains имеют сложность O(1)

				- Поддерживает работу с объектами, реализующими интерфейс Hashable

				- Поддерживает любой тип значений (SplObjectStorage поддерживает только объекты)

				- Имеет эквивалент поразрядных логических операций

			Слабые стороны:

				- Не поддерживает push, pop, insert, shift или unshift

				- get имеет сложность O(n) если есть удаленные значения до момента индексации, в ином случае — O(1)
*/