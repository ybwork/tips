- System.out.print("Hello") выведет сообщение в консоль, сообщение пишем именно в двойных кавычках

- System.out.println("Hello") выведет сообщение в консоль с переводом на новую строку

- переменная может быть типа byte a = 2; Альтернативный синтаксис byte a = 5, b = 7;

- при объявлении переменной ей нужно задавать тип

- байт это целочисленное и поэтому если в результате какой то операции, например 5 / 7, получается число типа float, то при записи в байт все знаки после точки будут отброшенны

- тип int занимает 4 байта

- после компиляции файл с кодом имеет расширение .class

- после модификатора доступа в методе следует тип возвращаемого значения:
	static byte test()
	{
		return 120;
	}

- у метода не пишем static, у функции пишем
	static void check() {} - функция 
	void say() {} - метод

- panasonic_a1 panas = new Panasonic_a1(); В данном случае panas это ссылочная переменная на объект Panasonic_a1

- panas.on() это обращение к методу объекта через ссылочную переменную

- возможно обращение к объекту можно производить только в главном классе приложения

- пакет эта таже папка, в пакете хранятся группы классов

- static void write() {} - статическая функция, который можно вызывать не создавая объект.

- функция от метода отличается только ключевым словаом static

- static void show(byte a) {} стандартная передача аргумента в функцию

- 

static void start(Panasonic_a1 a) {
	a.on();
	a.off();
} 

Panasonic_a1 panas = new Panasonic_a1();

start(panas) - можно передавать в качестве аргумента объект и использовать его внутри


- import newpackage.B; - импорт класса из если он находиться в другой директории нежели main.java (главный класс приложения). newpackage - имя директории в которой лежит файл с классом, B - имя файла с классом

- Модификаторы доступа:
	- Public - доступен везде

	- Protected - доступен внутри пакета и в наследуемых классах

	- Private - доступен только внутри класса
	
	- Default - используется автоматически, если не задаётся модификатор и обозначает, что класс доступен только в этом пакете


- public car() {} - конструктор от метода отличается лишь тем, что не имеет типа возвращаемого значения

	int speed;
	int door;

	public car(int speed, int door)
	{
		this.speed = speed;
		this.door = door;
	}

	Car car = new Car(120, 4);

- Можно создать несколько консрукторова с разным колличеством принимаемых аргументов, но так как интерпретатор сравнивает конструкторы по типам, то 2 конструктора например с тремя передаваемыми аргументами одинакового типа выдаст ошибку

- if (a == 5) {} else if () {} else {} - классическое условие. Если условие одно можно написать так: if (a == 10) break;

- switch (a) {
	case 1:
		System.out.println('hey');
		breack;

	default:
		System.out.println('hey');
		break;
} - классический switch

- a = 0;
	while (a < 10) {
		System.out.println('this is while');
		a++;
	} - классический while

- do {
	System.out.println('this is do-while');
	a++;
} while (a < 10); - отличие в том, что этот сначала делает, а потом проверяет условие. Т.е. первая итерация всегда отработает.

- for (i = 10; i > 0; i--) {} - классический for

- Сеттеры и геттеры 	

	Сеттеры (фишка в том, что когда нужно установить значение для св-в класса и они не должны быть меньше 0, очень хорошо помогают данные вещи)

	Геттеры (фишка в том, что мы внутри класса закрывает св-ва модификатором private, а геттеры дают возможность получить их значение)

	public class Computer 
	{
		private hdd = 0;
		private ram = 0;

		public int functin get_hdd()
		{
			return hdd;
		}

		public void set_hdd(int hdd)
		{
			if (hdd < 0) {
				System.out.println('Данное значение должно быть больше нуля');
			} else {
				this.hdd = hdd;
			}
		}

		public int get_ram()
		{
			return hdd;
		}

		public void set_ram(int ram)
		{
			if (ram < 0) {
				System.out.println('Данное значение должно быть больше нуля');
			} else {
				this.ram = ram;
			}
		}
	}

	public class Tutorial()
	{
		public static void main()
		{
			Computer comp = new Computer();

			comp.set_hdd(128);
			comp.set_ram(512);

			System.out.println(comp.get_hdd());
			System.out.println(comp.get_ram());
		}
	}

- У каждого массива есть тип

- Car[] cars = new Car(10); - определения массива, 10 это кол-во элементов

- byte[] mas = new byte(6); - ещё один вариант определения массива типа byte

- mas[0] = 12; - это наполнение массива

- for(int i = 0; i < cars.length; i++) {} - перебор массива, cars.length - длинна массива

- for(int i = 0; i< cars.length; i++) {
	cars[i] = new Car(); - заполнение массива ссылками на объекты
  }

- int i = 10; byte b = (byte) i; - приведение типов, при этом нужно расчитывать диапазон чтобы число поместилось

- public class Computer {}, public class Notebook extends Computer {} - наследование, нет множественного (есть как в php трейты?)

- @Override - переобпределение метода родителя при наследовании
  void on() {}

- @Override
  void on() {
  	super.on(); - внутри переопределённого метода можно вызвать этот же или любой другой метод родителя
  }

- Все классы без наследования по умолчанию наследуются от встроенного класса Object

- void test() {}, void test(int a) {} - перегрузка метода, если убрать передаваемый параметр во втором методе, то это уже будет ошибка

- у массива может быть тип, например byte

- public abstract class Computer {
	abstract void on();	
	abstract void off();
  } - абстракция это шаблон, в нём так же могут быть реализованные методы, которые не нужно будет реализовывать в классе наследнике. Если в нутри класса есть хоть один абстрактный метод, то он должен быть абстрактным.

- public class Acer extends Computer {
	@Override
	void on() {
		System.out.println('on');
	}

	@Override
	void off() {
		System.out.println('off');
	}	
  } - реализаци абстрактного класса

