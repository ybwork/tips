<?php

/*
    Глава 10. Оптимизация на уровне приложения.
*/

/*
    Поиск источника проблемы.

    Первым делом нужно найти виновного. Это будет гораздо проще сделать, если в приложение встроены средства профилирования.

    Вот перечень того, на что следует обращать внимание:

        - Кто именно потребляет ресурсы процессора, диска, сети и памяти на каждом из составляющих систему компьютеров? Выглядят ли характеристики потребления разумными? Если нет, взгляните при- стальнее на приложения, являющиеся основными «пожирателями» ресурсов.

        - Действительно ли приложение использует все данные, которые получает? Выборка 1000 строк только для того, чтобы вывести 10 из них и отбросить остальные, – очень распространенная ошибка

        - Выполняет ли приложение обработку, которую лучше было бы поручить базе данных, или наоборот? Два примера: выборка всех строк из таблицы для того, чтобы подсчитать их количество, и выполнение сложных манипуляций со строками средствами СУБД. База данных прекрасно справляется с подсчетом строк, тогда как прикладным языкам программирования нет равных в работе с регулярными выражениями.

        - Не выполняет ли приложение слишком много запросов? Часто следует винить интерфейсы на базе объектно-реляционных отображений (ORM), которые «избавляют программиста от необходимости писать SQL-код». Сервер базы данных изначально спроектирован для сопоставления данных из нескольких таблиц. Уберите вложенные циклы из кода и напишите вместо них запрос с соединением таблиц.

        - Не подключается ли приложение к MySQL понапрасну? Если можно получить данные из кэша, зачем устанавливать соединение?

        - Не подключается ли приложение слишком часто к одному и тому же экземпляру MySQL, быть может, потому, что разные его части открывают собственные соединения? Обычно гораздо лучше использовать одно и то же соединение на протяжении всей работы.

        - Не выполняет ли приложение массу «бесполезных» запросов? Типичный пример – выбор требуемой базы данных перед каждым из них.

        - Остаются ли соединения открытыми даже тогда, когда не используются? Если да – особенно при подключении сразу к нескольким серверам, – то, возможно, вы потребляете соединения, которые могли бы пригодиться другим процессам. Пусть, например, приложение подключается к 10 серверам MySQL. Установить 10 соединений из процесса Apache нетрудно, но лишь на одном из них в каждый момент времени происходит что-то полезное.
*/

/*
    Проблемы веб-сервера.

    Использовать:

        Если Apache запущен в универсальной конфигурации и напрямую обслуживает запросы, поступающие из веб, то может быть порождено много тяжеловесных процессов. Это приводит к расточительному расходованию ресурсов веб-сервера. К тому же эти процессы могут открывать много соединений с MySQL, истощая и его ресурсы тоже. Приведем несколько рекомендаций о том, как уменьшить нагрузку на сервера:

            - Не используйте Apache для обслуживания статического содержимого или, по крайней мере, используйте для этой цели отдельный экземпляр Apache. Популярными альтернативами являются lighttpd и nginx.
            
            - Применяйте кэширующий прокси-сервер, например Squid или Varnish, чтобы вообще не допустить запросы до веб-сервера. Даже если на этом уровне невозможно кэшировать страницу целиком, иногда удается кэшировать большую ее часть и воспользоваться технологией Edge Side Includes для включения небольшого динамического фрагмента в кэшированную статическую часть страницы.

            - Задавайте срок хранения для статического и динамического содержимого. Кэширующий прокси-сервер, например Squid, позволяет явно сделать содержимое недействительным. На сайте Википедии эта техника применяется для удаления измененных статей из кэша.

            - Включайте gzip-сжатие. Для современных процессоров эти накладные расходы ничтожны, зато позволяют сильно сэкономить на трафике. Если вы все же не хотите загружать процессор сжатием, то можете кэшировать сжатые версии страниц и обслуживать их с помощью облегченного веб-сервера, например lighttpd.

            - Не включайте в Apache режим Keep-Alive для соединений на больших расстояниях, поскольку в этом случае процессы Apache будут существовать слишком долго. Лучше поручите заботу о режиме Keep-Alive прокси-серверу, который защищает Apache от клиента. Для соединений между Apache и прокси-сервером режим Keep-Alive вполне допустим, потому что прокси открывает всего несколько соединений для получения данных от Apache.
*/

/*
    Кэширование.

    Высоконагруженным приложениям без кэширования не обойтись. Типичное веб-приложение тратит на генерацию страницы гораздо больше ресурсов, чем на ее выборку из кэша (даже с учетом проверки и устаревания данных), поэтому обычно кэширование позволяет повысить производительность на несколько порядков.

    Кэши можно подразделить на две большие категории: пассивные и активные. Пассивный кэш только хранит и возвращает данные. Запрашивая что-то из пассивного кэша, вы либо получаете результат, либо сообщение «такого у меня нет». Примером пассивного кэша является демон memcached.

    Напротив, активный кэш выполняет какие-то действия, когда искомое не обнаруживается. Обычно он передает поступивший запрос какой-то другой части приложения, которая и генерирует затребованный результат. Затем кэш сохраняет его и возвращает запросившей программе. Кэширующий прокси-сервер Squid – типичный пример активного кэша. При проектировании приложения обычно стремятся сделать кэши активными (их еще называют прозрачными), поскольку они скрывают от программного обеспечения логику проверки, генерации и сохранения. Активные кэши можно строить поверх пассивных.
*/

/*
    Кэширование на уровне ниже уровня приложения.

    Использовать:

        У сервера MySQL есть свои внутренние кэши, да и вам никто не запрещает создать собственные кэширующие и сводные таблицы. Кэширующие таблицы можно спроектировать так, чтобы они повышали скорость фильтрации, сортировки, соединения с другими таблицами и решения других специализированных задач. К тому же кэширующие таблицы существуют дольше, чем большинство кэшей на уровне приложения, поскольку они не исчезают при перезапуске сервера.
*/

/*
    Кэширование не всегда помогает.

    Нужно обязательно убедиться, что в результате кэширования производительность действительно повышается, потому что иногда кэш не помогает вовсе. Например, на практике часто быстрее обслужить запрос из памяти lighttpd, чем из кэширующего прокси-сервера. Особенно это относится к случаю, когда кэш прокси-сервера хранится на диске.
*/

/*
    Кэширование на уровне приложения.

    Существует много разных видов кэшей на уровне приложения:

        - Локальные кэши

        - Кэши в локальной разделяемой памяти

            Они хороши для небольших, полустатических фрагментов данных. В качестве примера можно назвать списки городов в каждом штате. Основное достоинство разделяемой памяти – очень высокая скорость доступа, обычно гораздо выше, чем для любого удаленного кэша.

        - Распределенные кэши в памяти

            Самый известный пример такого рода – демон memcached. Объем распределенных кэшей гораздо больше, чем у кэша в локальной разделяемой памяти, и их размер легко увеличивается. В кэше создается всего одна копия данных, поэтому не нужно тратить время и решать проблемы согласования, возникающие, когда одна и та же информация кэшируется в разных местах. Распределенная память прекрасно подходит для хранения таких разделяемых объектов, как профили пользователей, комментарии и фрагменты HTTP-разметки.

        - Кэши на диске

            Диски – медленные устройства, поэтому на них лучше кэшировать объекты, не помещающиеся в памяти, или статическое содержимое (например, предварительно сгенерированные изображения).
*/

/*
    Стратегии управления кэшем.

    Кэшам присуща та же проблема, что денормализованной базе данных: значения дублируются, то есть информацию приходится обновлять в нескольких местах и необходимо принимать меры к тому, чтобы избежать чтения некорректных данных. Ниже описываются некоторые наиболее употребительные стратегии управления кэшем:

        - Время жизни (TTL)

            Вместе с кэшированным объектом хранится момент истечения срока хранения; можно либо удалять все объекты, для которых этот момент уже наступил, с помощью специального процесса, либо дождаться следующего обращения и тогда заменить объект более актуальной версией. Такая стратегия вытеснения больше подходит для редко изменяющихся данных или для которых требования к актуальности не критичны.

        Продолжение читать со страницы 577 (Явная инвалидация)

        - Явная инвалидация

        - Инвалидация при чтении. 
*/

/*
    Кэширование иерархий объектов.

    Вместо того чтобы кэшировать только сами объекты, можно кэшировать их идентификаторы, а также группы идентификаторов объектов, которые обычно извлекаются совместно.

    Вместо того чтобы кэшировать перечень товаров полностью, можно сохранить лишь минимальную информацию о поиске, например, количество найденных элементов и список их идентификаторов. А каждый товар будет кэшироваться по отдельности. Тем самым мы решаем обе проблемы: результаты не дублируются, и вытеснение можно производить с точностью до отдельного товара.

    При попадании в кэш возвращается список идентификаторов, который затем используется для повторного обращения к кэшу.
*/

/*
    Предварительная генерация содержимого.

    Помимо кэширования данных на уровне приложения, можно заранее апрашивать некоторые страницы из фоновых процессов и сохранять полученные результаты в виде статических страниц. Если страницы формируются динамически, то можно заранее сгенерировать какие-то их части, а для построения полной страницы применять технологию включения на стороне сервера (server-side include – SSI) или аналогичную.
*/

/*
    Расширение MySQL.

    К счастью, MySQL становится все более и более модульной и универсальной системой. Например, в версии MySQL 5.1 значительная часть функциональности реализована в виде внешних модулей; даже подсистемы хранения могут быть подключаемыми, поэтому необязательно присоединять их на этапе компиляции сервера.

    Подсистемы хранения – отличный способ расширить MySQL для решения узкоспециализированной задачи.

    MySQL Proxy – еще одна область приложения сил для тех, кто хочет расширить функциональность протокола MySQL. А созданная Полом МакКаллаги масштабируемая инфраструктура потоковых BLOB’ов открывает целый спектр новых возможностей для хранения больших объектов в MySQL.
*/

/*
    Альтернативы MySQL.

    Один из самых очевидных примеров – хранение данных в традиционной файловой системе, а не в таблицах. Классический случай – файлы изображений: их можно поместить в столбец типа BLOB, но это редко бывает оправдано. Обычно изображения и другие большие двоичные файлы размещают в файловой системе, а внутри MySQL хранят только их имена; приложение может получить файл в обход MySQL.

    Полнотекстовый поиск также лучше реализовывать внешними средствами, поскольку MySQL не способен делать это так хорошо, как, скажем, системы Lucene или Sphinx.
*/