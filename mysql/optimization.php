<?php

/*
	MySQL Оптимизация производительности. (Бэрон Шварц, Петр Зайцев, Вадим Ткаченко)
*/

/*
	К главам 2, 3, 4, 5 переодически нужно возвращаться и перечитывать:

		- В главе 2 приводится методика определения того, какого рода нагрузки способен выдерживать сервер, насколько быстро он может выполнять конкретные задачи и т.п. Тестирование приложения следует выполнять до и после серьезных изменений, чтобы понять, насколько они оказались эффективными. Изменения, кажущиеся полезными, при больших нагрузках могут оказать противоположный эффект, и вы никогда не узнаете причину падения производительности, пока не измерите ее точно.

		- В главе 3 мы описываем различные нюансы типов данных, проектирования таблиц и индексов.

		- В главе 4 речь пойдет о том, как MySQL выполняет запросы и как можно воспользоваться сильными сторонами оптимизатора запросов.

		- В главе 5 рассматриваются, как работают дополнительные расширенные возможности MySQL. Мы рассмотрим кэш запросов, хранимые процедуры, триггеры, кодировки и прочее.
*/

/*
	Еще одна трудность при работе с MySQL на платформе Windows – отсутствие языка Perl в стандартной поставке операционной системы. В состав дистрибутива MySQL входят несколько полезных утилит, написанных на Perl, а в некоторых главах этой книги представлены примеры Perl-сценариев, которые служат основой для более сложных инструментов, создаваемых уже вами. Комплект Maatkit также написан на Perl. Чтобы использовать эти сценарии, вам потребуется загрузить версию Perl для Windows с сайта компании ActiveState и установить дополнительные модули (DBI и DBD::mysql) для доступа к MySQL.
*/

/*
    Логическая архитектура MySQL.

    На самом верхнем уровне содержатся службы, которые не являются уникальными для MySQL. Они обеспечивают поддержку соединений, идентификацию, безопасность и т.п.

        Для каждого клиентского соединения выделяется отдельный поток внутри процесса сервера. Запросы по данному соединению исполняются в пределах этого потока, который, в свою очередь, выполняется одним ядром или процессором. Сервер кэширует потоки, так что их не нужно создавать или уничтожать для каждого нового соединения.

        Когда клиенты (приложения) подключаются к серверу MySQL, сервер должен их идентифицировать. Идентификация основывается на имени пользователя, адресе хоста, с которого происходит соединение, и пароле. (Но есть и другие варанты, например SSL)

    На втором уровне сосредоточена значительная часть интеллекта MySQL: синтаксический анализ запросов, оптимизация, кэширование и все встроенные функции (например, функции работы с датами и временем, математические функции, шифрование). На этом уровне реализуется любая независимая от подсистемы хранения данных функциональность, например хранимые процедуры, триггеры и представления.

        Прежде чем выполнять синтаксический анализ запроса, сервер обращается к кэшу запросов, в котором могут храниться только команды SELECT и соответствующие им результирующие наборы. Если поступает запрос, идентичный уже имеющемуся в кэше, серверу вообще не нужно выполнять анализ, оптимизацию или выполнение запроса – он может просто отправить в ответ на запрос сохраненный результирующий набор!

        MySQL осуществляет синтаксический разбор запросов для создания внутренней структуры (дерева разбора), а затем выполняет ряд оптимизаций. В их число входят переписывание запроса, определение порядка чтения таблиц, выбор используемых индексов и т. п. Вы можете повлиять на работу оптимизатора, включив в запрос специальные ключевые слова-подсказки (hints). 
        
        Оптимизатор не интересуется тем, в какой подсистеме хранения данных находится каждая таблица, но подсистема хранения данных влияет на то, как сервер оптимизирует запрос. Оптимизатор запрашивает подсистему хранения данных о некоторых ее возможностях и стоимости определенных операций, а также о статистике по содержащимся в таблицах данным.

    Третий уровень содержит подсистемы хранения данных. Они отвечают за сохранение и извлечение всех данных, хранимых в MySQL. Подсистемы хранения не производят синтаксический анализ кода SQL и не взаимодействуют друг с другом, они просто отвечают на исходящие от сервера запросы.
*/

/*
    Единственной безопасной политикой является наличие только одного клиента, осуществляющего запись в данный момент времени, и предотвращение всех операций чтения содержимого ресурса на период выполнения записи.

    Вместо того чтобы блокировать весь ресурс, можно заблокировать только ту его часть, в которую необходимо внести изменения. Еще лучше заблокировать лишь модифицируемый фрагмент данных. Минимизация объема ресурсов, которые вы блокируете в каждый момент времени, позволяет выполнять одновременные операции с одним и тем же объектом

    Основной стратегией блокировки в MySQL, дающей наименьшие накладные расходы, является табличная блокировка. Такая блокировка блокирует всю таблицу.

    Наибольшие возможности совместного доступа (и наибольшие накладные расходы) дают блокировки строк.
*/

/*
    Хороший пример использования транзакций.

    Представьте себе банковскую базу данных с двумя таблицами текущий и сберегательный счета. Чтобы переместить $200 с текущего счета клиента банка на его сберегательный счет, вам нужно сделать, по меньшей мере, три шага:

        1. Убедиться, что остаток на текущем счете больше $200.
        2. Снять $200 с текущего счета.
        3. Зачислить $200 на сберегательный счет.

    Вся операция должна быть организована как транзакция, чтобы в случае неудачи на любом из этих трех этапов все выполненные ранее шаги были отменены.

    Результаты транзакции обычно невидимы другим транзакциианзакциям, пока она не закончена.

    Вы можете решить, требует ли ваше приложение использования транзакций. Если они вам на самом деле не нужны, можно добиться большей производительности, выбрав для некоторых типов запросов нетранзакционную подсистему хранения данных.

    Что произойдет в случае сбоя сервера базы данных во время выполнения четвертой строки? Клиент, вероятно, просто потеряет $200. А если другой процесс снимет весь остаток с текущего счета в момент между выполнением строк 3 и 4? Банк предоставит клиенту кредит размером $200, даже не зная об этом. Транзакций недостаточно, если система не проходит тест ACID. Сервер базы данных с транзакциями ACID обычно требует большей мощности процессора, объема памяти и дискового пространства, чем без них.
*/

/*
    Изоляция.

    Это правила, устанавливающие какие изменения видны внутри и вне транзакции, а какие нет. Для каждой базы могут быть разными.

    Четыре уровня изоляции:
        
        1. READ UNCOMMITTED

            На этом уровне транзакции могут видеть результаты незафиксированных транзакций. Используйте этот уровень, если у вас есть на то веские причины. На практике READ UNCOMMITTED используется редко, поскольку его производительность ненамного выше, чем у других. 

        2. READ COMMITTED

            Это уровень по умолчанию для большинства СУБД. (но не для MySQL!). Тут транзакция увидит только те изменения, которые были уже зафиксированы другими транзакциями к моменту ее начала, а произведенные ею изменения останутся невидимыми для других транзакций, пока текущая транзакция не будет зафиксирована. Здесь можно наткнуться на проблему, когда выполняем одну и ту же команду дважды и получаем различный результат.

        3. REPEATABLE READ

            Он гарантирует, что любые строки, которые считываются в контексте транзакции, будут «выглядеть такими же» при последовательных операциях чтения в пределах одной и той же транзакции.

            REPEATABLE READ является в MySQL уровнем изоляции транзакций по умолчанию. Подсистемы хранения данных InnoDB и Falcon следуют этому соглашению.

            На этом уровне возможен феномен фантомного чтения. Например вы выбираете некоторый диапазон строк, затем другая транзакция вставляет новую строку в этот диапазон, после чего вы выбираете тот же диапазон снова. В результате вы увидите новую «фантомную» строку.

        4. SERIALIZABLE

            Самый высокий уровень изоляции, SERIALIZABLE, решает проблему фантомного чтения, заставляя транзакции выполняться в таком порядке, чтобы исключить возможность конфликта.

            На этом уровне может возникать множество задержек и конфликтов при блокировках. На практике данный уровень изоляции применяется достаточно редко.

*/

/*
    MySQL по умолчанию работает в режиме AUTOCOMMIT. Это означает, что если вы не начали транзакцию явным образом, каждый запрос автоматически выполняется в отдельной транзакции. Вы можете включить или отключить режим AUTOCOMMIT:

        - SET AUTOCOMMIT = 1 (SET AUTOCOMMIT = ON)

        - SET AUTOCOMMIT = 0 (SET AUTOCOMMIT = OFF)

    Если я выключу автокомит, то после каждого запроса мне нужно будет писать COMMIT или ROLLBACK
*/

/*
    MVCC.

    Большая часть транзакционных подсистем хранения в MySQL используют не просто механизм блокировки строк, а блокировку строк в сочетании с методикой повышения степени конкурентности под названием MVCC.

    MVCC - это многоверсионное управление конкурентным доступом.

    MVCC позволяет во многих случаях вообще отказаться от блокировки и способна значительно снизить накладные расходы. В зависимости от способа реализации она может допускать чтение без блокировок, а блокировать лишь необходимые строки во время операций записи.
*/