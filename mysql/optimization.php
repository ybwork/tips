<?php

/*
	MySQL Оптимизация производительности. (Бэрон Шварц, Петр Зайцев, Вадим Ткаченко)
*/

/*
	К главам 2, 3, 4, 5 переодически нужно возвращаться и перечитывать:

		- В главе 2 приводится методика определения того, какого рода нагрузки способен выдерживать сервер, насколько быстро он может выполнять конкретные задачи и т.п. Тестирование приложения следует выполнять до и после серьезных изменений, чтобы понять, насколько они оказались эффективными. Изменения, кажущиеся полезными, при больших нагрузках могут оказать противоположный эффект, и вы никогда не узнаете причину падения производительности, пока не измерите ее точно.

		- В главе 3 мы описываем различные нюансы типов данных, проектирования таблиц и индексов.

		- В главе 4 речь пойдет о том, как MySQL выполняет запросы и как можно воспользоваться сильными сторонами оптимизатора запросов.

		- В главе 5 рассматриваются, как работают дополнительные расширенные возможности MySQL. Мы рассмотрим кэш запросов, хранимые процедуры, триггеры, кодировки и прочее.
*/

/*
	Еще одна трудность при работе с MySQL на платформе Windows – отсутствие языка Perl в стандартной поставке операционной системы. В состав дистрибутива MySQL входят несколько полезных утилит, написанных на Perl, а в некоторых главах этой книги представлены примеры Perl-сценариев, которые служат основой для более сложных инструментов, создаваемых уже вами. Комплект Maatkit также написан на Perl. Чтобы использовать эти сценарии, вам потребуется загрузить версию Perl для Windows с сайта компании ActiveState и установить дополнительные модули (DBI и DBD::mysql) для доступа к MySQL.
*/

/*
    Логическая архитектура MySQL.

    На самом верхнем уровне содержатся службы, которые не являются уникальными для MySQL. Они обеспечивают поддержку соединений, идентификацию, безопасность и т.п.

        Для каждого клиентского соединения выделяется отдельный поток внутри процесса сервера. Запросы по данному соединению исполняются в пределах этого потока, который, в свою очередь, выполняется одним ядром или процессором. Сервер кэширует потоки, так что их не нужно создавать или уничтожать для каждого нового соединения.

        Когда клиенты (приложения) подключаются к серверу MySQL, сервер должен их идентифицировать. Идентификация основывается на имени пользователя, адресе хоста, с которого происходит соединение, и пароле. (Но есть и другие варанты, например SSL)

    На втором уровне сосредоточена значительная часть интеллекта MySQL: синтаксический анализ запросов, оптимизация, кэширование и все встроенные функции (например, функции работы с датами и временем, математические функции, шифрование). На этом уровне реализуется любая независимая от подсистемы хранения данных функциональность, например хранимые процедуры, триггеры и представления.

        Прежде чем выполнять синтаксический анализ запроса, сервер обращается к кэшу запросов, в котором могут храниться только команды SELECT и соответствующие им результирующие наборы. Если поступает запрос, идентичный уже имеющемуся в кэше, серверу вообще не нужно выполнять анализ, оптимизацию или выполнение запроса – он может просто отправить в ответ на запрос сохраненный результирующий набор!

        MySQL осуществляет синтаксический разбор запросов для создания внутренней структуры (дерева разбора), а затем выполняет ряд оптимизаций. В их число входят переписывание запроса, определение порядка чтения таблиц, выбор используемых индексов и т. п. Вы можете повлиять на работу оптимизатора, включив в запрос специальные ключевые слова-подсказки (hints). 
        
        Оптимизатор не интересуется тем, в какой подсистеме хранения данных находится каждая таблица, но подсистема хранения данных влияет на то, как сервер оптимизирует запрос. Оптимизатор запрашивает подсистему хранения данных о некоторых ее возможностях и стоимости определенных операций, а также о статистике по содержащимся в таблицах данным.

    Третий уровень содержит подсистемы хранения данных. Они отвечают за сохранение и извлечение всех данных, хранимых в MySQL. Подсистемы хранения не производят синтаксический анализ кода SQL и не взаимодействуют друг с другом, они просто отвечают на исходящие от сервера запросы.

        Виды подсистем: MyISAM, InnoDB, MyISAM Merge, Memory, Archive, CSV, Federated, Blackhole, NDB Cluster, Falcon, solidDB, PBXT (Primebase XT), Maria

        MySQL хранит каждую базу данных (также именуемую схемой), как подкаталог своего каталога данных в файловой системе. Когда вы создаете таблицу, MySQL сохраняет определение таблицы в файле с расширением .frm и именем, совпадающим с именем таблицы. Таким образом, определение таблицы с наименованием MyTable сохраняется в файле MyTable.frm

        Чтобы определить, какая подсистема хранения используется для конкретной таблицы, используйте команду SHOW TABLE STATUS.
*/

/*
    Единственной безопасной политикой является наличие только одного клиента, осуществляющего запись в данный момент времени, и предотвращение всех операций чтения содержимого ресурса на период выполнения записи.

    Вместо того чтобы блокировать весь ресурс, можно заблокировать только ту его часть, в которую необходимо внести изменения. Еще лучше заблокировать лишь модифицируемый фрагмент данных. Минимизация объема ресурсов, которые вы блокируете в каждый момент времени, позволяет выполнять одновременные операции с одним и тем же объектом

    Основной стратегией блокировки в MySQL, дающей наименьшие накладные расходы, является табличная блокировка. Такая блокировка блокирует всю таблицу.

    Наибольшие возможности совместного доступа (и наибольшие накладные расходы) дают блокировки строк.
*/

/*
    Хороший пример использования транзакций.

    Представьте себе банковскую базу данных с двумя таблицами текущий и сберегательный счета. Чтобы переместить $200 с текущего счета клиента банка на его сберегательный счет, вам нужно сделать, по меньшей мере, три шага:

        1. Убедиться, что остаток на текущем счете больше $200.
        2. Снять $200 с текущего счета.
        3. Зачислить $200 на сберегательный счет.

    Вся операция должна быть организована как транзакция, чтобы в случае неудачи на любом из этих трех этапов все выполненные ранее шаги были отменены.

    Результаты транзакции обычно невидимы другим транзакциианзакциям, пока она не закончена.

    Вы можете решить, требует ли ваше приложение использования транзакций. Если они вам на самом деле не нужны, можно добиться большей производительности, выбрав для некоторых типов запросов нетранзакционную подсистему хранения данных.

    Что произойдет в случае сбоя сервера базы данных во время выполнения четвертой строки? Клиент, вероятно, просто потеряет $200. А если другой процесс снимет весь остаток с текущего счета в момент между выполнением строк 3 и 4? Банк предоставит клиенту кредит размером $200, даже не зная об этом. Транзакций недостаточно, если система не проходит тест ACID. Сервер базы данных с транзакциями ACID обычно требует большей мощности процессора, объема памяти и дискового пространства, чем без них.
*/

/*
    Изоляция.

    Это правила, устанавливающие какие изменения видны внутри и вне транзакции, а какие нет. Для каждой базы могут быть разными.

    Четыре уровня изоляции:
        
        1. READ UNCOMMITTED

            На этом уровне транзакции могут видеть результаты незафиксированных транзакций. Используйте этот уровень, если у вас есть на то веские причины. На практике READ UNCOMMITTED используется редко, поскольку его производительность ненамного выше, чем у других. 

        2. READ COMMITTED

            Это уровень по умолчанию для большинства СУБД. (но не для MySQL!). Тут транзакция увидит только те изменения, которые были уже зафиксированы другими транзакциями к моменту ее начала, а произведенные ею изменения останутся невидимыми для других транзакций, пока текущая транзакция не будет зафиксирована. Здесь можно наткнуться на проблему, когда выполняем одну и ту же команду дважды и получаем различный результат.

        3. REPEATABLE READ

            Он гарантирует, что любые строки, которые считываются в контексте транзакции, будут «выглядеть такими же» при последовательных операциях чтения в пределах одной и той же транзакции. Другими словами вновь добавленные данные уже будут доступны внутри транзакции, но не будут доступны до подтверждения извне.

            REPEATABLE READ является в MySQL уровнем изоляции транзакций по умолчанию. Подсистемы хранения данных InnoDB и Falcon следуют этому соглашению.

            На этом уровне возможен феномен фантомного чтения. Например вы выбираете некоторый диапазон строк, затем другая транзакция вставляет новую строку в этот диапазон, после чего вы выбираете тот же диапазон снова. В результате вы увидите новую «фантомную» строку.

        4. SERIALIZABLE

            Самый высокий уровень изоляции, SERIALIZABLE, решает проблему фантомного чтения, заставляя транзакции выполняться в таком порядке, чтобы исключить возможность конфликта.

            На этом уровне может возникать множество задержек и конфликтов при блокировках. На практике данный уровень изоляции применяется достаточно редко.

*/

/*
    MySQL по умолчанию работает в режиме AUTOCOMMIT. Это означает, что если вы не начали транзакцию явным образом, каждый запрос автоматически выполняется в отдельной транзакции. Вы можете включить или отключить режим AUTOCOMMIT:

        - SET AUTOCOMMIT = 1 (SET AUTOCOMMIT = ON)

        - SET AUTOCOMMIT = 0 (SET AUTOCOMMIT = OFF)

    Если я выключу автокомит, то после каждого запроса мне нужно будет писать COMMIT или ROLLBACK
*/

/*
    MVCC.

    Большая часть транзакционных подсистем хранения в MySQL используют не просто механизм блокировки строк, а блокировку строк в сочетании с методикой повышения степени конкурентности под названием MVCC.

    MVCC - это многоверсионное управление конкурентным доступом.

    MVCC позволяет во многих случаях вообще отказаться от блокировки и способна значительно снизить накладные расходы. В зависимости от способа реализации она может допускать чтение без блокировок, а блокировать лишь необходимые строки во время операций записи.

    Принцип работы MVCC заключается в сохранении мгновенного снимка данных, какими они были в некоторый момент времени. Это означает, что вне зависимости от своей длительности транзакции могут видеть согласованное представление данных. Это также означает, что различные транзакции могут видеть разные данные в одних и тех же таблицах в одно и то же время!

    Методика MVCC работает только на уровнях изоляции REPEATABLE READ и READ COMMITTED.
*/

/*
    MyISAM.

    Будучи подсистемой хранения по умолчанию в MySQL, MyISAM представлявляет собой удачный компромисс между производительностью и функциональностью. Так, она предоставляет полнотекстовое индексирование, сжатие и пространственные функции (для геоинформационных систем – ГИС). MyISAM не поддерживает транзакции и блокировки на уровне строк.
*/

/*
    MyISAM Merge. 

    Представляет собой объединение нескольких структурно одинаковых таблиц MyISAM в одну виртуальную таблицу.
*/

/*
    InnoDB.

    была разработана для транзакционной обработки, в частности для обработки большого количества краткосрочных транзакций. Наиболее популярная система хранения.
*/

/*
    Memory.

    Таблицы типа Memory (раньше называвшиеся таблицами типа HEAP) полезны, когда необходимо осуществить быстрый доступ к данным, которые либо никогда не изменяются, либо нет надобности в их сохранении после перезапуска. Их польза обуславливается скоростью, которая выше чем у MyISAM.

    Вот несколько хороших применений для таблиц Memory:
        - Для «справочных» таблиц или таблиц «соответствия», например для таблицы, в которой почтовым кодам соответствуют названия регионов

        - Для кэширования результатов периодического агрегирования данных

        - Для промежуточных результатов при анализе данных

    Таблицы Memory не всегда годятся в качестве замены дисковых таблиц. Потому что они используют блокировку на уровне таблицы, что уменьшает конкуренцию при записи, и не поддерживают столбцы типа TEXT и BLOB. Также они допускают использование только строк фиксированного размера, поэтому значения типа VARCHAR сохраняются как значения типа CHAR, что повышает расход памяти.

    MySQL внутри себя использует подсистему Memory для хранения промежуточных результатов при обработке запросов, которым требуется временная таблица. Если промежуточный результат становится слишком большим для таблицы Memory или содержит столбцы типа TEXT или BLOB, то MySQL преобразует его в таблицу MyISAM на диске. В следующих главах об этом будет рассказано подробнее. Многие часто путают таблицы типа Memory с временными таблицами, которые создаются командой CREATE TEMPORARY TABLE. Временные таблицы могут использовать любую подсистему хранения. Это не то же самое, что таблицы типа Memory.
*/

/*
    Archive.

    Подсистема хранения Archive позволяет выполнять только команды INSERT и SELECT. Эта система требует значительно меньше операций дискового ввода/вывода, чем MyISAM, поскольку буферизует записываемые данные и сжимает все вставляемые строки с помощью библиотеки zlib. Кроме того, каждый запрос SELECT требует полного сканирования таблицы. По этим причинам таблицы Archive идеальны для протоколирования и сбора данных, когда анализ чаще всего сводится к сканированию всей таблицы, а также в тех случаях, когда требуется обеспечить быстроту выполнения запросов INSERT на главном сервере репликации.
*/

/*
    CSV.

    Подсистема CSV рассматривает файлы с разделителями-запятыми (CSV) как таблицы, но не поддерживает индексы по ним. Она позволяет импортировать и экспортировать данные из CSV-файлов, не останавливая сервер. Если вы экспортируете CSV-файл из электронной таблицы и сохраните в каталоге данных сервера MySQL, то сервер сможет немедленно его прочитать. Аналогично, если вы записываете данные в таблицу CSV, внешняя программа сможет сразу же прочесть его. Таблицы CSV особенно полезны как формат обмена данными и для некоторых типов протоколирования.
*/

/*
    Federated.

    Подсистема Federated не хранит данные локально. Каждая таблица типа Federated ссылается на таблицу, расположенную на удаленном сервере MySQL, так что для всех операций она соединяется с удаленным сервером. Иногда ее используют для различных трюков с репликацией.
*/

/*
    Blackhole.

    В подсистеме Blackhole вообще нет механизма хранения данных. Все команды INSERT просто игнорируются. Однако сервер записывает запросы к таблицам Blackhole в журналы как обычно, так что они могут быть реплицированы на подчиненные серверы или просто сохранены в журнале. Это делает подсистему Blackhole полезной для настройки предполагаемых репликаций и ведения журнала аудита.
*/

/*
    Falcon.

    Подсистема Falcon разработана для современного аппаратного обеспечения, в частности для серверов с несколькими 64-разрядными процессорами и большим объемом оперативной памяти, но может функционировать и на более скромной технике. В Falcon используется технология MVCC, причем исполняемые транзакции по возможности целиком хранятся в памяти. Это существенно ускоряет откат и операцию восстановления.
*/

/*
    Maria.

    Создана на замену MyISAM.

    Из основных функций:

        - Выбор транзакционного либо нетранзакционного хранилища на уровне таблицы

        - Восстановление после сбоя, даже когда таблицы работают в нетранзакционном режиме

        - Блокировка на уровне строк и MVCC

        - Улучшенная обработка BLOB
*/

/*
    Выбор подсистемы хранения.

    При разработке приложения для MySQL вы должны решить, какую подсистему хранения использовать. Поскольку допустимо выбирать способ хранения данных для каждой таблицы в отдельности, вы должны ясно понимать, как будет использоваться каждая таблица, и какие данные в ней планируется хранить. Но использование разных подсистем хранения для разных таблиц - не всегда удачное решение.

    Критерии выбора:

        1. Транзакции

            - Если вашему приложению требуются транзакции, то InnoDB является наиболее стабильной, хорошо интегрированной, проверенной подсистемой хранения

            - MyISAM можно назвать хорошим вариантом, если задача не требует транзакций и в основном предъявляет запросы типа SELECT или INSERT.

        2. Конкурентный доступ

            - Если вам требуется просто осуществлять в конкурентном режиме операции чтения и вставки, то хотите верьте, хотите нет, MyISAM является прекрасным выбором!

            - Если нужно поддержать совокупность одновременных операций, так чтобы они не искажали результатов друг друга, то хорошо подойдет какая-нибудь подсистема с возможностью блокировок на уровне строки.

        3. Резервное копирование

            - Если существует возможность периодически останавливать сервер для выполнения данной процедуры, то подойдет любая подсистема хранения данных.

        4. Восстановление после сбоя

            - Если объем данных велик, то нужно серьезно оценить, сколько времени займет восстановление базы после сбоя. Таблицы MyISAM обычно чаще оказываются поврежденными и требуют значительно больше времени для восстановления, чем, например, таблицы InnoDB. На практике это одна из самых важных причин, по которым многие используют подсистему InnoDB даже при отсутствии необходимости в транзакциях.

        5. Специальные возможности

            - Наконец, вы можете обнаружить, что приложению требуются конкретные возможности или оптимизации, которые могут обеспечить только некоторые подсистемы хранения MySQL.
*/

/*
    Одним из решений является использование встроенной функции репликации MySQL для клонирования данных на второй (подчиненный) сервер, где затем будут запущены длительные запросы, активно потребляющие ресурсы. Таким образом, главный сервер останется свободным для вставки записей и не нужно будет беспокоиться о том, как создание отчета повлияет на протоколирование в реальном времени.
*/

/*
    Таблицы, содержащие данные, которые используются для создания каталога или списка (вакансии, аукционы, недвижимость и т. п.), обычно отличаются тем, что считывание из них происходит значительно чаще, чем запись. Такие таблицы являются хорошими кандидатами для MyISAM – если забыть о том, что происходит при сбое MyISAM. Поста- райтесь избежать недооценки того, насколько это важно.
*/

/*
    Только не доверяйте народной мудрости «MyISAM быстрее, чем InnoDB». Категоричность этого утверждения спорна. Мы можем перечислить десятки ситуаций, когда InnoDB повергает MyISAM в прах, особенно в приложениях, где находят применение кластерные индексы или данные целиком размещаются в памяти.
*/

/*
    Однако если вы используете веб-службу с большим трафиком, которая получает котировки в режиме реального времени и имеет тысячи пользователей, длительное ожидание результатов недопустимо. Многие клиенты будут одновременно пытаться осуществлять чтение из таблицы и запись в нее, поэтому необходима блокировка на уровне строк или проектное решение, минимизирующее количество операций обновления.
*/

/*
    Преобразования таблицы из одной подсистемы хранения в другую. 

    ALTER TABLE mytable ENGINE = Falcon;

    При изменении подсистемы хранения все специфичные для старой подсистемы возможности теряются. Например, после преобразования таблицы InnoDB в MyISAM, а потом обратно будут потеряны все внешние ключи, определенные в исходной таблице InnoDB.

    Чтобы получить больший контроль над процессом преобразования, вы можете сначала экспортировать таблицу в текстовый файл с помощью утилиты mysqldump. После этого можно будет просто изменить команду CREATE TABLE в этом текстовом файле. Не забудьте отредактировать название таблицы и ее тип, поскольку нельзя иметь две таблицы с одним и тем же именем в одной и той же базе данных, даже если у них разные типы – а mysqldump по умолчанию пишет команду DROP TABLE перед командой CREATE TABLE, так что вы можете потерять свои данные, если не будете осторожны!

    Вместо того чтобы экспортировать всю таблицу или преобразовывать ее за один прием, создайте новую таблицу и используйте команду MySQL INSERT ... SELECT для ее заполнения следующим образом:

        CREATE TABLE innodb_table LIKE myisam_table;
        ALTER TABLE innodb_table ENGINE=InnoDB;
        INSERT INTO innodb_table SELECT * FROM myisam_table;

    Этот способ работает хорошо, если данных немного. Но если объем данных велик, то зачастую оказывается гораздо эффективнее заполнять таблицу частями, фиксируя транзакцию после каждой части, чтобы журнал отмены не становился слишком большим.

        START TRANSACTION;
        INSERT INTO innodb_table SELECT * FROM myisam_table -> WHERE id BETWEEN x AND y;
        COMMIT;
*/

// Глава 2.

/*
    Итак, у вас возникла необходимость повысить производительность MySQL. Но что пытаться улучшить? Конкретный запрос? Схему? Оборудование? Единственный способ узнать это – оценить, что именно делает ваша система, и протестировать ее производительность в разных условиях.

    Эталонное тестирование (benchmarking) и профилирование (profiling) – вот два важнейших метода определения узких мест.

        Эталонное тестирование измеряет производительность системы.

        В свою очередь, профилирование помогает найти места, где приложение тратит больше всего времени и потребляет больше всего ресурсов.
*/

/*
    Эталонное тестирование.

    Области применения:

        - Измерить производительность приложения в текущий момент

        - Вы можете использовать эталонные тесты для эмуляции гораздо большей нагрузки, чем та, которую испытывает система сейчас

        - помогут оценить, какое оборудование, пропускная способность сети или другие ресурсы потребуются при планируемом увеличении нагрузки

        - Тестирование различных конфигураций оборудования, программного обеспечения и операционной системы

    Стратегии:

        - тестировать приложение целиком

        - только аспекты, относящиеся к MySQL

    Если вы плохо спроектируете тест, то можете прийти к неверным выводам, поскольку полученные подобным образом результаты не отражают реальности.

    Эталонное тестирование MySQL полезно, когда вы выполняете характерные для своего приложения запросы на реальном наборе данных. Но если их нет, то у вас нет другого выбора, кроме как сгенерировать больший объем данных и нагрузку.

    Перед началом тестирования нужно определить цели. Сформулируйте цели в виде вопросов, например «лучше ли этот процессор, чем тот?» или «будут ли новые индексы работать эффективнее, чем нынешние?».

    Так же следует обратить внимание на следующие показатели:

        - Количество транзакций в единицу времени. Это один из классических эталонных тестов приложений баз данных.

        - Время отклика или задержки. Этот показатель дает представление об общем времени исполнения задачи.

        - Масштабируемость. Измерение масштабируемости полезно для систем, в которых необходимо поддерживать стабильную производительность даже в условиях меняющейся нагрузки.

        - Уровень конкуренции. Более точная мера измерения конкуренции на веб-сервере – количество запросов в секунду, которые пользователи генерируют в пиковые периоды. В общем случае стоит ограничить конкуренцию на сервере MySQL, используя такие методы, как организация очередей на уровне приложений.

    Тактики эталонного тестирования.

        Наиболее частые ошибки эталонного тестирования, которые могут привести к непригодным или неточным результатам:

            - Использование набора данных, имеющего объем, несоизмеримый с рабочими объемами, например использование одного гигабайта данных, когда приложение должно будет обрабатывать сотни гигабайт

            - Использование данных с неправильным распределением, например равномерно распределенных, когда в реальных данных будут встречаться «горячие точки».

            - Использование нереалистично распределенных параметров, например в предположении, что частота просмотра всех профилей пользователей будет одинакова.

            - Использование однопользовательского сценария для многопользовательского приложения.

            - Тестирование распределенного приложения на единственном сервере.

            - Несоответствие реальному поведению пользователя, например неверное время просмотра одной страницы. Реальные пользователи запрашивают страницу, а потом читают ее. Они не щелкают по ссылкам без остановки.

            - Выполнение идентичных запросов в цикле. Реальные запросы неодинаковы.

            - Отсутствие контроля ошибок. Если результаты теста не имеют смысла – например, медленная операция внезапно очень быстро заканчиваетса, – ищите ошибку.

            - Игнорирование проверки работы системы сразу после ее запуска или перезагрузки. Иногда нужно знать, как быстро ваш сервер наберет «полную мощность» после перезагрузки. Наоборот, если вы предполагаете изучить производительность в нормальном режиме, убедитесь, что на результаты тестирования не повлияет «неразогретый» кэш.

        Проектирование и планирование тестов.

            Первым шагом в планировании тестов является определение проблемы и цели.

            Затем нужно решить, использовать ли стандартный тест или разработать свой собственный.

        Инструменты полного тестирования.

            Полное тестирование обычно является лучшим способом получить ясное представление о производительности системы. Для этого используются следующие инструменты:

                - ab. ab представляет собой широко известный инструмент тестирования производительности сервера HTTP Apache. Он показывает, сколько запросов в секунду способен обслуживать HTTP-сервер. Если вы тестируете веб-приложение, это число демонстрирует, какое количество запросов в секунду может обслужить приложение в целом. Это очень простой инструмент, но полезность его ограничена, поскольку он просто обращается к одному адресу URL настолько быстро, насколько это возможно.

                - http_load. Этот инструмент концептуально похож на ab. Он также предназначен для создания нагрузки на веб-сервер, но при этом является более гибким. Вы можете создать входной файл, включающий много разных адресов URL, а http_load будет выбирать их случайным образом. Вы также можете настроить параметры таким образом, что запросы станут отправляться с заданным интервалом, а не с максимально возможной скоростью.

                - JMeter. JMeter представляет собой приложение на языке Java, которое может загружать другое приложение и измерять его производительность. Эта программа была разработана для тестирования веб-приложений, но ее можно также использовать при тестировании FTP-серверов и для отправки запросов к базе данных через интерфейс JDBC. Программа JMeter значительно сложнее, чем ab и http_load. Например, с ее помощью можно более гибко эмулировать поведение реальных пользователей, управляя таким параметром, как время нарастания нагрузки.

            Инструменты покомпонентного тестирования.

                - mysqlslap. Эмулирует нагрузку на сервер и выдает данные хронометража. Эта программа является частью дистрибутива MySQL 5.1, но ее можно использовать и с более ранними версиями, начиная с 4.1. Данный инструмент позволяет настроить количество одновременных соединений и передать программе либо команду SQL в командной строке, либо файл с командами SQL, которые нужно выполнить. Если вы не зададите режим тестирования вручную, программа сама исследует схему базы данных и автоматически сгенерирует команды SELECT.

                - Database Test Suite. Представляет собой комплект программ для тестирования производительности, анало- гичный стандартным промышленным тестам, например опубликованным Советом по производительности обработки транзакций

                - MySQL Benchmark Suite. Среди главных недостатков этого инструмента можно упомянуть то, что он работает в однопользовательском режиме, задействует очень маленький набор исходных значений, не допускает тестирования на данных, характерных именно для ваших условий, а результаты могут отличаться от запуска к запуску. Поскольку он однопоточный и полностью последовательный, с его помощью невозможно оценить выигрыш от наличия нескольких процессоров, но вместе с тем он вполне пригоден для сравнения однопроцессорных серверов.

                - Super Smack. Предназначен для эталонного тестирования, тестирования под нагрузкой и создания нагрузки в применении к СУБД MySQL и PostgreSQL.

*/

/*
    Возьмите за правило всегда проверять после выполнения теста журнал ошибок.
*/

/*
    Функция BENCHMARK(), которую можно использовать при тестировании скорости выполнения определенных типов операций.

    Для этого нужно указать количество прогонов и подлежащее выполнению выражение. В качестве последнего может выступать любое скалярное выражение, например скалярный подзапрос или функция. Это удобно для тестирования относительных скоростей некоторых операций, например для выяснения того, какая функция работает быстрее: MD5() или SHA1():

        SET @input := 'hello world';
        SELECT BENCHMARK(1000000, MD5(@input));
        SELECT BENCHMARK(1000000, SHA1(@input));

    Эта функция просто измеряет, насколько быстро сервер может выполнить выражение, но не сообщает ничего о накладных расходах на синтаксический анализ и оптимизацию. А если выражение не включает в себя пользовательскую переменную, как в нашем примере, то второе и последующие выполнения сервером данного выражения могут оказаться обращением к кэшу. Поэтому не рекомендуется использовать данную функцию для реального тестирования производительности.
*/

/*
    Практические примеры тестов смотреть начиная со стр. 77 (они простые и можно использовать сразу)
*/

/*
    Профилирование.

    Профилирование показывает, какую долю вносит каждая часть системы в общую стоимость получения результата.

    Профилирование на уровне приложения обычно помогает понять, как оптимизировать его наилучшим образом, и дает более точные результаты, поскольку они включают в себя работу, выполненную всей системой.

    Доступ к базе данных часто, но не всегда, является узким местом приложения. Узкие места могут быть также вызваны одной из следующих причин:

        - Обращения к внешним ресурсам, например веб-сервисам или поисковым системам

        - Операции, которые требуют обработки больших объемов данных в приложении, например синтаксический анализ больших файлов XML

        - Дорогостоящие операции в циклах, например злоупотребление регулярными выражениями

        - Плохо оптимизированные алгоритмы, например наивные алгоритмы поиска в списках

        - Перед тем как начинать анализ запросов к MySQL, вы должны понять реальный источник ваших проблем с производительностью. Профилирование приложения поможет найти узкие места, и это важный шаг в мониторинге и увеличении общего быстродействия системы.

    Как и что измерять?

        Время является подходящей метрикой при профилировании большинства приложений, поскольку конечного пользователя больше всего интересует именно время работы.

        В веб-приложениях мы обычно предусматриваем режим отладки, в котором на каждой странице отображаются выполняемые запросы, а также момент их выполнения и количество возвращенных строк.

        Внедрить код профилирования в существующее приложение может оказаться трудной задачей, но в новые приложения включать его легко. 

        В PHP имеют встроенные функции для профилирования доступа к базам данных.

        Ваш код профилирования должен собирать и регистрировать, по меньшей мере, следующие сведения:

            - Общее время выполнения (в веб-приложениях это полное время генерирования страниц)

            - Каждый выполненный запрос и время его исполнения

            - Каждый факт открытия соединения с сервером MySQL

            - Каждое обращение к внешнему ресурсу, например к веб-сервисам, службе memcached и внешним вызываемым сценариям

            - Потенциально дорогостоящие вызовы функций, например синтаксический анализ XML

            - Процессорное время, потраченное в режиме пользователя и ядра

        Не замедлит ли профилирование работу ваших серверов?

            Да. Профилирование и мониторинг увеличивают накладные расходы. Поэтому лучше использовать облегченное профилирование. Можно просто профилировать случайную выборку, включая профилирование в конфигурационном файле приложения:

                $profiling_enabled = rand(0, 100) > 99;

        Пример профилирования приложения PHP смотреть на стр. 90
*/

/*
    Протоколирование запросов.

    В MySQL есть два типа журналов запросов: 

        - общий журнал

            В общий журнал каждый запрос заносится в момент поступления серверу, поэтому там присутствуют даже те запросы, которые не были выполнены из-за возникших ошибок. Вы можете включить этот журнал с помощью одного конфигурационного параметра: log = <имя_файла>. Естественно, общий журнал не содержит сведений о времени выполнения и иной информации, доступной только после завершения запроса.

        - журнал медленных запросов

            Журнал медленных запросов включает только данные о выполненных запросах. Точнее, здесь протоколируются запросы, выполнение которых заняло время, превышающее установленный порог. Для профилирования могут быть полезны оба журнала, но журнал медленных запросов является основным инструментом, позволяющим выявить проблемные запросы. Обычно мы рекомендуем включать его.

            В следующем примере конфигурации этот журнал включается, и в нем
            регистрируются все запросы, выполнение которых занимает больше
            двух секунд, а также запросы, для обработки которых не были задействованы индексы. Кроме того, будут протоколироваться медленные административные запросы, например OPTIMIZE TABLE:

                log-slow-queries = <имя_файла>
                long_query_time = 2
                log-queries-not-using-indexes
                log-slow-admin-statements

            Вам нужно подстроить эти параметры под себя в конфигурационном файле сервера my.cnf

            Значением по умолчанию для параметра long_query_time является 10 секунд. В большинстве случаев это слишком много, поэтому мы обычно задаем две секунды. Однако во многих случаях и одной секунды более чем достаточно.

    Как читать журнал медленных запросов см. на стр. 101

    В общем случае при исследовании журналов следует обращать внимание на следующие три вещи:

        - Долго выполняющиеся запросы

        - Запросы, больше всего нагружающие сервер

        - Новые запросы

    Вот некоторые из наиболее распространенных приложений, предназначенных для анализа журналов:

        - mysqldumpslow (Преимуществом программы mysqldumpslow является то, что она уже имеется в комплекте с СУБД. Недостаток ее в том, что она несколько менее гибкая, чем некоторые другие инструменты)

        - mysql_slow_log_filter

        - mysql_slow_log_parser

        - mysqlsla

    Профилирование сервера MySQL.

        Один из лучших способов профилировать сервер – то есть увидеть, на что он тратит большую часть времени, заключается в использовании команды SHOW STATUS, которая возвращает много информации о состоянии. (Команда SHOW STATUS ведет себя несколько каверзно и это может привести к плохим результатам в MySQL 5.0 и более новых версиях)

        Чтобы увидеть в режиме, близком к реальному времени, как работает ваш сервер, периодически запускайте команду SHOW STATUS и сравнивайте результат с предыдущим запуском. Вы можете делать это с помощью следующей команды:

            mysqladmin extended -r -i 10

            Некоторые из переменных не являются строго возрастающими счетчиками, так что вы можете увидеть странные результаты типа отрицательного значения Threads_running. Не беспокойтесь по этому поводу, просто счетчик уменьшился с момента предыдущей выборки.

        Еще одним хорошим способом профилирования сервера MySQL является использование команды SHOW PROCESSLIST. Она позволяет видеть не только типы выполняющихся запросов, но и состояние соединений. Некоторые вещи, например большое количество соединений в состоянии Locked, являются явными указаниями на узкие места. Как и в случае команды SHOW STATUS, вывод SHOW PROCESSLIST достаточно подробен. Обычно гораздо удобнее использовать такие инструменты, как innotop, чем разбирать его вручную.

    Профилирование операционной системы.

    Иногда бывает полезно получить статистику операционной системы и попытаться выяснить, что же делают ОС и оборудование. Это может помочь не только при профилировании приложения, но и в процессе поиска неполадок. Чаще всего мы используем инструменты vmstat, iostat, mpstat и strace. Будьте осторожны при использовании программы strace в GNU/Linux на рабочих серверах. Похоже, она не всегда правильно работает с многопоточными процессами, и нам доводилось видеть, как ее использование приводило к аварийной остановке сервера.
*/

/*
    Например, запрос продолжительностью 10 миллисекунд, который запускается 1000 раз в секунду, нагрузит сервер сильнее, чем десятисекундный запрос, запускаемый один раз в секунду. Чтобы выявить такую проблему, требуется протоколировать все запросы и проанализировать результаты.
*/

// Глава 3.

/*
    Оптимизация схемы и индексирование.

        Если вам требуется высокое быстродействие, вы должны разработать схему и индексы под те конкретные запросы, которые будете запускать. 

        Оптимизация часто требует компромиссов. Например, добавление индексов для ускорения выборки данных замедляет их изменение. Аналогично денормализованная схема ускоряет некоторые типы запросов, но замедляет другие.

        Оптимизация схемы и индексирование потребуют как взгляда на картину в целом, так и внимания к деталям. Вам нужно понимать всю систему, чтобы разобраться, как каждая ее часть влияет на остальные.

    Выбор оптимальных типов данных.
        
        Выбор правильного типа для хранения вашией информации критичен с точки зрения увеличения производительности. Следующие простые рекомендации помогут вам выбрать лучшее решение вне зависимости от типа сохраняемых данных:

            - Меньше обычно лучше.

                Нужно стараться использовать типы данных минимального размера, достаточного для их правильного хранения и представления. Меньшие по размеру типы данных обычно быстрее, поскольку занимают меньше места на диске, в памяти и в кэше процессора. Кроме того, для их обработки обычно требуется меньше процессорного времени. Увеличение размерности типа данных во многих местах схемы может оказаться болезненным и длительным процессом. Если вы сомневаетесь, какой тип данных выбрать, отдайте предпочтение самому короткому при условии, что его размера хватит.

            - Просто значит хорошо.

                Для выполнения операций с более простыми типами данных обычно требуется меньше процессорного времени. Вот два примера: следует хранить значения даты и времени во встроенных типах данных MySQL, а не в строках. Для IP-адресов имеет смысл использовать целочисленные типы данных. 

                Использовать:

                    В столбцах DATETIME и TIMESTAMP можно хранить один и тот же тип данных: дату и время, с точностью до секунды. Однако тип TIMESTAMP требует вдвое меньше места.

            - При возможности избегайте значений NULL

                Всюду, где это возможно, определяйте столбцы как NOT NULL. Очень часто в таблицах встречаются поля, допускающие хранение NULL (отсутствие значения), хотя приложению это совершенно не нужно, – просто потому, что такой режим выбирается по умолчанию. Однако не объявляйте столбец как NOT NULL, если у хранящихся в нем данных могут отсутствовать значения. Столбец, допускающий NULL, занимает больше места на диске и требует специальной обработки внутри MySQL. Даже когда требуется представить в таблице факт отсутствия значения, можно обойтись без использования NULL. Вместо этого иногда можно использовать нуль, специальное значение или пустую строку. Повышение производительности в результате замены столбцов NULL на NOT NULL обычно невелико, так что не делайте их поиск и изменение в существующих схемах приоритетом, если не уверены, что именно они вызывают проблемы. Однако если вы планируете индексировать столбцы, по возможности определяйте их как NOT NULL.

        Типы данных:

            - Целые числа:

                - TINYINT (8)
                
                - SMALLINT (16)

                - MEDIUMINT (24)

                - INT (32)

                - BIGINT (64)

            Их размеры соответственно равны 8, 16, 24, 32 и 64 бита. Целые типы данных могут иметь необязательный атрибут UNSIGNED, запрещающий отрицательные значения и приблизительно вдвое увеличивающий верхний предел положительных значений. Например, тип TINYINT UNSIGNED позволяет хранить значения от 0 до 255, а не от –128 до 127. В данном случае используйте тот тип, который больше подходит для диапазона ваших данных.

            - Вещественные числа (Вещественные числа – это числа, имеющие дробную часть):

                - FLOAT

                - DOUBLE

                Допускают приближенные математические вычисления с плавающей точкой. 

                - DECIMAL (предназначен для хранения точных дробных чисел) 

            Операции с плавающей точкой выполняются несколько быстрее, чем точные вычисления с DECIMAL, так как процессор выполняет их естественным для него образом. Для столбца типа DECIMAL вы можете указать максимально разрешенное количество цифр до и после десятичной запятой. Это влияет на объем пространства, требуемого для хранения данных столбца. Типы с плавающей точкой обычно используют для хранения одного и того же диапазона значений меньше пространства, чем тип DECIMAL. Столбец типа FLOAT задействует всего лишь четыре байта. Тип DOUBLE требует восемь байтов и имеет большую точность и больший диапазон значений. Как и в случае целых чисел, вы выбираете тип только для хранения. Для вычислений с плавающей точкой MySQL использует тип DOUBLE. 

            Использовать:

                Ввиду дополнительных требований к пространству и стоимости вычислений тип DECIMAL стоит использовать только тогда, когда нужны точные результаты при вычислениях с дробными числами, – например, при хранении финансовых данных.

            - Строковые типы:

                - VARCHAR

                    Тип VARCHAR хранит символьные строки переменной длины и является наиболее общим строковым типом данных. Строки этого типа могут занимать меньше места, чем строки фиксированной длины. Происходит это потому, что в VARCHAR используется лишь столькоместа, сколько действительно необходимо. Исключением являются таблицы типа MyISAM, созданные с параметром ROW_FORMAT=FIXED, когда для каждой строки на диске отводится область фиксированного размера, поэтому место может расходоваться впустую.
                    
                    Использовать:

                        VARCHAR увеличивает производительность за счет меньшего потребления места на диске. Однако поскольку строки имеют переменную длину, они способны увеличиваться при обновлении, что вызывает дополнительную работу. Если строка становится длиннее и больше не помещается в ранее отведенное для нее место, то ее дальнейшее поведение зависит от подсистемы хранения. Например, MyISAM может фрагментировать строку, а InnoDB, возможно, придется расщепить страницу. Другие подсистемы хранения могут вообще не обновлять данные в месте их хранения.

                        Обычно имеет смысл использовать тип VARCHAR при соблюдении хотя бы одного из следующих условий: максимальная длина строки в столбце значительно больше средней; обновление поля выполняется редко, так что фрагментация не представляет проблемы

                - CHAR

                    Тип CHAR имеет фиксированную длину. MySQL всегда выделяет место
                    для указанного количества символов. При сохранении значения CHAR
                    MySQL удаляет все пробелы в конце строки. Тип CHAR полезен, когда требуется сохранять очень короткие строки или все значения имеют приблизительно одинаковую длину. Например, CHAR является хорошим выбором для хранения MD5-сверток паролей пользователей, которые всегда имеют одинаковую длину. Тип CHAR также имеет преимущество над VARCHAR для часто меняющихся данных, поскольку строка фиксированной длины не подвержена фрагментации. В случае очень коротких столбцов тип CHAR также эффективнее, чем VARCHAR.

                - BINARY

                - VARBINARY

                Предназначенны для хранения двоичных строк. Двоичные строки очень похожи на обычные, но вместо символов в них содержатся байты. Эти типы полезны, когда нужно сохранять двоичные данные, и вы хотите, чтобы MySQL сравнивал значение как байты, а не как символы.

                - BLOB (TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB)

                - TEXT (TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT)

                Строковые типы BLOB и TEXT предназначены для хранения больших объемов двоичных или символьных данных соответственно.

                - ENUM

                    Иногда вместо обычных строковых типов можно использовать тип ENUM. В столбце типа ENUM можно хранить до 65535 различных строковых значений. MySQL воспринимает каждое значение как целое число, представляющее позицию значения в списке значений поля, и отдельно хранит в frm-файле «справочную таблицу», определяющую соответствие между числом и строкой. В строках таблицы в действительности хранятся целые числа, а не строки. Но эти числа могут повторяться. Другим сюрпризом является то, что поля типа ENUM сортируются по внутренним целочисленным значениям, а не по самим строкам. Главным недостатком столбцов типа ENUM является то, что список строк фиксирован, а для их добавления или удаления необходимо использовать команду ALTER TABLE. Таким образом, если предполагается изменение списка возможных значений в будущем, то обращение к типу ENUM для представления строк может быть не такой уж и хорошей идеей.

                - DATETIME
                    
                    Под значение отводится восемь байт.

                - TIMESTAMP

                    Для хранения типа TIMESTAMP используется только четыре байта, поэтому он позволяет представить значительно меньший диапазон дат, чем тип DATETIME: с 1970 года до некоторой даты в 2038 году.

                - BIT

                    Максимальная длина столбца типа BIT равна 64 битам. Вы можете использовать столбец типа BIT для хранения одного или нескольких значений true/false в одном столбце. MySQL рассматривает BIT как строковый тип, а не числовой. Когда вы извлекаете значение типа BIT(1), результатом является строка, но ее содержимое представляет собой двоичное значение 0 или 1, а не значение «0» или «1». Имейте это в виду, когда захотите сравнить результат с другим значением. Мы советуем использовать тип BIT с осторожностью. Для большинства приложений лучше его вообще избегать.

                - SET

                    Если нужно сохранять много значений true/false, попробуйте объединить несколько столбцов в один столбец типа SET. При поиске в столбцах типа SET не используются индексы.

                Испльзовать:

                    Альтернативой типу SET является использование целого числа как упакованного набора битов. Например, вы можете поместить восемь бит в тип TINYINT и выполнять с ним побитовые операции. Для упрощения работы можно определить именованные константы для каждого бита в коде приложения.

                Использовать:

                    Если возникла необходимость сохранять значение true/false в одном бите, просто создайте столбец типа CHAR(0) с возможностью хранения NULL. Подобный столбец может представить как отсутствие значения (NULL), так и значение нулевой длины (пустая строка).
                
                Использовать:

                    Несмотря на эти особенности, мы рекомендуем пользоваться типом TIMESTAMP, если это возможно, поскольку с точки зрения занимаемого места на диске он гораздо эффективнее, чем DATETIME. Иногда временные метки UNIX сохраняют в виде целых чисел, но обычно это не дает никаких преимуществ. Поскольку такое представление часто неудобно, мы не советуем так поступать.

                Использовать:

                    СУБД MySQL сортирует столбцы BLOB и TEXT иначе, чем столбцы других типов: вместо сортировки строк по всей длине хранимых данных, она сортирует только по первым max_sort_length байтам. Если нужна сортировка только по нескольким первым символам, то можно либо уменьшить значение серверной переменной max_sort_length, либо использовать конструкцию ORDER BY SUBSTRING(column, length). MySQL не может индексировать данные этих типов по полной длине и не может использовать для сортировки индексы.

                Использовать:

                    Поскольку подсистема хранения Memory не поддерживает типы BLOB и TEXT, для запросов, в которых используются столбцы такого типа и которым нужна неявная временная таблица, придется использовать временные таблицы MyISAM на диске, даже если речь идет всего о нескольких строках. Лучше всего не использовать типы BLOB и TEXT, если можно без них обойтись. Если же избежать этого не удается, можно использовать конструкцию ORDER BY SUBSTRING(column, length) для преобразования значений в символьные строки, которые уже могут храниться во временных таблицах в памяти. Только выбирайте достаточно короткие подстроки, чтобы временная таблица не вырастала до объемов, превышающих значения переменных max_heap_table_size или tmp_table_size.
                
                Использовать:

                    Сохранение значения ‘hello’ требует одинакового пространства и в столбце типа VARCHAR(5), и в столбце типа VARCHAR(200). Есть ли преимущество в использовании более короткого столбца? Оказывается, преимущество есть, и большое. Для столбца большей размерности может потребоваться намного больше памяти, поскольку MySQL часто выделяет для внутреннего хранения значений участки памяти фиксированного размера. Это особенно плохо для сортировки или операций, использующих временные таблицы в памяти.

    Выбор типа идентификатора.

    Выбор типа данных для столбца идентификатора имеет очень большое значение. Велика вероятность, что этот столбец будет сравниваться с другими значениями (например, в соединениях) и использоваться для поиска чаще, чем другие столбцы. Возможно также, что вы будете применять идентификаторы как внешние ключи в других таблицах, поэтому выбор типа столбца идентификатора, скорее всего, определит и типы столбцов в связанных таблицах.

    При выборе типа данных для столбца идентификатора нужно принимать во внимание не только тип хранения, но и то, как MySQL выполняет вычисления и сравнения с этим типом. Например, MySQL хранит типы ENUM и SET как целые числа, но при выполнении сравнения в строковом контексте преобразует их в строки.

    Сделав выбор, убедитесь, что вы используете один и тот же тип во всех связанных таблицах. Типы должны совпадать в точности, включая такие свойства как UNSIGNED. Потому что смешение различных типов данных может вызвать проблемы с производительностью. 
    
    Использовать:

        Имеет смысл выбирать самый маленький размер поля, способный вместить требуемый диапазон значений, и при необходимости оставлять место для дальнейшего роста. Например, если есть столбец state_id, в котором хранятся названия штатов США, вам не нужны тысячи или миллионы значений, поэтому не используйте тип INT. Типа TINYINT, который на три байта короче, вполне достаточно.

        Целые типы обычно лучше всего подходят для идентификаторов, поскольку они работают быстро и допускают автоматический инкремент (AUTO_INCREMENT).

        Типы ENUM и SET обычно не годятся для идентификаторов. Столбцы ENUM и SET подходят для хранения такой информации, как состояние заказа, вид продукта или пол человека.

        По возможности избегайте задания для идентификаторов строковых типов, поскольку они занимают много места и обычно обрабатываются медленнее, чем целочисленные типы. Особенно осторожным следует быть при использовании строковых идентификаторов в таблицах MyISAM. Подсистема хранения MyISAM по умолчанию применяет для строк упакованные индексы, поиск по которым значительно медленнее. В наших тестах мы обнаружили, что в процессе работы с упакованными индексами MyISAM производительность падает чуть ли не в шесть раз. Следует также быть очень внимательными при работе со «случайными» строками, например сгенерированными функциями MD5(), SHA1() или UUID(). Они замедляют запросы INSERT, поскольку вставленное значение должно быть помещено в случайное место в индексах. Они замедляют запросы SELECT, так как логически соседние строки оказываются разбросаны по всему диску и памяти. Случайные значения приводят к ухудшению работы кэша для запросов всех типов, поскольку нарушают принцип локальности ссылок, лежащий в основе работы кэша.
    
    Использовать:

        Лучше хранить IP-адреса как беззнаковые целые числа. В MySQL имеются функции INET_ATON() и INET_NTOA() для преобразования между двумя представлениями.
*/

/*
    В типе данных DECIMAL также можно хранить большие числа, не помещающиеся в типе BIGINT.
*/

/*
    Системы объектно-реляционного отображения (Object-relational mapping – ORM) – еще один кошмар для желающих достичь высокой производительности. Мы советуем вам хорошо подумать, прежде чем променять производительность на удобство разработки.
*/

/*
    Основы индексирования.

    Индексы (ключи) представляют собой структуры, которые помогают MySQL эффективно извлекать данные. Индексирование является главной причиной проблем с производительностью в реальных условиях.

    Самый простой способ понять, как работает индекс в MySQL, – представить себе алфавитный указатель в книге. Чтобы выяснить, в какой части издания обсуждается конкретный вопрос, вы смотрите в алфавитный указатель и находите номер страницы, где упоминается термин. 

    Допустим, выполняется следующий запрос: SELECT name FROM users WHERE user_id = 5. По столбцу user_id построен индекс, поэтому MySQL будет использовать его для поиска строк, в которых значением поля user_id является 5. Другими словами, она производит поиск значений в индексе.

    Использовать:

        Если индекс построен по нескольким столбцам, то их порядок следования очень важен, поскольку MySQL может осуществлять поиск эффективно только по самой левой части ключа.

    Создание индекса по двум столбцам – это совсем не то же самое, что создание двух отдельных индексов по одному столбцу.

    Типы индексов:

        - B-Tree-индексы

            Это индексы без упоминания типа. Большинство подсистем хранения в MySQL поддерживает этот тип. Исключение – подсистема Archive. Общая идея заключается в том, что значения хранятся по порядку, и все листовые страницы находятся на одинаковом расстоянии от корня. B-Tree-индекс ускоряет доступ к данным, поскольку подсистеме хранения не нужно сканировать всю таблицу для поиска нужной информации. Вместо этого она начинает с корневого узла. В корневом узле имеется массив указателей на дочерние узлы, и подсистема хранения переходит по этим указателям.

            Использовать:

                Поскольку в B-Tree индексах индексированные столбцы хранятся в упорядоченном виде, то они полезны для поиска по диапазону данных.

            Типы запросов, в которых может использоваться B-Tree-индекс:

                - B-Tree-индексы хорошо работают при поиске по полному значению ключа, по диапазону ключей или по префиксу ключа.

                    Пример создания:

                        CREATE TABLE (
                            last_name VARCHAR(50) NOT NULL,
                            first_name VARCHAR(50) NOT NULL,
                            key (last_name, first_name)
                        );

                    - Поиск по полному значению (При поиске с полным значением ключа задаются критерии для всех столбцов, по которым построен индекс. Например, индекс позволит найти человека по имени Cuba Allen, родившегося 1 января 1960.)

                    - Поиск по самому левому префиксу (Индекс позволит найти всех людей с фамилией Allen. В этом случае используется только первый столбец индекса.)

                    - Поиск по префиксу столбца (Вы можете искать соответствие по началу значения столбца. Рассматриваемый индекс позволит найти всех людей, чьи фамилии начинаются с буквы J. В этом случае используется только первый столбец индекса.)

                    - Поиск по диапазону значений (Индекс позволит найти всех людей с фамилиями, начиная с Allen и кончая Barrymore. В этом случае используется только первый столбец индекса.)

                    - Поиск по полному совпадению одной части и диапазону в другой части (Индекс позволит найти всех людей с фамилией Allen, чьи имена начинаются с буквы K (Kim, Karl и т. п.). Полное совпадение со столбцом last_name и поиск по диапазону значений столбца first_name.)

                    - Запросы только по индексу

            У B-Tree-индексов есть некоторые ограничения:

                - Они бесполезны, если в критерии поиска указана не самая левая часть ключа индекса. Например, рассматриваемый индекс не поможет найти людей с именем Bill или всех людей с определенной датой рождения, поскольку эти столбцы не являются самыми левыми в индексе.

                - Нельзя пропускать столбцы индекса. То есть, невозможно найти всех людей, имеющих фамилию Smith и родившихся в конкретный день.

        - Хеш-индексы
        
            Хеш-индекс строится на основе хеш-таблицы и полезен только для точного поиска с указанием всех столбцов индекса. Для каждой строки подсистема хранения вычисляет хеш-код индексированных столбцов – сравнительно короткое значение, которое, скорее всего, будет различно для строк с разными значениями ключей. В индексе хранятся хеш-коды и указатели на соответствующие строки. В MySQL только подсистема хранения Memory поддерживает явные хеш-индексы.

            Подсистема хранения InnoDB поддерживает так называемые адаптивные хеш-индексы. Когда InnoDB замечает, что доступ к некоторым значениям индекса происходит очень часто, она строит для них хеш-индекс в памяти, помимо уже имеющихся B-Tree-индексов. Тем самым к B-Tree-индексам добавляются некоторые свойства хеш-индексов, например очень быстрый поиск. Этот процесс полностью автоматический, и вы не можете ни контролировать, ни настраивать его.

            Использовать:

                Идея проста: создайте псевдохеш-индекс поверх стандартного B-Tree-индекса. Он будет не совсем идентичен настоящему хеш-индексу, поскольку для поиска по-прежнему будет использоваться B-Tree-индекс. Однако искаться будут хеш-коды ключей вместо самих ключей. От вас требуется лишь вручную указать хеш-функцию во фразе WHERE запроса. Примером хорошей работы подобного подхода является поиск адресов URL. B-Tree-индексы по адресам URL обычно оказываются очень большими, поскольку сами URL длинные. Обычно запрос к таблице адресов URL выглядит примерно так: SELECT id FROM url WHERE url="http://www.mysql.com". Но если удалить индекс по столбцу url и добавить в таблицу индексированный столбец url_crc, то можно переписать этот запрос в таком виде: SELECT id FROM url WHERE url="http://www.mysql.com" AND url_crc=CRC32("http://www.mysql.com"). Этот подход хорошо работает, поскольку оптимизатор запросов MySQL замечает, что существует небольшой высокоизбирательный индекс по столбцу url_crc, и осуществляет поиск в индексе элементов с этим значением (в данном случае 1560514994). Даже если несколько строк имеют одно и то же значение url_crc, эти строки очень легко найти с помощью быстрого целочисленного сравнения, а затем отыскать среди них то, которое в точности соответствует полному адресу URL. Альтернативой является индексирование URL как строки, что происходит значительно медленнее. При таком подходе не следует использовать хеш-функции SHA1() или MD5(). Они возвращают очень длинные строки, которые требуют много пространства и приводят к замедлению сравнения. Если в таблице большое количество строк и функция CRC32() дает слишком много коллизий, реализуйте собственную 64-разрядную хеш-функцию. Такая функция должна возвращать целое число, а не строку.
        
        - Полнотекстовые (FULLTEXT) индексы
            
            Специальный тип индекса для таблиц типа MyISAM. Он позволяет искать в тексте ключевые слова, а не сравнивать искомое значение со значениями в столбце. Полнотекстовые индексы предназначены для операций MATCH AGAINST, а не обычных операций с фразой WHERE.

        - Кластерные индексы

            Кластерные индексы не являются отдельным типом индекса. Скорее, это подход к хранению данных. В InnoDB кластерный индекс фактически содержит и B-Tree- индекс, и сами строки в одной и той же структуре.

        - Покрывающие индексы

            Индексы являются средством эффективного поиска строк, но MySQL может также использовать индекс для извлечения данных, не считывая строку таблицы. Рассмотрим преимущества считывания индекса вместо самих данных:

                1. Записи индекса обычно компактнее полной строки, поэтому, если MySQL читает только индекс, то обращается к значительно меньшему объему данных.

                2. Индексы отсортированы по индексируемым значениям (по крайней мере, внутри страницы), поэтому для поиска по диапазону, характеризуемому большим объемом ввода/вывода, потребуется меньше операций обращения к диску по сравнению с извлечением каждой строки из произвольного места хранения.

                3. Большинство подсистем хранения кэширует индексы лучше, чем сами данные

                4. Покрывающие индексы особенно полезны в случае таблиц InnoDB из-за кластерных индексов.

    Стратегии индексирования для достижения высокой производительности.

        Изоляция столбца. MySQL обычно не может использовать индекс по столбцу, если этот столбец не изолирован в запросе. «Изоляция» столбца означает, что он не должен быть частью выражения или употребляться в качестве аргумента внутри функции. Например: SELECT author_id FROM authors WHERE author_id + 1 = 5;

        Префиксные индексы и селективность индекса. Иногда нужно проиндексировать очень длинные символьные столбцы, из-за чего индексы становятся большими и медленными. Одной из стратегий является эмулирование хеш-индекса, как мы показали выше. Но порой этого оказывается недостаточно. Поэтому вы можете сэкономить пространство и получить хорошую производительность, проиндексировав первые несколько символов, а не все значение. Префикс столбца часто оказывается весьма избирательным, чтобы обеспечить хорошую производительность. Если вы индексируете столбцы типа BLOB или TEXT, либо очень длинные столбцы типа VARCHAR, то обязаны определять префиксные индексы, поскольку MySQL не позволяет индексировать такие столбцы по их полной длине. Сложность заключается в выборе длины префикса, которая должна быть достаточно велика, чтобы обеспечить хорошую селективность, но не слишком велика, чтобы сэкономить пространство. Теперь, отыскав подходящую длину префикса для наших тестовых данных, создадим индекс по префиксу столбца: ALTER TABLE sakila.city_demo ADD KEY (city(7)). Префиксные индексы могут стать хорошим способом уменьшения размера и повышения быстродействия индекса, но у них есть и недостатки - MySQL не может использовать префиксные индексы для запросов с фразами ORDER BY и GROUP BY.

    Использование просмотра индекса для сортировки.

        В СУБД MySQL есть два способа получения отсортированных результатов: использовать файловую сортировку или просматривать индекс по порядку. 

        Просмотр самого индекса производится быстро, поскольку сводится просто к перемещению от одной записи к другой. Однако если СУБД MySQL не использует индекс для «покрытия» запроса, ей приходится считывать каждую строку, которую она находит в индексе.

        Использовать:

            MySQL может использовать один и тот же индекс как для сортировки, так и для поиска строк. По возможности старайтесь проектировать индексы так, чтобы они были полезны для решения обеих задач.

        Сортировка результатов по индексу работает только в тех случаях, когда порядок элементов в точности соответствует порядку, указанному во фразе ORDER BY, а все столбцы отсортированы в одном направлении (по возрастанию или по убыванию). Если в запросе соединяется несколько таблиц, то необходимо, чтобы во фразе ORDER BY упоминались только столбцы из первой таблицы. Фраза ORDER BY имеет те же ограничения, что и поисковые запросы: должен быть указан самый левый префикс ключа. Во всех остальных случаях MySQL использует файловую сортировку.
*/