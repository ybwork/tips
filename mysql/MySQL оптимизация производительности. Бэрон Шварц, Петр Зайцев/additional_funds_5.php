<?php

/*
    Глава 5. Расширенные средства MySQL
*/

/*
    Например, хранимые процедуры, представления и триггеры.
*/

/*
    Кэш запросов MySQL.

    В кэше запросов MySQL хранится в точности тот результат, который запрос вернул клиенту. При попадании в кэш запросов сервер сразу же возвращает сохраненные итоги, пропуская стадии разбора, оптимизации и выполнения.

    Кэш запросов отслеживает, какие таблицы были использованы в запросе, и, если хотя бы одна из них изменилась, данные в кэше становятся недействительными.

    Следует также иметь в виду, что результат не попадет в кэш запросов, если сгенерирован недетерминированным запросом. Иначе говоря, любой запрос, содержащий недетерминированную функцию, например NOW() или CURRENT_DATE(), не кэшируется. Аналогично, такие функции, как CURRENT_USER() и CONNECTION_ID(), дают разные результаты в зависимости от того, каким пользователем вызваны, поэтому также препятствуют записи запроса в кэш.

    Кроме того, кэш не работает для запросов, в которых есть ссылки на определенные пользователем функции, хранимые процедуры, пользовательские переменные, временные таблицы и т.д.

    Использовать:

        Есть полезный прием, позволяющий все же закэшировать запросы, ссылающиеся на текущую дату; для этого нужно включить дату в виде литерала, вместо использования функции. Например:

            DATE_SUB(CURRENT_DATE, INTERVAL 1 DAY) - не кэшируется!

            DATE_SUB(‘2007-07-14’, INTERVAL 1 DAY) - кэшируется

    Минусы кэширования запросов:

        - Перед началом обработки запроса на чтение нужно проверить, есть ли он в кэше

        - Если запрос допускает кэширование, но еще не помещен в кэш, то нужно потратить некоторое время на запись в кэш сгенерированных результатов

        - Наконец, при обработке любого запроса на запись необходимо сделать недействительными все записи в кэше, в которых встречается измененная таблица

    Пользователей InnoDB подстерегает еще одна проблема: полезность кэша ограничена транзакциями. Если какая-то команда внутри транзакции модифицирует таблицу, то сервер делает недействительными все кэшированные запросы, ссылающиеся на эту таблицу.
*/

/*
    Когда полезен кэш запросов.

    Выигрывают от наличия кэша те запросы, которые долго выполняются, но занимают в кэше немного места, так что их хранение, возврат клиенту и инвалидация обходятся дешево. В эту категорию попадают, в частности, агрегирующие запросы, например, с функцией COUNT() для больших таблиц. Но есть и много других типов запросов, которые имеет смысл кэшировать.
*/

/*
    Как настраивать и обслуживать кэш запросов.

        query_cache_type - режим кэширования запросов. Допустимые значения: OFF, ON, DEMAND.

        query_cache_size - общий объем памяти, отведенной под кэш запросов, в байтах. Значение должно быть кратно 1024, поэтому MySQL, возможно, слегка изменит заданное вами число.

        query_cache_min_res_unit - Минимальный размер выделяемого блока.

        query_cache_limit - Размер максимального результирующего набора, который разрешено кэшировать. Если при выполнении запроса результирующий набор оказывается больше, он не кэшируется.

        query_cache_wlock_invalidate - Следует ли обслуживать из кэша результаты, которые относятся к таблицам, заблокированным другими соединениями. По умолчанию этот параметр равен OFF.        
*/

/*
    Уменьшение фрагментации.

    Полностью избежать фрагментации невозможно, но тщательный выбор параметра query_cache_min_res_unit может помочь не расходовать понапрасну память. Если задать слишком маленькое значение, то сервер будет терять меньше памяти, но блоки ему придется выделять чаще, а, значит, объем работы увеличится.
*/

/*
    Улучшение коэффициента загрузки кэша.

    Если кэш не фрагментирован, но коэффициент попадания все равно низкий, то, возможно, вы отвели под него слишком мало памяти. Когда сервер не может найти свободный блок, достаточно большой для сохранения нового результата, он должен «вытеснить» (prune) из кэша какие-то запросы.
*/

/*
    InnoDB и кэш запросов.

    InnoDB сообщает серверу, для каждой таблицы в отдельности, может ли транзакция обращаться к кэшу запросов. Она управляет доступом к кэшу как для операций чтения (выборки результатов из кэша), так и для операций записи (сохранения результатов в кэше).
*/

/*
    Общие оптимизации кэша запросов.

    Испльзовать:

        Наличие нескольких маленьких таблиц вместо одной большой часто повышает эффективность использования кэша запросов. При этом стратегия объявления записей недействительными работает на более мелком уровне. Но не придавайте этому соображению решающего значения при проектировании схемы, поскольку другие факторы могут легко перевесить все достигаемые таким образом выгоды.

        Более эффективно собирать операции записи в пакет, чем выполнять их по одиночке.

        Мы обратили внимание, что сервер может на длительное время «зависать», будучи занят инвалидацией записей или вытеснением запросов из большого кэша. Самое простое решение – не задавать слишком большое значение параметра query_cache_size; 256 Мбайт должно быть более, чем достаточно.

        Невозможно контролировать кэш запросов на уровне отдельной базы данных или таблицы, но можно включать в некоторые команды SELECT модификаторы SQL_CACHE или SQL_NO_CACHE. Можно также включать или выключать кэширование для отдельного соединения, установив подходящее значение сеансовой переменной query_cache_type.

        Для приложений, выполняющих много операций записи, иногда можно повысить производительность, полностью отключив кэширование. При этом исключаются накладные расходы на кэширование запросов, которые в скором времени все равно были бы объявлены недействительными.
*/

/*
    Альтернативы кэшу запросов.

    Альтернативой кэширование запросов может стать кэширование на стороне клиента, оно может еще больше снизить нагрузку на сервер.
*/

/*
    Хранение кода внутри MySQL.

    MySQL позволяет хранить код на стороне сервера в форме триггеров, хранимых процедур, хранимых функций и сохранять код в периодически выполняемых заданиях, которые называются событиями.

    Плюсы:

        - Это положительно сказывается на безопасности и позволяет более точно управлять привилегиями. Типичный пример – хранимая процедура для перевода средств с одного банковского счета на другой. Можно дать приложению право вызывать хранимую процедуру, не открывая доступ к используемым в ней таблицам.

        - Сервер кэширует планы выполнения хранимых процедур, что снижает накладные расходы на повторные вызовы.

    Минусы:

        - Вместе с MySQL не поставляются хорошие инструменты разработки и отладки, поэтому писать хранимый код для MySQL труднее, чем для других СУБД. (проверить)

        - Наличие хранимого кода может даже усложнить развертывание приложения. Приходится не только вносить изменения в саму программу и схему базы данных, но и развертывать код, хранящийся внутри сервера.

        - MySQL предлагает весьма скромные средства контроля над ресурсами, выделяемыми для исполнения хранимого кода, поэтому ошибка может привести к отказу всего сервера.

    Нужно лишь понимать, что, прибегая к хранимому коду, вы помещаете логику на сервер базы данных.
*/

/*
    Хранимые процедуры и функции.

    Использовать:

        Мы обычно предпочитаем писать небольшие, простые хранимые процедуры. На наш взгляд, сложную логику лучше оставить вовне базы данных и реализовывать ее с помощью более выразительного и гибкого процедурного языка.

        Однако для некоторых операций хранимые процедуры могут оказаться гораздо быстрее, особенно если речь идет о мелких запросах. Чтобы доказать это, мы написали простенькую хранимую процедуру, которая вставляет в таблицу заданное количество строк. Затем мы сравнили время вставки миллиона строк с помощью этой процедуры и последовательной вставки из клиентского приложения. Хранимая процедура работает гораздо быстрее, главным образом из-за отсутствия накладных расходов на передачу по сети, разбор, оптимизацию и т.д.
*/

/*
    Триггеры.

    Испльзовать:

        Триггеры дают возможность выполнить код, когда встречаются команды INSERT, UPDATE или DELETE. Вы можете заставить MySQL обрабатывать триггеры до и/или после выполнения самой команды. Триггер не возвращает значения, но в состоянии читать и/или изменять данные, которые были модифицированы командой, вызвавшей его срабатывание.

        Триггеры позволяют упростить логику приложения и повысить производительность, поскольку избавляют от необходимости обмениваться данными по сети. Они также бывают полезны для автоматического обновления денормализованных и сводных таблиц.

        В каждой таблице для каждого события можно определить только один триггер.

        MySQL поддерживает только триггеры на уровне строки, т.е. триггер всегда работает в режиме FOR EACH ROW, а не для команды в целом. При обработке больших наборов данных это гораздо менее эффективно.

        Триггеры могут стать причиной неочевидных взаимоблокировок и ожиданий блокировок. Если в триггере возникает ошибка, то с ошибкой завершается и исходный запрос, а если вы не знаете о существовании триггера, то разобраться, о чем говорит код ошибки, будет затруднительно. Поэтому берём и пишем комментарий возле простого на первый взгляд зарпоса.

        Триггеры можно применять и с целью протоколирования обновлений строк. Это полезно для «самописных» схем репликации, когда требуется разорвать соединение между двумя системами, изменить данные, а затем восстановить синхронизацию. Простой пример – группа пользователей, которые берут с собой ноутбуки в другой офис. Произведенные ими изменения нужно затем синхронизировать с главной базой данных, после чего скопировать главную базу обратно на отдельные ноутбуки. Эта задача требует двусторонней синхронизации. Триггеры неплохо подходят для построения подобных систем. На каждом ноутбуке с помощью триггеров все операции модификации данных протоколируются в специальные таблицы с указанием того, какие строки изменились. Затем специально написанная программа синхронизации переносит изменения в главную базу данных. А уже потом с помощью стандартной репликации MySQL можно синхронизировать ноутбуки с главной базой, в результате чего на каждом переносном компьютере окажутся изменения, произведенные на всех остальных ноутбуках.
*/

/*
    События.

    Использовать:

        События – это новый вид хранимого кода, появившийся в MySQL начиная с версии 5.1. Они похожи на задания cron, но выполняются целиком внутри сервера MySQL. Можно создать событие, которое будет обрабатывать SQL-код в требуемый момент времени или с заданным интервалом. Обычно поступают так: оформляют сложный SQL-код в виде хранимой процедуры, а событие просто вызывает ее с помощью команды CALL.

        Накладные расходы на сам запуск событий минимальны, но команды, которые выполняются внутри них, могут оказать заметное воздействие на производительность. Разумно использовать события для периодического запуска задач обслуживания, в том числе перестроения кэша и сводных таблиц, эмулирующих материализованные представления, а также для сохранения переменных состояния с целью мониторинга и диагностики.

        Наконец, если для выполнения периодического события требуется длительное время, то может случиться так, что оно в очередной раз активируется в момент, когда предыдущее еще не завершилось. MySQL не защищает вас от этого, так что придется написать собственную логику взаимного исключения. Чтобы гарантировать, что работает только один экземпляр события, можно воспользоваться функцией GET_LOCK().
*/

/*
    Сохранение комментариев в хранимом коде.

    Чтобы оставить комментарии в хранимом коде, существует полезный прием: воспользоваться зависящими от версии комментариями, которые сервер воспринимает как потенциально исполняемый код (т.е. код, который сервер будет выполнять, если номер его версии не меньше указанного). И сервер, и клиентские программы знают, что это не обычные комментарии, поэтому не удаляют их. Чтобы такой «код» гарантированно не выполнялся, можно просто задать очень большой номер версии, скажем 99999. Пример комментария:

        /*!999999
            Текст комментария.
        */
*/

/*
    Курсоры.

    Использовать:

        В настоящее время MySQL предлагает однонаправленные (с прокруткой вперед) серверные курсоры только для чтения, и использовать их можно лишь в хранимых процедурах. Курсор позволяет построчно обойти результат запроса, извлекая строки в переменные для последующей обработки. Хранимая процедура позволяет открывать сразу несколько курсоров, причем они могут быть «вложены» друг в друга (во вложенных циклах).

        Для непосвященного устройство курсоров в MySQL таит немало сюрпризов. Поскольку курсоры реализованы с помощью временных таблиц, у разработчика может возникнуть ложное ощущение эффективности. Самое важное, что нужно помнить, – это то, что курсор выполняет весь запрос в момент открытия.

        Курсор можно закрыть до завершения обхода результатов. Разработчик, привыкший к Oracle или Microsoft SQL Server, возможно, и не заметит в этой процедуре ничего плохого, но в MySQL она приводит к массе лишней работы. Мораль заключается в том, что раннее закрытие курсора, выбирающего данные из большой таблицы, не дает никакой экономии. Если нужно всего несколько строк, воспользуйтесь фразой LIMIT.
*/

/*
    Подготовленные команды.

    Использовать:

        Получить доступ к функциональности подготовленных команд позволяют библиотеки, поддерживающие новый протокол, например MySQL C API.

        В момент создания подготовленной команды клиентская библиотека посылает серверу прототип будущего запроса. Сервер разбирает и обрабатывает эту «заготовку» запроса, сохраняет структуру, представляющую частично оптимизированный запрос, и возвращает клиенту дескриптор команды.

        Например, можно подготовить такой запрос: INSERT INTO tbl (col1, col2, col3) VALUES (?, ?, ?)

        Чтобы впоследствии выполнить этот запрос, серверу необходимо отправить дескриптор команды и значения всех параметров, представленных вопросительными знаками. Это действие можно повторять сколько угодно раз. Использование подготовленных команд может оказаться эффективнее повторного выполнения запросов.
*/

/*
    Ограничения подготовленных команд.
    
    Использовать:

        Подготовленные команды локальны по отношению к соединению, поэтому в другом соединении тот же самый дескриптор использовать нельзя. По той же причине клиент, который разрывает и вновь устанавливает соединение, теряет все подготовленные команды (смягчить эту проблему позволяет пул соединений и устойчивые соединения).

        Использование подготовленных команд не всегда эффективно. Если подготовленная команда выполняется всего один раз, вы можете потратить на подготовку больше времени, чем ушло бы на выполнение обычной SQL-команды. Кроме того, для подготовки команды необходимо дополнительное обращение к серверу.

        В настоящее время подготовленные команды нельзя использовать в хранимых функциях (но можно в хранимых процедурах).

        Если вы забудете освободить дескриптор подготовленной команды, то возникнет «утечка». Это может приводить к потерям большого количества ресурсов сервера.
*/

/*
    Определяемые пользователем функции.

    Испльзовать:

        В отличие от хранимых функций, которые пишутся на языке SQL, определяемые пользователем функции можно писать на любом языке программирования, который поддерживает соглашения о вызове. Ошибка в функции может привести к аварийному останову сервера, запортить память или данные пользователя и вообще внести хаос.
*/

/*
    Представления.

    Использовать:

        Представления – это широко распространенный в СУБД механизм. В MySQL таблицы и представления – не одно и то же. Например, для представления нельзя создать триггер, и невозможно удалить представление командой DROP TABLE.

        Более правильный способ реализации представлений – переписать запрос, в котором встречается представление, объединив SQL-код самого запроса с SQL-кодом представления.
*/

/*
    Обновляемые представления.

    Использовать:

        Обновляемое представление позволяет изменять данные в базовой таблице через ее представление. При соблюдении определенных условий к представлению можно применять команды UPDATE, DELETE и даже INSERT, как к обычной таблице.

        Представление не является обновляемым, если оно содержит фразы GROUP BY, UNION, агрегатную функцию, а также еще в нескольких случаях.
*/

/*
    Представления и производительность.

    Большинство разработчиков не считают, что представления могут както повысить производительность, однако в MySQL это не так. 
*/

/*
    Ограничения представлений.

    MySQL не поддерживает материализованные представления, с которыми вы, возможно, знакомы по работе с другими СУБД. В общем случае материализованное представление хранит результаты выполнения в невидимой таблице, которую периодически обновляет по исходным данным. MySQL также не поддерживает индексированные представления.
*/

/*
    Умолчания при создании объектов.

    При создании базы данных кодировка наследуется от определенного на уровне сервера параметра character_set_server.

    При создании таблицы кодировка наследуется от базы данных.

    При создании столбца кодировка наследуется от таблицы.
*/

/*
    Выбор кодировки и схемы упорядочения.

    Смесь разных кодировок в одной базе данных может привести к хаосу. Несовместимые кодировки служат источником разнообразных ошибок.
*/

/*
    Ограничения внешнего ключа.

    В настоящее время InnoDB – основная подсистема хранения для MySQL, поддерживающая внешние ключи. Как правило, их наличие означает, что сервер должен заглядывать в другую таблицу при каждом изменении определенных данных. Хотя для ускорения операции InnoDB принудительно строит индекс, это вовсе не устраняет все негативные последствия подобных проверок.

    И все же в некоторых случаях внешние ключи могут повысить производительность. Если жизненно необходимо гарантировать, что данные в двух взаимосвязанных таблицах непротиворечивы, то эффективнее поручить проверку серверу, а не заниматься этим на уровне приложения. Внешние ключи полезны также для каскадного удаления и обновления, хотя эти операции выполняются построчно, то есть медленнее, чем запрос с обновлением нескольких таблиц или пакетная операция.

    Использовать:

        Из-за внешних ключей запрос может «распространяться» на другие таблицы, а это означает захват блокировок. Например, при попытке вставить строку в подчиненную таблицу, ограничение внешнего ключа заставит InnoDB проверить наличие соответствующего значения в главной таблице. При этом необходимо установить блокировку на строку главной таблицы, чтобы ее никто не удалил до завершения транзакции. Это может привести к неожиданному ожиданию блокировки и даже к взаимоблокировкам на таблицах, к которым вы напрямую не обращаетесь. Такого рода проблемы далеки от интуитивно очевидных и решать их очень трудно.
*/

/*
    Объединенные таблицы и секционирование.

    Объединенные таблицы и секционирование – взаимосвязанные понятия, которые легко спутать. В MySQL объединенные таблицы (merge tables) – это способ объединить несколько таблиц типа MyISAM в одну «виртуальную таблицу». Это очень похоже на представление, в котором таблицы объединяются посредством фразы UNION. Объединенная таблица создается с помощью подсистемы хранения Merge, и, строго говоря, не является таблицей. Она больше напоминает контейнер для таблиц с похожими определениями.

    Напротив, секционированные таблицы (partitioned tables) выглядят как обычные таблицы со специальным набором указаний, сообщающих MySQL, где нужно физически хранить строки. Откроем секрет: код, реализующий хранение секционированных таблиц, очень похож на код для объединенных таблиц! Фактически, на нижнем уровне каждая секция представляет собой отдельную таблицу со своими индексами, а вся секционированная таблица – это просто обертка вокруг набора объектов Handler. Секционированная таблица выглядит и ведет себя, как единая таблица, хотя на самом деле является совокупностью отдельных таблиц. Однако обратиться к таблицам-секциям напрямую невозможно, тогда как объединенные таблицы это позволяют.
*/