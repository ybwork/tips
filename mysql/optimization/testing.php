<?php

// Глава 2.

/*
    Итак, у вас возникла необходимость повысить производительность MySQL. Но что пытаться улучшить? Конкретный запрос? Схему? Оборудование? Единственный способ узнать это – оценить, что именно делает ваша система, и протестировать ее производительность в разных условиях.

    Эталонное тестирование (benchmarking) и профилирование (profiling) – вот два важнейших метода определения узких мест.

        Эталонное тестирование измеряет производительность системы.

        В свою очередь, профилирование помогает найти места, где приложение тратит больше всего времени и потребляет больше всего ресурсов.
*/

/*
    Эталонное тестирование.

    Области применения:

        - Измерить производительность приложения в текущий момент

        - Вы можете использовать эталонные тесты для эмуляции гораздо большей нагрузки, чем та, которую испытывает система сейчас

        - помогут оценить, какое оборудование, пропускная способность сети или другие ресурсы потребуются при планируемом увеличении нагрузки

        - Тестирование различных конфигураций оборудования, программного обеспечения и операционной системы

    Стратегии:

        - тестировать приложение целиком

        - только аспекты, относящиеся к MySQL

    Если вы плохо спроектируете тест, то можете прийти к неверным выводам, поскольку полученные подобным образом результаты не отражают реальности.

    Эталонное тестирование MySQL полезно, когда вы выполняете характерные для своего приложения запросы на реальном наборе данных. Но если их нет, то у вас нет другого выбора, кроме как сгенерировать больший объем данных и нагрузку.

    Перед началом тестирования нужно определить цели. Сформулируйте цели в виде вопросов, например «лучше ли этот процессор, чем тот?» или «будут ли новые индексы работать эффективнее, чем нынешние?».

    Так же следует обратить внимание на следующие показатели:

        - Количество транзакций в единицу времени. Это один из классических эталонных тестов приложений баз данных.

        - Время отклика или задержки. Этот показатель дает представление об общем времени исполнения задачи.

        - Масштабируемость. Измерение масштабируемости полезно для систем, в которых необходимо поддерживать стабильную производительность даже в условиях меняющейся нагрузки.

        - Уровень конкуренции. Более точная мера измерения конкуренции на веб-сервере – количество запросов в секунду, которые пользователи генерируют в пиковые периоды. В общем случае стоит ограничить конкуренцию на сервере MySQL, используя такие методы, как организация очередей на уровне приложений.

    Тактики эталонного тестирования.

        Наиболее частые ошибки эталонного тестирования, которые могут привести к непригодным или неточным результатам:

            - Использование набора данных, имеющего объем, несоизмеримый с рабочими объемами, например использование одного гигабайта данных, когда приложение должно будет обрабатывать сотни гигабайт

            - Использование данных с неправильным распределением, например равномерно распределенных, когда в реальных данных будут встречаться «горячие точки».

            - Использование нереалистично распределенных параметров, например в предположении, что частота просмотра всех профилей пользователей будет одинакова.

            - Использование однопользовательского сценария для многопользовательского приложения.

            - Тестирование распределенного приложения на единственном сервере.

            - Несоответствие реальному поведению пользователя, например неверное время просмотра одной страницы. Реальные пользователи запрашивают страницу, а потом читают ее. Они не щелкают по ссылкам без остановки.

            - Выполнение идентичных запросов в цикле. Реальные запросы неодинаковы.

            - Отсутствие контроля ошибок. Если результаты теста не имеют смысла – например, медленная операция внезапно очень быстро заканчиваетса, – ищите ошибку.

            - Игнорирование проверки работы системы сразу после ее запуска или перезагрузки. Иногда нужно знать, как быстро ваш сервер наберет «полную мощность» после перезагрузки. Наоборот, если вы предполагаете изучить производительность в нормальном режиме, убедитесь, что на результаты тестирования не повлияет «неразогретый» кэш.

        Проектирование и планирование тестов.

            Первым шагом в планировании тестов является определение проблемы и цели.

            Затем нужно решить, использовать ли стандартный тест или разработать свой собственный.

        Инструменты полного тестирования.

            Полное тестирование обычно является лучшим способом получить ясное представление о производительности системы. Для этого используются следующие инструменты:

                - ab. ab представляет собой широко известный инструмент тестирования производительности сервера HTTP Apache. Он показывает, сколько запросов в секунду способен обслуживать HTTP-сервер. Если вы тестируете веб-приложение, это число демонстрирует, какое количество запросов в секунду может обслужить приложение в целом. Это очень простой инструмент, но полезность его ограничена, поскольку он просто обращается к одному адресу URL настолько быстро, насколько это возможно.

                - http_load. Этот инструмент концептуально похож на ab. Он также предназначен для создания нагрузки на веб-сервер, но при этом является более гибким. Вы можете создать входной файл, включающий много разных адресов URL, а http_load будет выбирать их случайным образом. Вы также можете настроить параметры таким образом, что запросы станут отправляться с заданным интервалом, а не с максимально возможной скоростью.

                - JMeter. JMeter представляет собой приложение на языке Java, которое может загружать другое приложение и измерять его производительность. Эта программа была разработана для тестирования веб-приложений, но ее можно также использовать при тестировании FTP-серверов и для отправки запросов к базе данных через интерфейс JDBC. Программа JMeter значительно сложнее, чем ab и http_load. Например, с ее помощью можно более гибко эмулировать поведение реальных пользователей, управляя таким параметром, как время нарастания нагрузки.

            Инструменты покомпонентного тестирования.

                - mysqlslap. Эмулирует нагрузку на сервер и выдает данные хронометража. Эта программа является частью дистрибутива MySQL 5.1, но ее можно использовать и с более ранними версиями, начиная с 4.1. Данный инструмент позволяет настроить количество одновременных соединений и передать программе либо команду SQL в командной строке, либо файл с командами SQL, которые нужно выполнить. Если вы не зададите режим тестирования вручную, программа сама исследует схему базы данных и автоматически сгенерирует команды SELECT.

                - Database Test Suite. Представляет собой комплект программ для тестирования производительности, анало- гичный стандартным промышленным тестам, например опубликованным Советом по производительности обработки транзакций

                - MySQL Benchmark Suite. Среди главных недостатков этого инструмента можно упомянуть то, что он работает в однопользовательском режиме, задействует очень маленький набор исходных значений, не допускает тестирования на данных, характерных именно для ваших условий, а результаты могут отличаться от запуска к запуску. Поскольку он однопоточный и полностью последовательный, с его помощью невозможно оценить выигрыш от наличия нескольких процессоров, но вместе с тем он вполне пригоден для сравнения однопроцессорных серверов.

                - Super Smack. Предназначен для эталонного тестирования, тестирования под нагрузкой и создания нагрузки в применении к СУБД MySQL и PostgreSQL.

*/

/*
    Возьмите за правило всегда проверять после выполнения теста журнал ошибок.
*/

/*
    Функция BENCHMARK(), которую можно использовать при тестировании скорости выполнения определенных типов операций.

    Для этого нужно указать количество прогонов и подлежащее выполнению выражение. В качестве последнего может выступать любое скалярное выражение, например скалярный подзапрос или функция. Это удобно для тестирования относительных скоростей некоторых операций, например для выяснения того, какая функция работает быстрее: MD5() или SHA1():

        SET @input := 'hello world';
        SELECT BENCHMARK(1000000, MD5(@input));
        SELECT BENCHMARK(1000000, SHA1(@input));

    Эта функция просто измеряет, насколько быстро сервер может выполнить выражение, но не сообщает ничего о накладных расходах на синтаксический анализ и оптимизацию. А если выражение не включает в себя пользовательскую переменную, как в нашем примере, то второе и последующие выполнения сервером данного выражения могут оказаться обращением к кэшу. Поэтому не рекомендуется использовать данную функцию для реального тестирования производительности.
*/

/*
    Практические примеры тестов смотреть начиная со стр. 77 (они простые и можно использовать сразу)
*/

/*
    Профилирование.

    Профилирование показывает, какую долю вносит каждая часть системы в общую стоимость получения результата.

    Профилирование на уровне приложения обычно помогает понять, как оптимизировать его наилучшим образом, и дает более точные результаты, поскольку они включают в себя работу, выполненную всей системой.

    Доступ к базе данных часто, но не всегда, является узким местом приложения. Узкие места могут быть также вызваны одной из следующих причин:

        - Обращения к внешним ресурсам, например веб-сервисам или поисковым системам

        - Операции, которые требуют обработки больших объемов данных в приложении, например синтаксический анализ больших файлов XML

        - Дорогостоящие операции в циклах, например злоупотребление регулярными выражениями

        - Плохо оптимизированные алгоритмы, например наивные алгоритмы поиска в списках

        - Перед тем как начинать анализ запросов к MySQL, вы должны понять реальный источник ваших проблем с производительностью. Профилирование приложения поможет найти узкие места, и это важный шаг в мониторинге и увеличении общего быстродействия системы.

    Как и что измерять?

        Время является подходящей метрикой при профилировании большинства приложений, поскольку конечного пользователя больше всего интересует именно время работы.

        В веб-приложениях мы обычно предусматриваем режим отладки, в котором на каждой странице отображаются выполняемые запросы, а также момент их выполнения и количество возвращенных строк.

        Внедрить код профилирования в существующее приложение может оказаться трудной задачей, но в новые приложения включать его легко. 

        В PHP имеют встроенные функции для профилирования доступа к базам данных.

        Ваш код профилирования должен собирать и регистрировать, по меньшей мере, следующие сведения:

            - Общее время выполнения (в веб-приложениях это полное время генерирования страниц)

            - Каждый выполненный запрос и время его исполнения

            - Каждый факт открытия соединения с сервером MySQL

            - Каждое обращение к внешнему ресурсу, например к веб-сервисам, службе memcached и внешним вызываемым сценариям

            - Потенциально дорогостоящие вызовы функций, например синтаксический анализ XML

            - Процессорное время, потраченное в режиме пользователя и ядра

        Не замедлит ли профилирование работу ваших серверов?

            Да. Профилирование и мониторинг увеличивают накладные расходы. Поэтому лучше использовать облегченное профилирование. Можно просто профилировать случайную выборку, включая профилирование в конфигурационном файле приложения:

                $profiling_enabled = rand(0, 100) > 99;

        Пример профилирования приложения PHP смотреть на стр. 90
*/

/*
    Протоколирование запросов.

    В MySQL есть два типа журналов запросов: 

        - общий журнал

            В общий журнал каждый запрос заносится в момент поступления серверу, поэтому там присутствуют даже те запросы, которые не были выполнены из-за возникших ошибок. Вы можете включить этот журнал с помощью одного конфигурационного параметра: log = <имя_файла>. Естественно, общий журнал не содержит сведений о времени выполнения и иной информации, доступной только после завершения запроса.

        - журнал медленных запросов

            Журнал медленных запросов включает только данные о выполненных запросах. Точнее, здесь протоколируются запросы, выполнение которых заняло время, превышающее установленный порог. Для профилирования могут быть полезны оба журнала, но журнал медленных запросов является основным инструментом, позволяющим выявить проблемные запросы. Обычно мы рекомендуем включать его.

            В следующем примере конфигурации этот журнал включается, и в нем
            регистрируются все запросы, выполнение которых занимает больше
            двух секунд, а также запросы, для обработки которых не были задействованы индексы. Кроме того, будут протоколироваться медленные административные запросы, например OPTIMIZE TABLE:

                log-slow-queries = <имя_файла>
                long_query_time = 2
                log-queries-not-using-indexes
                log-slow-admin-statements

            Вам нужно подстроить эти параметры под себя в конфигурационном файле сервера my.cnf

            Значением по умолчанию для параметра long_query_time является 10 секунд. В большинстве случаев это слишком много, поэтому мы обычно задаем две секунды. Однако во многих случаях и одной секунды более чем достаточно.

    Как читать журнал медленных запросов см. на стр. 101

    В общем случае при исследовании журналов следует обращать внимание на следующие три вещи:

        - Долго выполняющиеся запросы

        - Запросы, больше всего нагружающие сервер

        - Новые запросы

    Вот некоторые из наиболее распространенных приложений, предназначенных для анализа журналов:

        - mysqldumpslow (Преимуществом программы mysqldumpslow является то, что она уже имеется в комплекте с СУБД. Недостаток ее в том, что она несколько менее гибкая, чем некоторые другие инструменты)

        - mysql_slow_log_filter

        - mysql_slow_log_parser

        - mysqlsla

    Профилирование сервера MySQL.

        Один из лучших способов профилировать сервер – то есть увидеть, на что он тратит большую часть времени, заключается в использовании команды SHOW STATUS, которая возвращает много информации о состоянии. (Команда SHOW STATUS ведет себя несколько каверзно и это может привести к плохим результатам в MySQL 5.0 и более новых версиях)

        Чтобы увидеть в режиме, близком к реальному времени, как работает ваш сервер, периодически запускайте команду SHOW STATUS и сравнивайте результат с предыдущим запуском. Вы можете делать это с помощью следующей команды:

            mysqladmin extended -r -i 10

            Некоторые из переменных не являются строго возрастающими счетчиками, так что вы можете увидеть странные результаты типа отрицательного значения Threads_running. Не беспокойтесь по этому поводу, просто счетчик уменьшился с момента предыдущей выборки.

        Еще одним хорошим способом профилирования сервера MySQL является использование команды SHOW PROCESSLIST. Она позволяет видеть не только типы выполняющихся запросов, но и состояние соединений. Некоторые вещи, например большое количество соединений в состоянии Locked, являются явными указаниями на узкие места. Как и в случае команды SHOW STATUS, вывод SHOW PROCESSLIST достаточно подробен. Обычно гораздо удобнее использовать такие инструменты, как innotop, чем разбирать его вручную.

    Профилирование операционной системы.

    Иногда бывает полезно получить статистику операционной системы и попытаться выяснить, что же делают ОС и оборудование. Это может помочь не только при профилировании приложения, но и в процессе поиска неполадок. Чаще всего мы используем инструменты vmstat, iostat, mpstat и strace. Будьте осторожны при использовании программы strace в GNU/Linux на рабочих серверах. Похоже, она не всегда правильно работает с многопоточными процессами, и нам доводилось видеть, как ее использование приводило к аварийной остановке сервера.
*/

/*
    Например, запрос продолжительностью 10 миллисекунд, который запускается 1000 раз в секунду, нагрузит сервер сильнее, чем десятисекундный запрос, запускаемый один раз в секунду. Чтобы выявить такую проблему, требуется протоколировать все запросы и проанализировать результаты.
*/