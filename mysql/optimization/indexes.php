<?php

/*
    Оптимизация схемы и индексирование.

        Если вам требуется высокое быстродействие, вы должны разработать схему и индексы под те конкретные запросы, которые будете запускать. 

        Оптимизация часто требует компромиссов. Например, добавление индексов для ускорения выборки данных замедляет их изменение. Аналогично денормализованная схема ускоряет некоторые типы запросов, но замедляет другие.

        Оптимизация схемы и индексирование потребуют как взгляда на картину в целом, так и внимания к деталям. Вам нужно понимать всю систему, чтобы разобраться, как каждая ее часть влияет на остальные.
*/

/*
    Основы индексирования.

    Индексы (ключи) представляют собой структуры, которые помогают MySQL эффективно извлекать данные. Индексирование является главной причиной проблем с производительностью в реальных условиях.

    Самый простой способ понять, как работает индекс в MySQL, – представить себе алфавитный указатель в книге. Чтобы выяснить, в какой части издания обсуждается конкретный вопрос, вы смотрите в алфавитный указатель и находите номер страницы, где упоминается термин. 

    Допустим, выполняется следующий запрос: SELECT name FROM users WHERE user_id = 5. По столбцу user_id построен индекс, поэтому MySQL будет использовать его для поиска строк, в которых значением поля user_id является 5. Другими словами, она производит поиск значений в индексе.

    Использовать:

        Если индекс построен по нескольким столбцам, то их порядок следования очень важен, поскольку MySQL может осуществлять поиск эффективно только по самой левой части ключа.

    Создание индекса по двум столбцам – это совсем не то же самое, что создание двух отдельных индексов по одному столбцу.

    Типы индексов:

        - B-Tree-индексы

            Это индексы без упоминания типа. Большинство подсистем хранения в MySQL поддерживает этот тип. Исключение – подсистема Archive. Общая идея заключается в том, что значения хранятся по порядку, и все листовые страницы находятся на одинаковом расстоянии от корня. B-Tree-индекс ускоряет доступ к данным, поскольку подсистеме хранения не нужно сканировать всю таблицу для поиска нужной информации. Вместо этого она начинает с корневого узла. В корневом узле имеется массив указателей на дочерние узлы, и подсистема хранения переходит по этим указателям.

            Использовать:

                Поскольку в B-Tree индексах индексированные столбцы хранятся в упорядоченном виде, то они полезны для поиска по диапазону данных.

            Типы запросов, в которых может использоваться B-Tree-индекс:

                - B-Tree-индексы хорошо работают при поиске по полному значению ключа, по диапазону ключей или по префиксу ключа.

                    Пример создания:

                        CREATE TABLE (
                            last_name VARCHAR(50) NOT NULL,
                            first_name VARCHAR(50) NOT NULL,
                            bithday DATETIME NOT NULL,
                            key (last_name, first_name)
                        );

                    - Поиск по полному значению (При поиске с полным значением ключа задаются критерии для всех столбцов, по которым построен индекс. Например, индекс позволит найти человека по имени Cuba Allen, родившегося 1 января 1960.)

                    - Поиск по самому левому префиксу (Индекс позволит найти всех людей с фамилией Allen. В этом случае используется только первый столбец индекса.)

                    - Поиск по префиксу столбца (Вы можете искать соответствие по началу значения столбца. Рассматриваемый индекс позволит найти всех людей, чьи фамилии начинаются с буквы J. В этом случае используется только первый столбец индекса.)

                    - Поиск по диапазону значений (Индекс позволит найти всех людей с фамилиями, начиная с Allen и кончая Barrymore. В этом случае используется только первый столбец индекса.)

                    - Поиск по полному совпадению одной части и диапазону в другой части (Индекс позволит найти всех людей с фамилией Allen, чьи имена начинаются с буквы K (Kim, Karl и т. п.). Полное совпадение со столбцом last_name и поиск по диапазону значений столбца first_name.)

                    - Запросы только по индексу

            У B-Tree-индексов есть некоторые ограничения:

                - Они бесполезны, если в критерии поиска указана не самая левая часть ключа индекса. Например, рассматриваемый индекс не поможет найти людей с именем Bill или всех людей с определенной датой рождения, поскольку эти столбцы не являются самыми левыми в индексе.

                - Нельзя пропускать столбцы индекса. То есть, невозможно найти всех людей, имеющих фамилию Smith и родившихся в конкретный день.

        - Хеш-индексы
        
            Хеш-индекс строится на основе хеш-таблицы и полезен только для точного поиска с указанием всех столбцов индекса. Для каждой строки подсистема хранения вычисляет хеш-код индексированных столбцов – сравнительно короткое значение, которое, скорее всего, будет различно для строк с разными значениями ключей. В индексе хранятся хеш-коды и указатели на соответствующие строки. В MySQL только подсистема хранения Memory поддерживает явные хеш-индексы.

            Подсистема хранения InnoDB поддерживает так называемые адаптивные хеш-индексы. Когда InnoDB замечает, что доступ к некоторым значениям индекса происходит очень часто, она строит для них хеш-индекс в памяти, помимо уже имеющихся B-Tree-индексов. Тем самым к B-Tree-индексам добавляются некоторые свойства хеш-индексов, например очень быстрый поиск. Этот процесс полностью автоматический, и вы не можете ни контролировать, ни настраивать его.

            Ограничения:

                - Поскольку индекс содержит только хеш-коды и указатели на строки, а не сами значения, MySQL не может использовать данные в индексе, чтобы избежать чтения строк. К счастью, доступ к строкам в памяти очень быстр, так что обычно это не снижает производительность.

                - MySQL не может использовать хеш-индексы для сортировки, поскольку строки в нем не хранятся в отсортированном порядке.

                - Хеш-индексы поддерживают только сравнения на равенство, использующие операторы =, IN() и <=> (обратите внимание, что <> и <=> – разные операторы). Они не ускоряют поиск по диапазону, например WHERE price > 100.

                - Доступ к данным в хеш-индексе очень быстр, если нет большого количества коллизий (нескольких значений с одним и тем же хеш-кодом).

                - Некоторые операции обслуживания индекса могут оказаться медленными, если количество коллизий велико.

            Использовать:

                Идея проста: создайте псевдохеш-индекс поверх стандартного B-Tree-индекса. Он будет не совсем идентичен настоящему хеш-индексу, поскольку для поиска по-прежнему будет использоваться B-Tree-индекс. Однако искаться будут хеш-коды ключей вместо самих ключей. От вас требуется лишь вручную указать хеш-функцию во фразе WHERE запроса. Примером хорошей работы подобного подхода является поиск адресов URL. B-Tree-индексы по адресам URL обычно оказываются очень большими, поскольку сами URL длинные. Обычно запрос к таблице адресов URL выглядит примерно так: SELECT id FROM url WHERE url="http://www.mysql.com". Но если удалить индекс по столбцу url и добавить в таблицу индексированный столбец url_crc, то можно переписать этот запрос в таком виде: SELECT id FROM url WHERE url="http://www.mysql.com" AND url_crc=CRC32("http://www.mysql.com"). Этот подход хорошо работает, поскольку оптимизатор запросов MySQL замечает, что существует небольшой высокоизбирательный индекс по столбцу url_crc, и осуществляет поиск в индексе элементов с этим значением (в данном случае 1560514994). Даже если несколько строк имеют одно и то же значение url_crc, эти строки очень легко найти с помощью быстрого целочисленного сравнения, а затем отыскать среди них то, которое в точности соответствует полному адресу URL. Альтернативой является индексирование URL как строки, что происходит значительно медленнее. При таком подходе не следует использовать хеш-функции SHA1() или MD5(). Они возвращают очень длинные строки, которые требуют много пространства и приводят к замедлению сравнения. Если в таблице большое количество строк и функция CRC32() дает слишком много коллизий, реализуйте собственную 64-разрядную хеш-функцию. Такая функция должна возвращать целое число, а не строку.

        - Пространственные индексы (Spatial, R-Tree)

            MyISAM поддерживает пространственные индексы, которые можно строить по стобцам пространственного типа, например GEOMETRY. Однако для того чтобы R-Tree индексы работали, необходимо использовать геоинформационные функции MySQL, например MBRCONTAINS().
        
        - Полнотекстовые (FULLTEXT) индексы
            
            Специальный тип индекса для таблиц типа MyISAM. Он позволяет искать в тексте ключевые слова, а не сравнивать искомое значение со значениями в столбце. Полнотекстовые индексы предназначены для операций MATCH AGAINST, а не обычных операций с фразой WHERE.

        - Кластерные индексы

            Кластерные индексы не являются отдельным типом индекса. Скорее, это подход к хранению данных. В InnoDB кластерный индекс фактически содержит и B-Tree- индекс, и сами строки в одной и той же структуре.

            Моралью всей этой истории является то, что при использовании InnoDB вам нужно стремиться к вставке данных в порядке, соответствующем первичному ключу, и стараться использовать такой кластерный ключ, который монотонно возрастает для новых строк.

        - Покрывающие индексы

            Индексы являются средством эффективного поиска строк, но MySQL может также использовать индекс для извлечения данных, не считывая строку таблицы. Рассмотрим преимущества считывания индекса вместо самих данных:

                1. Записи индекса обычно компактнее полной строки, поэтому, если MySQL читает только индекс, то обращается к значительно меньшему объему данных.

                2. Индексы отсортированы по индексируемым значениям (по крайней мере, внутри страницы), поэтому для поиска по диапазону, характеризуемому большим объемом ввода/вывода, потребуется меньше операций обращения к диску по сравнению с извлечением каждой строки из произвольного места хранения.

                3. Большинство подсистем хранения кэширует индексы лучше, чем сами данные

                4. Покрывающие индексы особенно полезны в случае таблиц InnoDB из-за кластерных индексов.

        - Упакованные (сжатые по префиксу) индексы

            MyISAM использует префиксное сжатие для уменьшения размера индекса, обеспечивая таким образом размещение большей части индекса в памяти и значительное увеличение производительности в некоторых случаях. По умолчанию эта подсистема хранения упаковывает только строковые значения например, если первым значением является слово «perform», а вторым – «performance», то второе значение будет записано как «7,ance»., но вы можете затребовать также сжатие целочисленных значений. Наши тесты показали, что при большой загрузке процессора упакованные ключи замедляют поиск по индексу в таблицах MyISAM в несколько раз

        - Избыточные и дублирующие индексы

            MySQL позволяет создавать несколько индексов по одному и тому же столбцу. Она не «замечает» и не защищает вас от таких ошибок. СУБД MySQL должна обслуживать каждый дублирующий индекс отдельно, а оптимизатор запросов в своей работе будет учитывать их все. Это может вызвать серьезное падение производительности. 

            Использовать:

                Дублирующими являются индексы одного типа, созданные на основе того же набора столбцов в одинаковом порядке. Старайтесь избегать их создания, а если найдете – удаляйте. Иногда можно создать дублирующие индексы, даже не ведая о том. Например, взгляните на следующий код:

                    CREATE TABLE test (
                        id INT NOT NULL PRIMARY KEY,
                        UNIQUE(ID),
                        INDEX(ID)
                    )

                    MySQL реализует ограничения UNIQUE и PRIMARY KEY с помощью индексов, так что на деле создаются три индекса по одному и тому же столбцу!

    Стратегии индексирования для достижения высокой производительности.

        1. Изоляция столбца. MySQL обычно не может использовать индекс по столбцу, если этот столбец не изолирован в запросе. «Изоляция» столбца означает, что он не должен быть частью выражения или употребляться в качестве аргумента внутри функции. Например: SELECT author_id FROM authors WHERE author_id + 1 = 5;

        2. Иногда нужно проиндексировать очень длинные символьные столбцы, из-за чего индексы становятся большими и медленными. Вы можете сэкономить пространство и получить хорошую производительность, проиндексировав первые несколько символов, а не все значение. Префикс столбца часто оказывается весьма избирательным, чтобы обеспечить хорошую производительность. Если вы индексируете столбцы типа BLOB или TEXT, либо очень длинные столбцы типа VARCHAR, то обязаны определять префиксные индексы, поскольку MySQL не позволяет индексировать такие столбцы по их полной длине. Сложность заключается в выборе длины префикса, которая должна быть достаточно велика, чтобы обеспечить хорошую селективность, но не слишком велика, чтобы сэкономить пространство. Теперь, отыскав подходящую длину префикса для наших тестовых данных, создадим индекс по префиксу столбца: ALTER TABLE sakila.city_demo ADD KEY (city(7)). Префиксные индексы могут стать хорошим способом уменьшения размера и повышения быстродействия индекса, но у них есть и недостатки - MySQL не может использовать префиксные индексы для запросов с фразами ORDER BY и GROUP BY.

        3. В СУБД MySQL есть два способа получения отсортированных результатов: использовать файловую сортировку или просматривать индекс по порядку. Просмотр самого индекса производится быстро, поскольку сводится просто к перемещению от одной записи к другой. Однако если СУБД MySQL не использует индекс для «покрытия» запроса, ей приходится считывать каждую строку, которую она находит в индексе. Сортировка результатов по индексу работает только в тех случаях, когда порядок элементов в точности соответствует порядку, указанному во фразе ORDER BY, а все столбцы отсортированы в одном направлении (по возрастанию или по убыванию). Если в запросе соединяется несколько таблиц, то необходимо, чтобы во фразе ORDER BY упоминались только столбцы из первой таблицы. Фраза ORDER BY имеет те же ограничения, что и поисковые запросы: должен быть указан самый левый префикс ключа. Во всех остальных случаях MySQL использует файловую сортировку.

        Использовать:

            MySQL может использовать один и тот же индекс как для сортировки, так и для поиска строк. По возможности старайтесь проектировать индексы так, чтобы они были полезны для решения обеих задач.

        4. В InnoDB если запрос не обращается к строкам, которые ему не нужны, то блокируется меньше строк, и это лучше для производительности. InnoDB блокирует строки только в момент доступа к ним, а индекс позволяет уменьшить количество строк, к которым обращается InnoDB. Однако это работает только в том случае, когда InnoDB может отфильтровывать ненужные строки на уровне подсистемы хранения.

    Использовать:

        Постарайтесь избежать распространенной ошибки – создавать индексы без знания того, какие запросы будут их использовать. Иногда у вас будут запросы различных типов, и вы не сможете добавить оптимальные индексы для каждого из них. Тогда вам потребуется идти на компромисс. Где это возможно, старайтесь расширять существующие индексы, а не добавлять новые. Обычно эффективнее поддерживать один многостолбцовый индекс, чем несколько одностолбцовых.

    Использовать (Практические примеры индексирования):

        Предположим, нам нужно спроектировать интерактивный сайт знакомств с профилями пользователей, в которые включены различные столбцы, например: страна, регион, город, пол, возраст, цвет глаз и т.п. Сайт должен поддерживать поиск в профилях по различным комбинациям этих свойств. Он также должен позволять пользователю сортировать и фильтровать результаты по времени последнего посещения сайта владельцем профиля, по оценкам его другими пользователями и т.д. 

        Как ни странно, первое, что мы должны решить, будем ли мы использовать сортировку с помощью индексов или подойдет обычная сортировка (filesort). Сортировка с помощью индексов налагает ограничения на то, как должны быть построены индексы и запросы. Например, мы не можем использовать индекс для фразы WHERE age BETWEEN 18 AND 25, если в том же самом запросе индекс используется для сортировки пользователей по оценкам, которые дают им другие пользователи. Если СУБД MySQL задействует в запросе индекс для поиска по диапазону, то она не может использовать другой индекс (или суффикс того же самого индекса) с целью упорядочивания. Учитывая, что это будет одна из самых распространенных фраз WHERE, мы считаем само собой разумеющимся, что для многих запросов потребуется обычная сортировка (filesort).

        Теперь нам нужно посмотреть, какие столбцы содержат много различных значений, и какие столбцы появляются во фразах WHERE чаще всего. Индексы по столбцам с большим количеством различных значений будут высокоселективны. Обычно это хорошо, поскольку высокая селективность позволяет MySQL более эффективно отфильтровывать ненужные строки.

        Если вы видите необходимость в индексе, но считаете, что он может оказать негативное влияние на некоторые запросы, спросите себя: нельзя ли изменить запросы? Оптимизируйте запросы и индексы одновременно, чтобы найти наилучший компромисс. Нельзя спроектировать хорошую схему индексирования в вакууме.

    Обслуживание индексов и таблиц.

        После того как вы создали таблицы с нужными типами данных и добавили индексы, ваша работа еще не закончена: таблицы и индексы еще требуется обслуживать с целью обеспечения нормальной работы. Тремя главными задачами обслуживания таблицы являются поиск и устранение повреждений, актуализация статистики по индексам и уменьшение фрагментации.

        Поврежденные индексы могут привести к тому, что запросы будут возвращать неправильные результаты, вызывать ошибки дублирования ключа, хотя дубликатов нет, и даже приводить к блокировкам и аварийным остановам. Если вы сталкиваетесь со странным поведением, например ошибками, которые, по вашему мнению, происходить просто не могут, – запустите команду CHECK TABLE, чтобы выяснить, не повреждена ли таблица (обратите внимание, что некоторые подсистемы хранения не поддерживают эту команду, а другие поддерживают многочисленные параметры, позволяющие указать, насколько тщательно нужно проверить таблицу). Команда CHECK TABLE обычно выявляет большинство ошибок в таблицах и индексах. Исправить поврежденную таблицу позволяет команда REPAIR TABLE, но и ее поддерживают не все подсистемы хранения. В таком случае можно выполнить «пустую» команду ALTER, например просто указав ту же подсистему, которая и так уже используется для таблицы. Вот пример для таблицы типа InnoDB: ALTER TABLE innodb_tbl ENGINE=INNODB;

        Чтобы создать статистику по индексам нужно выполнить команду ANALYZE TABLE. Так как команда ANALYZE TABLE для InnoDB пользуется случайной выборкой, собираемая статистика InnoDB менее точна, зато ее не требуется обновлять вручную, если только с момента последнего перезапуска сервера прошло не очень много времени. Команда ANALYZE TABLE в InnoDB не вызывает блокировок и является относительно недорогой, поэтому можно выполнять оперативное обновление статистики, практически не влияя на работу сервера.

        Вы можете выяснить кардинальность ваших индексов с помощью команды SHOW INDEX FROM table_name.

    Уменьшение фрагментации индекса и данных.

        B-Tree-индексы могут становиться фрагментированными, что приводит к уменьшению производительности. Фрагментированные индексы бывают плохо заполнены и/или располагаются на диске не в последовательном порядке. 

        Существуют два типа фрагментации данных:

            1. Фрагментация строки

                Этот тип фрагментации наблюдается тогда, когда строка хранится в виде нескольких фрагментов в разных местах. Фрагментация строки уменьшает производительность даже если запросу требуется только одна строка из индекса.

            2. Межстрочная фрагментация

                Этот тип фрагментации наблюдается тогда, когда логически последовательные страницы или строки хранятся на диске не последовательно. Она влияет на такие операции, как полное сканирование таблицы и сканирование диапазона кластерного индекса, для которых последовательное размещение данных на диске выгоднее.

    Нормализация и денормализация.

        В нормализованной базе данных каждый факт представлен один и только один раз. В денормализованной базе данных, наоборот, информация дублируется или хранится в нескольких местах.

        Нормализованные таблицы обычно обновляются быстрее, чем ненормализованные. Когда данные хорошо нормализованы, они либо редко дублируются, либо не дублируются совсем. Так что изменять приходится меньше данных. Нормализованные таблицы обычно меньше по размеру, поэтому лучше помещаются в памяти и их производительность выше. Из-за отсутствия избыточных данных реже возникает необходимость в запросах с фразами DISTINCT или GROUP BY для извлечения списков значений. Любой нетривиальный запрос к хорошо нормализованной схеме, скорее всего, потребует, по крайней мере одного, а то и нескольких соединений. Это не только дорого, но и делает некоторые стратегии индексирования невозможными.

        Достоинством денормализованной схемы является то, что все данные находятся в одной и той же таблице, что позволяет избежать соединений. Если вам не нужно соединять таблицы, то худшим случаем для большинства запросов – даже тех, которые не используют индексы, – будет полное сканирование таблицы. Это может быть значительно быстрее соединения.

        Истина заключается в том, что полностью нормализованные и полностью денормализованные схемы подобны лабораторным мышам: они редко имеют что-то общее с реальным миром. На практике часто приходится сочетать оба подхода, применяя частично нормализованные схемы, кэширующие таблицы, и другие приемы.

    Кэширующие и сводные таблицы.

        В некоторых случаях наилучший способ увеличения производительности состоит в том, чтобы сохранить избыточные данные в той же таблице, что и данные, от которых они произошли. Однако иногда требуется построить совершенно отдельную сводную или кэширующую таблицу, специально настроенную под ваши потребности для извлечения данных. Этот метод работает хорошо, если вы готовы смириться с некоторым устареванием информации.

        Термины «кэширующая таблица» и «сводная таблица» не являются общепринятыми. Мы используем понятие «кэширующая таблица» для обозначения таблиц, содержащих данные, которые можно легко, хотя и не так быстро, извлечь из схемы (т.е. логически избыточные данные). Под «сводными таблицами» мы понимаем таблицы, в которых хранятся агрегированные данные из запросов с фразой GROUP BY (т.е. данные, не являющиеся логически избыточными).

    Таблицы счетчиков.

        Приложения, хранящие счетчики в таблицах, могут испытывать проблемы совместного доступа при обновлении счетчиков. В веб-приложениях такие таблицы применяются очень часто. Вы можете использовать их для кэширования количества друзей пользователя, количества загрузок файла и т.п. Часто имеет смысл создать для счетчиков отдельную таблицу, что обеспечит ее малый размер и скорость работы.

    Ускорение работы команды ALTER TABLE.

        Если таблица велика и над ней построено много индексов, то это может занимать большой промежуток времени, особенно при недостатке памяти. Многие сталкивались с ситуацией, когда операция ALTER TABLE выполнялась несколько часов или даже дней.

    Быстрое построение индексов MyISAM.

        Обычным приемом для эффективной загрузки таблиц MyISAM являются отключение ключей, загрузка данных и повторное включение ключей:

            ALTER TABLE test.load_data DISABLE KEYS;

            Команды на загрузку файлов

            ALTER TABLE test.load_data ENABLE KEYS;

        Увы, данный прием не работает для уникальных индексов, поскольку модификатор DISABLE KEYS применяется только к неуникальным. MyISAM строит уникальные индексы в памяти и проверяет их уникальность при загрузке каждой строки. Как только размер индекса превысит объем доступной памяти, загрузка становится чрезвычайно медленной.
*/