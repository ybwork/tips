<?php

/*
    Глава 4. Оптимизация запрос.
*/

/*
    Если запрос составлен плохо, то даже самая лучшая схема базы не поможет.

    Главная причина, из-за которой запрос может выполняться медленно это слишком большой объем обрабатываемых данных. Но большинство запросов можно изменить так, чтобы они обращались к меньшему объему данных.

    Анализ медленно выполняющегося запроса нужно производить в два этапа:

        1. Понять, не извлекает ли приложение больше данных, чем нужно. Обычно это означает, что слишком велико количество отбираемых строк, но не исключено, что отбираются также лишние столбцы.

        2. Понять, не анализирует ли сервер MySQL больше строк, чем это необходимо.

    Не запрашиваете ли вы лишние данные у базы?

        Вот несколько типичных ошибок:

            - Выборка ненужных строк. 

                Широко распространено заблуждение, будто MySQL передает результаты по мере необходимости, а не формирует и возвращает весь результирующий набор целиком. Например, применяется такой прием: выполнить команду SELECT, которая возвращает много строк, затем выбрать первые строки и закрыть результирующий набор (скажем, отобрать 100 последних по времени статей на новостном сайте, хотя на начальной странице нужно показать только 10). Разработчик полагает, что MySQL вернет первые 10 строк, после чего прекратит выполнение запроса. Но на самом деле MySQL генерирует весь результирующий список. А клиентская библиотека получит полный набор данных и большую часть отбросит. Было бы гораздо лучше включить в запрос фразу LIMIT.

            - Выборка всех столбцов из соединения нескольких таблиц.

                Если нужно отобрать всех актеров, снимавшихся в фильме Academy Dinosaur, не пишите такой запрос:

                    SELECT * FROM sakila.actor INNER JOIN sakila.film_actor USING(actor_id) INNER JOIN sakila.film USING(film_id) WHERE sakila.film.title = ‘Academy Dinosaur’;

                Этот запрос возвращает все столбцы из всех трех таблиц. Правильнее составить этот запрос следующим образом:

                    SELECT sakila.actor.* FROM sakila.actor...;

            - Выборка всех столбцов.

                Наличие SELECT * должно вас насторожить. Неужели действительно нужны все столбцы без исключения? Скорее всего, нет.

    Не слишком ли много данных анализирует MySQL?

        Если вы уверены, что все запросы отбирают лишь необходимые данные, можно поискать запросы, которые анализируют слишком много данных для получения результата. 

        В MySQL простейшими метриками стоимости запроса являются:

            - Время выполнения

            - Количество проанализированных строк

            - Количество возвращенных строк

    Способы реструктуризации запросов.

        Целью оптимизации проблемных запросов должно стать отыскание альтернативных способов получения требуемого результата, хотя далеко не всегда это означает получение точно такого же результирующего набора от MySQL. Иногда удается преобразовать запрос в эквивалентную форму, добившись более высокой производительности. Но следует подумать и о приведении запроса к виду, дающему иной результат, если это позволяет повысить скорость выполнения. Можно даже изменить не только запрос, но и код приложения.

        Один сложный или несколько простых запросов?

            Традиционно при проектировании базы данных стараются сделать как можно больше работы с помощью наименьшего числа запросов. Но к MySQL данная рекомендация относится в меньшей степени, поскольку эта СУБД изначально проектировалась так, чтобы установление и разрыв соединения происходили максимально эффективно, а обработка небольших простых запросов выполнялась очень быстро. Современные сети гораздо быстрее, чем раньше, поэтому и сетевые задержки заметно сократились. MySQL способна выполнять свыше 50 000 простых запросов в секунду на типичном серверном оборудовании и свыше 2000 запросов в секунду от одиночного клиента в гигабитной сети, поэтому выполнение нескольких запросов может оказаться вполне приемлемой альтернативой.

            Но передача информации с использованием соединения все же происходит значительно медленнее. (запросы на выборку)

            Так что с учетом всех факторов по-прежнему лучше бы ограничиться минимальным количеством запросов, но иногда можно повысить скорость выполнения сложного запроса, разложив его на несколько более простых.

        Разбиение запроса на части.

            Отличный пример – удаление старых данных. В процессе периодической чистки иногда приходится удалять значительные объемы информации. Если делать это одним большим запросом, то возможны всяческие неприятные последствия: блокировки большого числа строк на длительное время, переполнение журналов транзакций, истощение ресурсов, блокировка небольших запросов, которые не допускают прерывания. Разбив команду DELETE на части, каждая из которых удаляет умеренное число строк, мы заметно повысим производительность.

        Декомпозиция соединения.

            На многих высокопроизводительных сайтах применяется техника декомпозиции соединений (join decomposition). Смысл ее заключается в том, чтобы выполнить несколько однотабличных запросов вместо одного запроса к нескольким объединенным таблицам, а соединение выполнить уже в приложении. Например, следующий запрос:

                SELECT * FROM tag JOIN tag_post ON tag_post.tag_id=tag.id JOIN post ON tag_post.post_id=post.id WHERE tag.tag=’mysql’;

            можно было бы заменить такими:

                SELECT * FROM tag WHERE tag=’mysql’;
                SELECT * FROM tag_post WHERE tag_id=1234;
                SELECT * FROM post WHERE post.id in (123,456,567,9098,8904);

            На первый взгляд, это расточительство, поскольку мы просто увеличили количество запросов, не получив ничего взамен. Тем не менее, такая реструктуризация может дать ощутимый выигрыш в производительности.

            Так же к плюсам декомпозиции соединения можно отнести:

                - Можно более эффективно реализовать кэширование. Во многих приложениях кэшируются «объекты», которые напрямую соответствуют таблицам.

                - Для подсистемы MyISAM запросы, обращающиеся только к одной таблице, позволяют более эффективно использовать блокировки, поскольку таблицы блокируются по отдельности и на краткий промежуток времени, а не коллективно и надолго.

                - Соединение результатов на уровне приложения упрощает масштабирование базы данных путем размещения разных таблиц на различных серверах.

                - Можно избавиться от лишних обращений к строкам. Если соединение производится на уровне приложения, то каждая строка извлекается ровно один раз, тогда как на уровне сервера эта операция по существу сводится к денормализации, в ходе которой обращение к одним и тем же данным может производиться многократно.

                - В какой-то мере эту технику можно считать ручной реализацией хеш-соединений вместо стандартного применяемого в MySQL алгоритма вложенных циклов.

        Основные принципы выполнения запросов.

            Если вы хотите получить максимальную производительность от своего сервера MySQL, то настоятельно рекомендуем потратить время на изу- чение того, как СУБД оптимизирует и выполняет запросы.

            Давайте посмотрим, что происходит, когда вы отправляете запрос на выполнение:

                - Клиент отправляет SQL-команду серверу.

                - Сервер смотрит, есть ли эта команда в кэше запросов. Если да, то возвращается сохраненный результат из кэша; в противном случае выполняется следующий шаг.

                - Сервер осуществляет разбор, предварительную обработку (preprocesing) и оптимизацию SQL-команды, преобразуя ее в план выполнения запроса.

                - Подсистема выполнения запросов выполняет этот план, обращаясь к подсистеме хранения.

                - Сервер отправляет результат клиенту.

        Клиент-серверный протокол MySQL.

            Это полудуплексный протокол, то есть в любой момент времени сервер либо отправляет, либо принимает сообщения, но не то и другое вместе. Кроме того, это означает, что невозможно оборвать сообщение «на полуслове».

            Данный протокол обеспечивает простое и очень быстрое взаимодействие с MySQL, но имеет кое-какие ограничения. Во-первых, в нем отсутствует механизм управления потоком данных: после того как одна сторона отправила сообщение, другая должна получить его целиком и только потом сможет ответить.

            Напротив, ответ сервера обычно состоит из нескольких пакетов данных. Клиент обязан получить весь результирующий набор, отправленный сервером. Нельзя выбрать только первые несколько строк и попросить сервер не посылать остальное. Если клиенту все-таки нужны именно первые строки, то у него есть два варианта действий: дождаться прихода всех отправленных сервером пакетов и отбросить ненужные, или бесцеремонно разорвать соединение. Оба метода не слишком привлекательны, поэтому фраза LIMIT так важна.

            Пока все строки не будут получены, сервер MySQL не освобождает блокировки и другие ресурсы, потребовавшиеся для выполнения запроса.

        Кэш запросов.

            Еще перед тем как приступать к разбору запроса, MySQL проверяет, нет ли его в кэше запросов (если режим кэширования включен). При этом производится поиск в хеш-таблице с учетом регистра ключа. Если поступивший запрос отличается от хранящегося в кэше хотя бы в одном байте, запросы считаются разными, и сервер переходит к следующей стадии обработки запроса.

        Процесс оптимизации запроса.

            Следующий шаг в жизненном цикле запроса – преобразование SQL-команды в план выполнения. Он состоит из нескольких этапов: разбор, предварительная обработка и оптимизация.

        Оптимизатор запросов.

            Теперь, когда дерево разбора тщательно проверено, наступает очередь оптимизатора, который превращает его в план выполнения запроса. В MySQL используется стоимостный оптимизатор, пытающийся предсказать стоимость различных планов выполнения и выбрать из них наиболее дешевый. Оптимизатор не учитывает влияния кэширования – предполагается, что любое чтение сводится к операции дискового ввода/вывода.

            Принятая метрика стоимости не всегда эквивалентна истинной стоимости выполнения запроса, поэтому даже когда статистика точна, запрос может оказаться дороже или дешевле оценки MySQL. 

            MySQL не берет в расчет другие одновременно выполняющиеся запросы, а они могут повлиять на время обработки оптимизируемого.

        Типы оптимизации:
            
            - Изменение порядка соединения (Таблицы не обязательно соединять именно в том порядке, который указан в запросе. Определение наилучшего порядка соединения – важная оптимизация)

            - Преобразование OUTER JOIN в INNER JOIN

            - Оптимизации COUNT(), MIN() и MAX() - наличие индексов и сведений о возможности хранения NULL-значений в столбцах часто позволяет вообще не вычислять эти выражения.

            - Вычисление и свертка константных выражений (Если MySQL обнаруживает, что выражение можно свернуть в константу, то делает это на стадии оптимизации. Например, определенную пользователем переменную можно преобразовать в константу, если она не изменяется в запросе.)

            - Покрывающие индексы (Если индекс содержит все необходимые запросу столбцы, то MySQL может воспользоваться им, вообще не читая данные таблицы.)

            - Оптимизация подзапросов (MySQL умеет преобразовывать некоторые виды подзапросов в более эффективные эквивалентные формы, сводя их к поиску по индексу.)

            - Раннее завершение (MySQL может прекратить обработку запроса, как только поймет, что этот запрос или шаг полностью выполнен. Очевидный пример – фраза LIMIT или заведомо невыполнимое условие после которого MySQL может прекратить обработку всего запроса.)

            - Сравнение по списку IN (здесь перечисленные в списке IN()значения сортируются, и для работы с ним применяется быстрый двоичный поиск.)

            Главная мысль, которую следует вынести из этого списка, – не пытайтесь перехитрить оптимизатор. В конечном итоге вы просто потерпите неудачу или сделаете свои запросы чрезмерно запутанными и трудными для сопровождения, не получив ни малейшей выгоды. Позвольте оптимизатору заниматься своим делом.

        Использовать:

            Если вы уверены, что оптимизатор дает плохой результат и знаете, почему, то можете ему помочь. Вариантов тут несколько: включить в запрос подсказку (hint), переписать запрос, перепроектировать схему или добавить индексы.
*/

/*
    Стратегия выполнения соединений в MySQL.

        Под соединениями понимаются все запросы, а не только те, что сопоставляют строки из двух таблиц. Еще раз подчеркнем: имеются в виду все без исключения запросы, в том числе подзапросы и даже выборка SELECT из одной таблицы.

        Это означает, что MySQL в цикле перебирает строки из одной таблицы, а затем во вложенном цикле ищет соответствующие строки в следующей. И так со всеми соединяемыми таблицами. После этого СУБД строит и возвращает строку, составленную из перечисленных в списке SELECT столбцов. Далее MySQL пытается найти следующую строку в последней таблице. Если такой не оказывается, то производится возврат на одну таблицу назад и попытка найти дополнительные строки в ней. MySQL продолжает выполнять возвраты, пока в какой-то таблице не обнаружится подходящая строка, после чего ищет соответствующую ей строку в следующей таблице и т.д.

        Этот процесс называется «соединение методом вложенных циклов».
*/

/*
    Оптимизатор соединений.

    Важнейшая часть оптимизатора запросов в MySQL – это оптимизатор соединений, который определяет наилучший порядок выполнения запросов с несколькими таблицами.
*/

/*
    Оптимизации сортировки.

    Сортировка результатов может оказаться дорогостоящей операцией, поэтому зачастую производительность можно повысить, избежав сортировки вовсе или уменьшив количество сортируемых строк.

    Существует два алгоритма файловой сортировки:

        - Двухпроходный (старый). Двухпроходный алгоритм обходится довольно дорого, поскольку читает строки из таблицы дважды, и второе чтение вызывает много непоследовательных операций ввода/вывода.

        - Однопроходный (новый). Этот алгоритм может показывать гораздо более высокую скорость, особенно на больших наборах данных. Однопроходный алгоритм не читает строки из таблицы дважды, а случайный ввод/вывод в нем заменяется последовательным чтением.
*/

/*
    Подсистема выполнения запросов.

    На стадиях разбора и оптимизации вырабатывается план выполнения запроса, который затем передается подсистеме выполнения.

    Как правило, стадия выполнения гораздо проще, чем стадия оптимизации: MySQL просто следует инструкциям, содержащимся в плане.
*/

/*
    Возврат результатов клиенту.

    Последняя стадия выполнения запроса – отправка ответа клиенту. Даже для тех запросов, которые не возвращают результирующий набор, сервер должен послать клиенту информацию о результате обработки, например сообщить, сколько строк было изменено. Если запрос можно кэшировать, то на этой стадии MySQL помещает результаты в кэш запросов.
*/

/*
    Ограничения оптимизатора MySQL.

    Использовать:

        Иногда MySQL очень плохо оптимизирует подзапросы. Самый неприятный случай – подзапросы в операторе IN() во фразе WHERE. SELECT * FROM film WHERE film_id IN(SELECT film_id FROM film_actor WHERE actor_id = 1)

        Впрочем, такой запрос легко переписать с использованием оператора JOIN. SELECT film.* FROM film INNER JOIN film_actor USING(film_id) WHERE actor_id = 1;

        Еще одна неплохая оптимизация – вручную сгенерировать список IN(), выполнив вместо подзапроса отдельный запрос с функцией GROUP_CONCAT(). Иногда это оказывается быстрее, чем JOIN.

        Не всегда MySQL так уж плохо оптимизирует подзапросы с IN(). Если вам рекомендуют любой ценой избегать их, не слушайте! Измеряйте производительность и принимайте решение самостоятельно.
*/

/*
    Ограничения UNION.

    Использовать:

        Например, в ситуации, когда вы объединяете две очень большие таблицы и ограничиваете результат первыми 20 строками, MySQL сначала запишет обе таблицы во временную, а из нее выберет всего 20 строк. Этого можно избежать, включив ограничение LIMIT 20 в каждую часть UNION.
*/

/*
    Оптимизация слияния индексов.

    Алгоритмы слияния индексов позволяют использовать при выполнении запроса несколько индексов по одной таблице.

    Если ваш запрос работает медленнее, чем ожидается, из-за этой особенности оптимизатора, то можно попробовать обходной путь – запретить использование некоторых индексов с помощью подсказки IGNORE INDEX
*/

/*
    Параллельное выполнение.
    
    Использовать:

        MySQL не умеет распараллеливать выполнение одного запроса на нескольких ЦП. Эту возможность предлагают многие СУБД, но только не MySQL. Мы упоминаем о ней лишь для того, чтобы вы не тратили время в попытках понять, как же заставить MySQL выполнять запрос параллельно!
*/

/*
    Хеш-соединения.

    Использовать:

        В настоящее время MySQL не умеет выполнять настоящие хеш-соединения, любое соединение производится методом вложенных циклов.
*/

/*
    Непоследовательный просмотр индекса.

    Исторически MySQL никогда не умела выполнять непоследовательный просмотр индекса (loose index scan), то есть просмотр несмежных диапазонов индекса. При просмотре индекса всегда необходимо было задавать начальную и конечную точку, даже если для запроса нужно всего несколько несмежных строк в середине диапазона. MySQL просматривает весь диапазон строк между двумя заданными точками. 
*/

/*
    Функции MIN() и MAX().

    MySQL не очень хорошо оптимизирует некоторые запросы, содержащие агрегатные функции MIN() и MAX().

    Использовать:

        Обходное решение – исключить MIN() и переписать запрос с применением LIMIT. SELECT actor_id FROM actor USE INDEX(PRIMARY) WHERE first_name = ‘PENELOPE’ LIMIT 1
*/

/*
    SELECT и UPDATE для одной и той же таблицы.

    MySQL не позволяет производить выборку из таблицы (SELECT) одновременно с ее обновлением (UPDATE).

    Использовать:

        SELECT и UPDATE для одной и той же таблицы можно обойти с помощью такого запроса: UPDATE tbl AS outer_tbl SET cnt = (SELECT count(*) FROM tbl AS inner_tbl WHERE inner_tbl.type = outer_tbl.type)

        Этот запрос обновляет каждую строку, записывая в нее количество похожих строк в той же таблице
*/

/*
    Оптимизация запросов с COUNT().

    COUNT() – это особая функция, которая решает две очень разные задачи: подсчитывает значения и строки.

    Значение – это выражение, отличное от NULL. Если указать имя столбца или какое-нибудь другое выражение в скоб-ках, то COUNT() посчитает, сколько раз это выражение имеет значение.

    Вторая форма COUNT() просто подсчитывает количество строк в результирующем наборе. Так MySQL поступает, когда точно знает, что выражение внутри скобок не может быть равно NULL. Наиболее очевидный пример – выражение COUNT(*), специальная форма COUNT(), которая вовсе не сводится к подстановке вместо метасимвола * полного списка столбцов таблицы, как вы, возможно, подумали. На самом деле столбцы вообще игнорируются, а подсчитываются сами строки.

    Использовать:

        Одна из наиболее часто встречающихся ошибок – задание имени столбца в скобках, когда требуется подсчитать строки. Если вы хотите знать, сколько строк в результирующем наборе, всегда употребляйте COUNT(*). Тем самым вы недвусмысленно сообщите о своем намерении и избежите возможного падения производительности.

    Распространено неверное представление о том, что для таблиц типа MyISAM запросы, содержащие функцию COUNT(), выполняются очень быстро. Так-то оно так, но лишь в очень частном случае: COUNT(*) без фразы WHERE, то есть при подсчете общего количества строк в таблице.
    
    Использовать:

        В общем случае запросы, содержащие COUNT(), с трудом поддаются оптимизации, поскольку обычно они должны подсчитать много строк. Единственная возможность внутри самого сервера MySQL – воспользоваться покрывающим индексом. Если этого недостаточно, рекомендуется внести изменения в архитектуру приложения. Можно рассмотреть вариант заведения сводных таблиц или применить внешнюю систему кэширования, скажем, memcached.
*/

/*
    Оптимизация запросов с JOIN.
    
    Использовать:

        Стройте индексы по столбцам, используемым во фразах ON или USING. При добавлении индексов учитывайте порядок соединения. Если таблицы A и B соединяются по столбцу С и оптимизатор решит, что их надо соединять в порядке B, A, то индексировать таблицу B необязательно. Неиспользуемые индексы только влекут за собой лишние накладные расходы. В общем случае следует индексировать только вторую таблицу в порядке соединения, если, конечно, индекс не нужен для каких-то других целей.

        Старайтесь, чтобы в выражениях GROUP BY и ORDER BY встречались столбцы только из одной таблицы, тогда у MySQL появится возможность воспользоваться для этой операции индексом.
*/

/*
    Оптимизация подзапросов.
    
    Использовать:
    
        Самая важная рекомендация, которую мы можем дать относительно подзапросов, – стараться по возможности использовать вместо них соединение, по крайней мере, в текущих версиях MySQL.
*/

/*
    Оптимизация GROUP BY и DISTINCT.
    
    Использовать:

        Если нужна группировка по значению столбца, который извлекается при соединении из справочной таблицы, то обычно более продуктивно группировать по идентификатору из этой таблицы, а не по его значению. (т.е. GROUP BY user_id)
*/

/*
    Оптимизация LIMIT со смещением.

    Использовать:

        Запросы, содержащие ключевые слова LIMIT и OFFSET, часто встречаются в системах, производящих разбиение на страницы, и неизменно в сочетании с ORDER BY. Полезно иметь индекс, поддерживающий нужное упорядочение, иначе серверу придется слишком часто прибегать к файловой сортировке.
        
        Типичная проблема – слишком большое смещение. Если в запросе встречается фраза LIMIT 10000, 20, то сервер сгенерирует 10020 строк и отбросит первые 10000, а это очень дорого. Один из простых приемов повышения производительности – выполнять смещение, пользуясь покрывающим индексом, а не исходной таблицей. SELECT film.film_id, film.description FROM sakila.film INNER JOIN (SELECT film_id FROM sakila.film ORDER BY title LIMIT 50, 5) AS lim USING(film_id)

        Выигрыш достигается за счет того, что серверу приходится просматривать только индекс, не обращаясь к самим строкам. А после того, как нужные строки найдены, они соединяются с исходной таблицей для выборки недостающих столбцов.

        Если вы хотите по-настоящему оптимизировать разбиение на страницы, то имеет смысл предварительно вычислять итоги. В качестве альтернативы можно предложить соединение со вспомогательными таблицами, которые содержат только первичный ключ и столбцы, необходимые для выполнения ORDER BY. Можно также воспользоваться поисковой системой Sphinx.   
*/

/*
    Оптимизация UNION.

    Использовать:

        MySQL всегда выполняет запросы с UNION путем создания и заполнения временной таблицы. К подобным запросам MySQL может применить не так уж много оптимизаций. Но вы в состоянии помочь оптимизатору, «опустив вниз» фразы WHERE, LIMIT, ORDER BY и другие условия (то есть скопировав их из внешнего запроса в каждый SELECT, входящий в объединение). 

        Очень важно всегда употреблять UNION ALL, если только вы не хотите, чтобы сервер устранял строки-дубликаты. Когда ключевое слово ALL отсутствует, MySQL будет создавать временную таблицу в режиме distinct, а это значит, что для соблюдения уникальности производится сравнение строк целиком. Такая операция обойдется очень недешево.
*/

/*
    Подсказки оптимизатору запросов.
    
    В СУБД MySQL имеется ряд подсказок оптимизатору запросов, которыми можно воспользоваться, чтобы повлиять на выбор плана выполнения, если тот, что предложен оптимизатором, вас не удовлетворяет. Подсказка включается в запрос, чей план выполнения вы хотите изменить, и действует только для этого запроса. Список:

        - HIGH_PRIORITY и LOW_PRIORITY. 

            Подсказка HIGH_PRIORITY означает, что MySQL должен поместить команду SELECT в очередь раньше всех прочих, ожидающих получения блокировок для модификации данных. Иными словами, команда SELECT должна быть выполнена как можно быстрее, а не ожидать своей очереди. Подсказка LOW_PRIORITY оказывает обратное действие: в этом случае команда будет ждать завершения всех остальных команд, желающих обратиться к тем же таблицам, даже если они были отправлены позже.

            Обе подсказки работают с подсистемами хранения, в которых реализована блокировка на уровне таблиц, но в InnoDB необходимости в них возникать не должно.

            Будьте осторожны, применяя их к таблицам типа MyISAM, поскольку таким образом можно запретить одновременные вставки и существенно понизить производительность.

        - DELAYED

            Эта подсказка применяется к командам INSERT и REPLACE. Команда с данной подсказкой возвращает управление немедленно, а подлежащие вставке строки помещаются в буфер и будут реально вставлены все сразу, когда таблица освободится. Чаще всего это бывает полезно для протоколирования и аналогичных приложений, в которых нужно записывать много строк, не заставляя клиента ждать и не выполняя операцию ввода/вывода для каждой команды в отдельности.

        - STRAIGHT_JOIN

            Эта подсказка может встречаться сразу после ключевого слова SELECT в команде SELECT или в любой другой команде между двумя соединяемыми таблицами. В первом случае она говорит серверу, что указанные в запросе таблицы нужно соединять в порядке перечисления. Во втором случае она задает порядок соединения таблиц, между которыми находится.

            Подсказка STRAIGHT_JOIN полезна, если выбранный MySQL порядок соединения не оптимален или оптимизатор тратит чересчур много времени на выбор порядка.

        - SQL_SMALL_RESULT и SQL_BIG_RESULT

            Эти подсказки применимы только к команде SELECT. Они говорят оптимизатору, когда и как использовать временные таблицы или сортировку при выполнении запросов с GROUP BY или DISTINCT. SQL_SMALL_RESULT означает, что результирующий набор будет невелик, так что его можно поместить в индексированную временную таблицу, чтобы не сортировать для группировки. Напротив, SQL_BIG_RESULT означает, что результат велик, и лучше использовать временные таблицы на диске с последующей сортировкой.

        - SQL_BUFFER_RESULT

            Эта подсказка говорит оптимизатору, что результаты нужно поместить во временную таблицу и как можно скорее освободить табличные блокировки.

        - SQL_CACHE и SQL_NO_CACHE

            Эти подсказки говорят серверу о том, что данный запрос является или не является кандидатом на помещение в кэш запросов.

        - SQL_CALC_FOUND_ROWS

            Эта подсказка заставляет MySQL вычислить весь результирующий набор, даже если имеется фраза LIMIT, ограничивающая количество возвращаемых строк.

        - FOR UPDATE и LOCK IN SHARE MODE

            Эти подсказки управляют блокировками для команд SELECT. Они позволяют поставить блокировки на найденные строки, что бывает полезно, когда заранее известно, что эти строки нужно будет обновить. Когда писалась эта книга, лишь подсистема InnoDB позволяла использовать данные подсказки, и пока слишком рано говорить, поддержат ли их в будущем другие подсистемы хранения

        - USE INDEX, IGNORE INDEX и FORCE INDEX

            Эти подсказки говорят оптимизатору о том, какие индексы использовать или игнорировать при поиске строк в таблице

            FORCE INDEX – то же самое, что USE INDEX, но эта подсказка сообщает оптимизатору о том, что сканирование таблицы обойдется гораздо дороже поиска по индексу, даже если индекс не очень полезен.
*/

/*
    Переменные, определяемые пользователем.

    Определяемые пользователем переменные – это временные контейнеры, хранящие некоторые значения. Их существование ограничено временем жизни соединения с сервером.

    SET @one := 1;
    SET @min_actor := (SELECT MIN(actor_id) FROM sakila.actor);

    Затем эти переменные можно использовать в различных местах выражения: SELECT ... WHERE col <= @min_actor;

    Эти переменные нельзя использовать тех местах, где требуется литерал или идентификатор, например вместо имени таблицы или столбца либо во фразе LIMIT. Они связаны с конкретным соединением, поэтому не годятся для передачи информации между соединениями. Они подавляют кэширование запроса.
*/

/*
    Осторожнее при переходе на новые версии MySQL.

    После перехода на новую версию может оказаться, что некоторые запросы работают хуже, чем раньше.
*/